{
  "tests": [
    {
      "id": 1,
      "title": "Mạng Máy Tính",
      "timeLimit": 3600,
      "questions": [
        {
          "id": 1,
          "question": "Mạng LAN là viết tắt của cụm từ nào?",
          "options": [
            "Large Area Network",
            "Local Area Network",
            "Long Access Network",
            "Light Area Network"
          ],
          "correctAnswer": "Local Area Network"
        },
        {
          "id": 2,
          "question": "Mô hình OSI có bao nhiêu tầng?",
          "options": ["5", "6", "7", "8"],
          "correctAnswer": "7"
        },
        {
          "id": 3,
          "question": "Giao thức nào sau đây hoạt động ở tầng Transport trong mô hình TCP/IP?",
          "options": ["IP", "TCP", "HTTP", "FTP"],
          "correctAnswer": "TCP"
        },
        {
          "id": 4,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Network?",
          "options": ["Switch", "Router", "Hub", "Repeater"],
          "correctAnswer": "Router"
        },
        {
          "id": 5,
          "question": "Địa chỉ IP nào sau đây là địa chỉ lớp B?",
          "options": ["10.0.0.1", "172.16.0.1", "192.168.1.1", "224.0.0.1"],
          "correctAnswer": "172.16.0.1"
        },
        {
          "id": 6,
          "question": "Giao thức nào sau đây được sử dụng để truyền tải website?",
          "options": ["FTP", "SMTP", "HTTP", "Telnet"],
          "correctAnswer": "HTTP"
        },
        {
          "id": 7,
          "question": "Subnet mask 255.255.255.0 tương đương với ký hiệu CIDR nào?",
          "options": ["/16", "/24", "/8", "/32"],
          "correctAnswer": "/24"
        },
        {
          "id": 8,
          "question": "Thiết bị nào sau đây hoạt động dựa trên địa chỉ MAC?",
          "options": ["Router", "Switch", "Modem", "Repeater"],
          "correctAnswer": "Switch"
        },
        {
          "id": 9,
          "question": "Giao thức nào sau đây cung cấp dịch vụ truyền dữ liệu tin cậy?",
          "options": ["UDP", "TCP", "IP", "ARP"],
          "correctAnswer": "TCP"
        },
        {
          "id": 10,
          "question": "Mạng nào sau đây có phạm vi kết nối rộng nhất?",
          "options": ["LAN", "MAN", "WAN", "GAN"],
          "correctAnswer": "WAN"
        },
        {
          "id": 11,
          "question": "Giao thức nào chuyển đổi tên miền thành địa chỉ IP?",
          "options": ["SMTP", "FTP", "DNS", "HTTP"],
          "correctAnswer": "DNS"
        },
        {
          "id": 12,
          "question": "Mô hình kết nối mạng nào mà tất cả các máy tính đều kết nối vào một đường trục chung?",
          "options": ["Star", "Ring", "Mesh", "Bus"],
          "correctAnswer": "Bus"
        },
        {
          "id": 13,
          "question": "Cổng mặc định của giao thức HTTPS là bao nhiêu?",
          "options": ["80", "443", "25", "21"],
          "correctAnswer": "443"
        },
        {
          "id": 14,
          "question": "Địa chỉ IPv4 nào sau đây là địa chỉ broadcast của mạng 192.168.1.0/24?",
          "options": [
            "192.168.1.0",
            "192.168.1.1",
            "192.168.1.254",
            "192.168.1.255"
          ],
          "correctAnswer": "192.168.1.255"
        },
        {
          "id": 15,
          "question": "Kết nối nào sau đây thường được sử dụng cho mạng không dây?",
          "options": [
            "Cáp quang",
            "Cáp đồng trục",
            "Cáp xoắn đôi",
            "Sóng vô tuyến"
          ],
          "correctAnswer": "Sóng vô tuyến"
        },
        {
          "id": 16,
          "question": "Giao thức nào sau đây được sử dụng để gửi email?",
          "options": ["POP3", "IMAP", "SMTP", "HTTP"],
          "correctAnswer": "SMTP"
        },
        {
          "id": 17,
          "question": "Địa chỉ IP nào sau đây là địa chỉ private?",
          "options": [
            "8.8.8.8",
            "172.32.0.1",
            "192.168.1.100",
            "200.100.50.25"
          ],
          "correctAnswer": "192.168.1.100"
        },
        {
          "id": 18,
          "question": "Mô hình mạng nào có độ tin cậy cao nhất?",
          "options": ["Bus", "Star", "Ring", "Mesh"],
          "correctAnswer": "Mesh"
        },
        {
          "id": 19,
          "question": "Thiết bị nào sau đây thường được sử dụng để kết nối mạng LAN với Internet?",
          "options": ["Switch", "Hub", "Router", "Repeater"],
          "correctAnswer": "Router"
        },
        {
          "id": 20,
          "question": "Giao thức nào sau đây hoạt động ở tầng Application trong mô hình TCP/IP?",
          "options": ["TCP", "UDP", "IP", "FTP"],
          "correctAnswer": "FTP"
        },
        {
          "id": 21,
          "question": "Giao thức nào sau đây sử dụng cổng 21?",
          "options": ["HTTP", "HTTPS", "SMTP", "FTP"],
          "correctAnswer": "FTP"
        },
        {
          "id": 22,
          "question": "Kỹ thuật nào sau đây cho phép chia một mạng lớn thành các mạng con nhỏ hơn?",
          "options": ["Routing", "Switching", "Subnetting", "NAT"],
          "correctAnswer": "Subnetting"
        },
        {
          "id": 23,
          "question": "Địa chỉ nào sau đây được sử dụng để xác định một thiết bị cụ thể trong mạng?",
          "options": [
            "Địa chỉ mạng",
            "Địa chỉ broadcast",
            "Địa chỉ IP",
            "Địa chỉ cổng"
          ],
          "correctAnswer": "Địa chỉ IP"
        },
        {
          "id": 24,
          "question": "Giao thức nào sau đây không đảm bảo dữ liệu được truyền đến đích một cách tin cậy?",
          "options": ["TCP", "UDP", "HTTP", "FTP"],
          "correctAnswer": "UDP"
        },
        {
          "id": 25,
          "question": "Phương thức mã hóa nào sau đây được sử dụng trong HTTPS?",
          "options": ["DES", "AES", "SSL/TLS", "WPA2"],
          "correctAnswer": "SSL/TLS"
        },
        {
          "id": 26,
          "question": "Cáp mạng nào sau đây có tốc độ truyền dẫn cao nhất?",
          "options": [
            "Cáp đồng trục",
            "Cáp xoắn đôi UTP",
            "Cáp xoắn đôi STP",
            "Cáp quang"
          ],
          "correctAnswer": "Cáp quang"
        },
        {
          "id": 27,
          "question": "Địa chỉ IP nào sau đây là địa chỉ loopback?",
          "options": ["0.0.0.0", "127.0.0.1", "255.255.255.255", "192.168.1.1"],
          "correctAnswer": "127.0.0.1"
        },
        {
          "id": 28,
          "question": "Giao thức nào sau đây được sử dụng trong mạng cục bộ không dây (WLAN)?",
          "options": ["Ethernet", "Token Ring", "Wi-Fi", "Bluetooth"],
          "correctAnswer": "Wi-Fi"
        },
        {
          "id": 29,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Data Link và Physical?",
          "options": ["Router", "Switch", "Modem", "Repeater"],
          "correctAnswer": "Modem"
        },
        {
          "id": 30,
          "question": "Mô hình mạng nào mà các máy tính kết nối với nhau tạo thành một vòng tròn?",
          "options": ["Star", "Ring", "Mesh", "Bus"],
          "correctAnswer": "Ring"
        },
        {
          "id": 31,
          "question": "Lớp nào trong mô hình OSI chịu trách nhiệm mã hóa và giải mã dữ liệu?",
          "options": ["Application", "Presentation", "Session", "Transport"],
          "correctAnswer": "Presentation"
        },
        {
          "id": 32,
          "question": "Giao thức nào sau đây hoạt động ở cổng 25?",
          "options": ["HTTP", "HTTPS", "SMTP", "FTP"],
          "correctAnswer": "SMTP"
        },
        {
          "id": 33,
          "question": "Địa chỉ IPv4 nào sau đây là địa chỉ mạng?",
          "options": [
            "192.168.1.1",
            "192.168.1.0",
            "192.168.1.254",
            "192.168.1.255"
          ],
          "correctAnswer": "192.168.1.0"
        },
        {
          "id": 34,
          "question": "Kỹ thuật nào sau đây cho phép nhiều thiết bị sử dụng chung một địa chỉ IP công cộng?",
          "options": ["Subnetting", "Routing", "NAT", "VLAN"],
          "correctAnswer": "NAT"
        },
        {
          "id": 35,
          "question": "Giao thức nào sau đây được sử dụng để cấu hình địa chỉ IP tự động cho các thiết bị trong mạng?",
          "options": ["ARP", "DHCP", "ICMP", "DNS"],
          "correctAnswer": "DHCP"
        },
        {
          "id": 36,
          "question": "Thiết bị mạng nào hoạt động ở tầng physical layer?",
          "options": ["Switch", "Router", "Repeater", "Bridge"],
          "correctAnswer": "Repeater"
        },
        {
          "id": 37,
          "question": "Tầng nào chịu trách nhiệm định tuyến gói tin trong mô hình OSI?",
          "options": ["Data Link", "Network", "Transport", "Session"],
          "correctAnswer": "Network"
        },
        {
          "id": 38,
          "question": "Giao thức nào dưới đây KHÔNG phải là giao thức ở tầng Application",
          "options": ["HTTP", "FTP", "SMTP", "TCP"],
          "correctAnswer": "TCP"
        },
        {
          "id": 39,
          "question": "Lớp nào trong mô hình OSI chịu trách nhiệm thiết lập, duy trì và kết thúc các phiên kết nối?",
          "options": ["Application", "Presentation", "Session", "Transport"],
          "correctAnswer": "Session"
        },
        {
          "id": 40,
          "question": "Giao thức nào sau đây được sử dụng để kiểm tra kết nối mạng?",
          "options": ["ARP", "DHCP", "ICMP", "DNS"],
          "correctAnswer": "ICMP"
        },
        {
          "id": 41,
          "question": "Quá trình bắt tay ba bước (three-way handshake) được sử dụng trong giao thức nào?",
          "options": ["UDP", "TCP", "IP", "ICMP"],
          "correctAnswer": "TCP"
        },
        {
          "id": 42,
          "question": "Trong mô hình TCP/IP, tầng nào chịu trách nhiệm đóng gói dữ liệu thành các segment?",
          "options": ["Application", "Transport", "Internet", "Network Access"],
          "correctAnswer": "Transport"
        },
        {
          "id": 43,
          "question": "Đơn vị dữ liệu ở tầng Data Link được gọi là gì?",
          "options": ["Packet", "Segment", "Frame", "Datagram"],
          "correctAnswer": "Frame"
        },
        {
          "id": 44,
          "question": "Giao thức nào sau đây cung cấp dịch vụ email cho phép đồng bộ hóa trên nhiều thiết bị?",
          "options": ["POP3", "IMAP", "SMTP", "HTTP"],
          "correctAnswer": "IMAP"
        },
        {
          "id": 45,
          "question": "Địa chỉ MAC có bao nhiêu bit?",
          "options": ["32", "48", "64", "128"],
          "correctAnswer": "48"
        },
        {
          "id": 46,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Application?",
          "options": ["Router", "Switch", "Gateway", "Repeater"],
          "correctAnswer": "Gateway"
        },
        {
          "id": 47,
          "question": "Giao thức nào được sử dụng để phân giải địa chỉ MAC từ địa chỉ IP?",
          "options": ["ARP", "RARP", "ICMP", "DHCP"],
          "correctAnswer": "ARP"
        },
        {
          "id": 48,
          "question": "Mô hình mạng nào mà mỗi máy tính đều kết nối trực tiếp với tất cả các máy tính khác?",
          "options": ["Star", "Ring", "Mesh", "Bus"],
          "correctAnswer": "Mesh"
        },
        {
          "id": 49,
          "question": "Cổng mặc định của giao thức HTTP là bao nhiêu?",
          "options": ["80", "443", "25", "21"],
          "correctAnswer": "80"
        },
        {
          "id": 50,
          "question": "Địa chỉ IPv4 nào sau đây không phải là địa chỉ private?",
          "options": ["10.0.0.1", "172.16.0.1", "192.168.1.1", "200.100.50.25"],
          "correctAnswer": "200.100.50.25"
        },
        {
          "id": 51,
          "question": "Tên viết tắt của tiêu chuẩn mạng cục bộ không dây IEEE 802.11 là gì?",
          "options": ["Ethernet", "Token Ring", "Wi-Fi", "Bluetooth"],
          "correctAnswer": "Wi-Fi"
        },
        {
          "id": 52,
          "question": "Giao thức nào sau đây được sử dụng để truyền file qua mạng?",
          "options": ["HTTP", "SMTP", "FTP", "Telnet"],
          "correctAnswer": "FTP"
        },
        {
          "id": 53,
          "question": "Tầng nào trong mô hình TCP/IP tương đương với tầng Network trong mô hình OSI?",
          "options": ["Application", "Transport", "Internet", "Network Access"],
          "correctAnswer": "Internet"
        },
        {
          "id": 54,
          "question": "Giao thức nào sau đây được sử dụng để cấu hình tự động thông số mạng cho thiết bị, bao gồm cả địa chỉ IP?",
          "options": ["DNS", "DHCP", "ARP", "RARP"],
          "correctAnswer": "DHCP"
        },
        {
          "id": 55,
          "question": "Địa chỉ IP 192.168.1.1 với subnet mask 255.255.255.0 thuộc lớp địa chỉ IP nào?",
          "options": ["Lớp A", "Lớp B", "Lớp C", "Lớp D"],
          "correctAnswer": "Lớp C"
        },
        {
          "id": 56,
          "question": "Thiết bị nào hoạt động như một cầu nối giữa hai mạng có kiến trúc khác nhau?",
          "options": ["Repeater", "Bridge", "Switch", "Gateway"],
          "correctAnswer": "Gateway"
        },
        {
          "id": 57,
          "question": "Giao thức nào sau đây sử dụng phương thức \"store and forward\" để truyền dữ liệu?",
          "options": ["TCP", "UDP", "IP", "ICMP"],
          "correctAnswer": "TCP"
        },
        {
          "id": 58,
          "question": "Giao thức nào sau đây sử dụng cổng 110?",
          "options": ["SMTP", "POP3", "IMAP", "FTP"],
          "correctAnswer": "POP3"
        },
        {
          "id": 59,
          "question": "Đơn vị dữ liệu ở tầng Network được gọi là gì?",
          "options": ["Packet", "Segment", "Frame", "Datagram"],
          "correctAnswer": "Packet"
        },
        {
          "id": 60,
          "question": "Tầng nào trong mô hình TCP/IP chịu trách nhiệm truyền dữ liệu giữa các ứng dụng?",
          "options": ["Application", "Transport", "Internet", "Network Access"],
          "correctAnswer": "Application"
        },
        {
          "id": 61,
          "question": "Giao thức nào sau đây KHÔNG sử dụng cho việc truyền email?",
          "options": ["SMTP", "POP3", "IMAP", "HTTP"],
          "correctAnswer": "HTTP"
        },
        {
          "id": 62,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Transport?",
          "options": ["Router", "Switch", "Firewall", "Repeater"],
          "correctAnswer": "Firewall"
        },
        {
          "id": 63,
          "question": "Địa chỉ nào sau đây là địa chỉ broadcast của mạng 172.16.0.0/16?",
          "options": [
            "172.16.0.0",
            "172.16.0.255",
            "172.16.255.255",
            "172.16.255.0"
          ],
          "correctAnswer": "172.16.255.255"
        },
        {
          "id": 64,
          "question": "Giao thức nào sau đây được sử dụng để mã hóa dữ liệu trong mạng riêng ảo (VPN)?",
          "options": ["IPSec", "PPTP", "L2TP", "Tất cả đều đúng"],
          "correctAnswer": "Tất cả đều đúng"
        },
        {
          "id": 65,
          "question": "Thiết bị nào sau đây thường được sử dụng để chia sẻ kết nối Internet cho nhiều máy tính trong mạng LAN?",
          "options": ["Switch", "Hub", "Router", "Repeater"],
          "correctAnswer": "Router"
        },
        {
          "id": 66,
          "question": "Giao thức nào sau đây sử dụng phương thức \"best-effort delivery\"?",
          "options": ["TCP", "UDP", "HTTP", "FTP"],
          "correctAnswer": "UDP"
        },
        {
          "id": 67,
          "question": "Tầng nào trong mô hình OSI chịu trách nhiệm đóng gói dữ liệu thành các frame?",
          "options": ["Physical", "Data Link", "Network", "Transport"],
          "correctAnswer": "Data Link"
        },
        {
          "id": 68,
          "question": "Giao thức nào sau đây được sử dụng để đồng bộ hóa thời gian trên các thiết bị mạng?",
          "options": ["NTP", "SNTP", "DHCP", "ARP"],
          "correctAnswer": "NTP"
        },
        {
          "id": 69,
          "question": "Địa chỉ IPv6 có bao nhiêu bit?",
          "options": ["32", "48", "64", "128"],
          "correctAnswer": "128"
        },
        {
          "id": 70,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Physical và Data Link?",
          "options": ["Router", "Switch", "NIC", "Gateway"],
          "correctAnswer": "NIC"
        },
        {
          "id": 71,
          "question": "Giao thức nào cung cấp cơ chế đánh số thứ tự cho các gói tin?",
          "options": ["IP", "UDP", "TCP", "ICMP"],
          "correctAnswer": "TCP"
        },
        {
          "id": 72,
          "question": "Kỹ thuật nào sau đây cho phép nhiều VLAN hoạt động trên một cổng vật lý của switch?",
          "options": [
            "Trunking",
            "Spanning Tree",
            "Port Mirroring",
            "VLAN Tagging"
          ],
          "correctAnswer": "Trunking"
        },
        {
          "id": 73,
          "question": "Giao thức nào sau đây sử dụng cổng 143?",
          "options": ["SMTP", "POP3", "IMAP", "FTP"],
          "correctAnswer": "IMAP"
        },
        {
          "id": 74,
          "question": "Đơn vị dữ liệu ở tầng Transport được gọi là gì?",
          "options": ["Packet", "Segment", "Frame", "Datagram"],
          "correctAnswer": "Segment"
        },
        {
          "id": 75,
          "question": "Tầng nào trong mô hình TCP/IP tương đương với tầng Data Link và Physical trong mô hình OSI?",
          "options": ["Application", "Transport", "Internet", "Network Access"],
          "correctAnswer": "Network Access"
        },
        {
          "id": 76,
          "question": "Giao thức nào sau đây KHÔNG hoạt động ở tầng Application?",
          "options": ["HTTP", "FTP", "Telnet", "ARP"],
          "correctAnswer": "ARP"
        },
        {
          "id": 77,
          "question": "Thiết bị nào sau đây hoạt động chủ yếu ở tầng Network và Data Link?",
          "options": ["Router", "Switch", "Bridge", "Repeater"],
          "correctAnswer": "Router"
        },
        {
          "id": 78,
          "question": "Địa chỉ nào sau đây là địa chỉ loopback trong IPv6?",
          "options": ["::1", "::", "127.0.0.1", "0:0:0:0:0:0:0:1"],
          "correctAnswer": "::1"
        },
        {
          "id": 79,
          "question": "Giao thức nào sau đây được sử dụng để bảo mật kết nối Wi-Fi?",
          "options": ["WEP", "WPA", "WPA2", "Tất cả đều đúng"],
          "correctAnswer": "Tất cả đều đúng"
        },
        {
          "id": 80,
          "question": "Tầng nào trong mô hình OSI chịu trách nhiệm xác định đường đi tối ưu cho gói tin?",
          "options": ["Physical", "Data Link", "Network", "Transport"],
          "correctAnswer": "Network"
        },
        {
          "id": 81,
          "question": "Giao thức nào sau đây KHÔNG phải là giao thức định tuyến?",
          "options": ["RIP", "OSPF", "BGP", "ARP"],
          "correctAnswer": "ARP"
        },
        {
          "id": 82,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Presentation?",
          "options": ["Router", "Switch", "Gateway", "Không có thiết bị nào"],
          "correctAnswer": "Không có thiết bị nào"
        },
        {
          "id": 83,
          "question": "Địa chỉ nào sau đây là địa chỉ broadcast của mạng 10.0.0.0/8?",
          "options": [
            "10.0.0.0",
            "10.0.0.255",
            "10.255.255.255",
            "10.0.255.255"
          ],
          "correctAnswer": "10.255.255.255"
        },
        {
          "id": 84,
          "question": "Giao thức nào sau đây được sử dụng để quản lý mạng từ xa?",
          "options": ["SNMP", "Telnet", "SSH", "Tất cả đều đúng"],
          "correctAnswer": "Tất cả đều đúng"
        },
        {
          "id": 85,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Session?",
          "options": ["Router", "Switch", "Gateway", "Không có thiết bị nào"],
          "correctAnswer": "Không có thiết bị nào"
        },
        {
          "id": 86,
          "question": "Giao thức nào sau đây cung cấp dịch vụ \"connectionless\"?",
          "options": ["TCP", "UDP", "HTTP", "FTP"],
          "correctAnswer": "UDP"
        },
        {
          "id": 87,
          "question": "Kỹ thuật nào sau đây cho phép tạo ra các mạng LAN ảo trên cùng một hạ tầng mạng vật lý?",
          "options": ["Subnetting", "Routing", "NAT", "VLAN"],
          "correctAnswer": "VLAN"
        },
        {
          "id": 88,
          "question": "Giao thức nào sau đây được sử dụng để phát hiện lỗi trong quá trình truyền dữ liệu?",
          "options": [
            "TCP",
            "UDP",
            "Cả hai đều đúng",
            "Không có giao thức nào"
          ],
          "correctAnswer": "Cả hai đều đúng"
        },
        {
          "id": 89,
          "question": "Địa chỉ IP nào sau đây thuộc lớp C?",
          "options": ["126.0.0.1", "128.0.0.1", "191.0.0.1", "192.0.0.1"],
          "correctAnswer": "192.0.0.1"
        },
        {
          "id": 90,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Application, Transport, Network, Data Link và Physical?",
          "options": ["Router", "Switch", "Máy tính", "Repeater"],
          "correctAnswer": "Máy tính"
        },
        {
          "id": 91,
          "question": "Giao thức nào sau đây được sử dụng để thiết lập kết nối an toàn qua Internet?",
          "options": ["Telnet", "SSH", "FTP", "HTTP"],
          "correctAnswer": "SSH"
        },
        {
          "id": 92,
          "question": "Kỹ thuật \"Carrier Sense Multiple Access with Collision Detection\" (CSMA/CD) được sử dụng trong mạng nào?",
          "options": ["Ethernet", "Token Ring", "Wi-Fi", "Tất cả đều sai"],
          "correctAnswer": "Ethernet"
        },
        {
          "id": 93,
          "question": "Giao thức nào sau đây sử dụng cổng 23?",
          "options": ["HTTP", "FTP", "Telnet", "SSH"],
          "correctAnswer": "Telnet"
        },
        {
          "id": 94,
          "question": "Đơn vị dữ liệu ở tầng Application được gọi là gì?",
          "options": ["Packet", "Segment", "Frame", "Message"],
          "correctAnswer": "Message"
        },
        {
          "id": 95,
          "question": "Tầng nào trong mô hình TCP/IP tương đương với tầng Session, Presentation và Application trong mô hình OSI?",
          "options": ["Application", "Transport", "Internet", "Network Access"],
          "correctAnswer": "Application"
        },
        {
          "id": 96,
          "question": "Giao thức nào sau đây KHÔNG hỗ trợ cơ chế bắt tay (handshake)?",
          "options": ["TCP", "UDP", "HTTP", "FTP"],
          "correctAnswer": "UDP"
        },
        {
          "id": 97,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Data Link và Network?",
          "options": ["Router", "Switch", "Bridge", "Repeater"],
          "correctAnswer": "Router"
        },
        {
          "id": 98,
          "question": "Địa chỉ nào sau đây KHÔNG phải là địa chỉ MAC hợp lệ?",
          "options": [
            "00:11:22:33:44:55",
            "AA:BB:CC:DD:EE:FF",
            "01:23:45:67:89:AB",
            "00:11:22:33:44:55:66"
          ],
          "correctAnswer": "00:11:22:33:44:55:66"
        },
        {
          "id": 99,
          "question": "Giao thức nào sau đây được sử dụng để mã hóa dữ liệu trong HTTPS?",
          "options": ["SSL/TLS", "IPSec", "PPTP", "L2TP"],
          "correctAnswer": "SSL/TLS"
        },
        {
          "id": 100,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Network, Data Link và Physical?",
          "options": ["Router", "Switch", "Máy tính", "Repeater"],
          "correctAnswer": "Máy tính"
        }
      ]
    },
    {
      "id": 2,
      "title": "Science Quiz",
      "timeLimit": 300,
      "questions": [
        {
          "id": 1,
          "question": "What is the chemical symbol for water?",
          "options": ["H2O", "CO2", "NaCl", "O2"],
          "correctAnswer": "H2O",
          "reason": "zxcaxc"
        },
        {
          "id": 2,
          "question": "What is the speed of light?",
          "options": [
            "300,000 km/s",
            "150,000 km/s",
            "450,000 km/s",
            "600,000 km/s"
          ],
          "correctAnswer": "300,000 km/s"
        }
      ]
    },
    {
      "id": 3,
      "title": "Data Structures and Algorithms Quiz - Part 1",
      "timeLimit": 3600,
      "questions": [
        {
          "id": 1,
          "question": "Cấu trúc dữ liệu nào sau đây hoạt động theo nguyên tắc LIFO (Last In, First Out)?",
          "options": ["Queue", "Stack", "Linked List", "Tree"],
          "correctAnswer": "Stack",
          "reason": "Stack hoạt động theo nguyên tắc LIFO, phần tử được thêm vào cuối cùng sẽ là phần tử được lấy ra đầu tiên."
        },
        {
          "id": 2,
          "question": "Độ phức tạp thời gian của thuật toán tìm kiếm nhị phân (Binary Search) trên mảng đã sắp xếp là gì?",
          "options": ["O(n)", "O(log n)", "O(n log n)", "O(n^2)"],
          "correctAnswer": "O(log n)",
          "reason": "Tìm kiếm nhị phân chia đôi phạm vi tìm kiếm sau mỗi bước, do đó độ phức tạp là logarit."
        },
        {
          "id": 3,
          "question": "Khi nào thì nên sử dụng mảng (Array) thay vì danh sách liên kết (Linked List)?",
          "options": [
            "Khi cần chèn/xóa phần tử thường xuyên.",
            "Khi cần truy cập ngẫu nhiên các phần tử nhanh chóng.",
            "Khi không biết trước kích thước dữ liệu.",
            "Khi cần tiết kiệm bộ nhớ."
          ],
          "correctAnswer": "Khi cần truy cập ngẫu nhiên các phần tử nhanh chóng.",
          "reason": "Mảng cho phép truy cập phần tử thông qua chỉ số với độ phức tạp O(1), trong khi danh sách liên kết cần duyệt qua các phần tử trước đó."
        },
        {
          "id": 4,
          "question": "Trong cây nhị phân tìm kiếm (BST), thứ tự duyệt cây nào sẽ trả về các giá trị tăng dần?",
          "options": ["Inorder", "Preorder", "Postorder", "Level order"],
          "correctAnswer": "Inorder",
          "reason": "Duyệt inorder (trái - gốc - phải) trên BST sẽ thăm các nút theo thứ tự giá trị tăng dần."
        },
        {
          "id": 5,
          "question": "Cấu trúc dữ liệu nào dùng để triển khai cơ chế 'Undo/Redo' trong các trình soạn thảo văn bản?",
          "options": ["Queue", "Stack", "Linked List", "Tree"],
          "correctAnswer": "Stack",
          "reason": "Mỗi thao tác được push vào một stack 'Undo', khi undo thì pop khỏi stack 'Undo' và push vào stack 'Redo'. Khi redo thì pop khỏi stack 'Redo' và push vào stack 'Undo'."
        },
        {
          "id": 6,
          "question": "Cho đoạn code sau:\n```javascript\nfunction foo(n) {\n  if (n <= 1) return 1;\n  return foo(n - 1) + foo(n - 2);\n}\n```\nHàm `foo(n)` tính toán gì?",
          "options": [
            "Giai thừa của n.",
            "Dãy Fibonacci.",
            "Tổng các số từ 1 đến n.",
            "Lũy thừa của n."
          ],
          "correctAnswer": "Dãy Fibonacci.",
          "reason": "Hàm `foo(n)` tính số Fibonacci thứ n dựa trên đệ quy: F(n) = F(n-1) + F(n-2)."
        },
        {
          "id": 7,
          "question": "Kỹ thuật thiết kế giải thuật nào thường đi kèm với việc sử dụng đệ quy?",
          "options": [
            "Tham lam (Greedy)",
            "Chia để trị (Divide and Conquer)",
            "Quy hoạch động (Dynamic Programming)",
            "Quay lui (Backtracking)"
          ],
          "correctAnswer": [
            "Chia để trị (Divide and Conquer)",
            "Quay lui (Backtracking)"
          ],
          "reason": "Chia để trị thường chia bài toán thành các bài toán con nhỏ hơn và giải quyết chúng bằng đệ quy. Quay lui cũng thường sử dụng đệ quy để thử các phương án."
        },
        {
          "id": 8,
          "question": "Phát biểu nào sau đây là đúng về bảng băm (Hash Table)?",
          "options": [
            "Bảng băm luôn đảm bảo thứ tự các phần tử.",
            "Độ phức tạp tìm kiếm trung bình trong bảng băm là O(n).",
            "Bảng băm sử dụng hàm băm để ánh xạ khóa thành các chỉ số.",
            "Bảng băm không thể xảy ra đụng độ (collision)."
          ],
          "correctAnswer": "Bảng băm sử dụng hàm băm để ánh xạ khóa thành các chỉ số.",
          "reason": "Bảng băm sử dụng hàm băm để ánh xạ khóa (key) thành các chỉ số (index) trong bảng. Việc đụng độ (collision) có thể xảy ra và cần được xử lý."
        },
        {
          "id": 9,
          "question": "Cho mảng `arr = [5, 2, 8, 1, 9, 4]`. Cần bao nhiêu lần so sánh để sắp xếp mảng này bằng thuật toán Bubble Sort?",
          "options": ["5", "10", "15", "20"],
          "correctAnswer": "15",
          "reason": "Bubble Sort cần (n-1) + (n-2) + ... + 1 = n*(n-1)/2 lần so sánh. Với n = 6, ta có 6*5/2 = 15 lần so sánh."
        },
        {
          "id": 10,
          "question": "Thuật toán nào sau đây KHÔNG phải là thuật toán sắp xếp dựa trên so sánh?",
          "options": ["Quick Sort", "Merge Sort", "Heap Sort", "Counting Sort"],
          "correctAnswer": "Counting Sort",
          "reason": "Counting Sort không dựa trên việc so sánh các phần tử mà dựa trên tần suất xuất hiện của chúng. Các thuật toán còn lại đều dựa trên so sánh."
        },
        {
          "id": 11,
          "question": "Cấu trúc dữ liệu nào phù hợp để biểu diễn đồ thị?",
          "options": [
            "Ma trận kề (Adjacency Matrix)",
            "Danh sách kề (Adjacency List)",
            "Cả hai đều đúng",
            "Không có cái nào đúng"
          ],
          "correctAnswer": "Cả hai đều đúng",
          "reason": "Cả ma trận kề và danh sách kề đều có thể được sử dụng để biểu diễn đồ thị. Ma trận kề phù hợp với đồ thị dày, danh sách kề phù hợp với đồ thị thưa."
        },
        {
          "id": 12,
          "question": "Thuật toán Dijkstra dùng để làm gì?",
          "options": [
            "Tìm cây bao trùm nhỏ nhất",
            "Tìm đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh còn lại trong đồ thị có trọng số không âm",
            "Sắp xếp mảng",
            "Tìm kiếm phần tử trong mảng"
          ],
          "correctAnswer": "Tìm đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh còn lại trong đồ thị có trọng số không âm",
          "reason": "Thuật toán Dijkstra tìm đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh khác trong đồ thị có trọng số không âm."
        },
        {
          "id": 13,
          "question": "Độ phức tạp của thuật toán Dijkstra khi sử dụng hàng đợi ưu tiên (priority queue) là bao nhiêu?",
          "options": ["O(n)", "O(log n)", "O(E log V)", "O(n^2)"],
          "correctAnswer": "O(E log V)",
          "reason": "Với E là số cạnh, V là số đỉnh. Mỗi lần lấy phần tử ra khỏi hàng đợi ưu tiên mất O(log V) và có thể cập nhật trọng số của tối đa E cạnh."
        },
        {
          "id": 14,
          "question": "Trong thuật toán Kruskal, các cạnh được sắp xếp theo thứ tự nào?",
          "options": [
            "Tăng dần theo trọng số",
            "Giảm dần theo trọng số",
            "Ngẫu nhiên",
            "Không cần sắp xếp"
          ],
          "correctAnswer": "Tăng dần theo trọng số",
          "reason": "Thuật toán Kruskal sắp xếp các cạnh theo thứ tự tăng dần theo trọng số để chọn ra các cạnh có trọng số nhỏ nhất trước, tạo thành cây bao trùm nhỏ nhất."
        },
        {
          "id": 15,
          "question": "Cấu trúc dữ liệu nào được sử dụng để lưu trữ các node trong cây nhị phân?",
          "options": [
            "Array",
            "Linked List",
            "Cả hai đều đúng",
            "Không có cái nào đúng"
          ],
          "correctAnswer": "Linked List",
          "reason": "Mỗi node trong cây nhị phân thường được biểu diễn bằng một cấu trúc dữ liệu (ví dụ: struct trong C, class trong Java/C++) có các con trỏ trỏ đến node con trái và con phải, tạo thành mối liên kết như Linked List."
        },
        {
          "id": 16,
          "question": "Phát biểu nào sau đây là KHÔNG đúng về cây AVL?",
          "options": [
            "Là cây nhị phân tìm kiếm",
            "Là cây tự cân bằng",
            "Chiều cao của hai cây con của mỗi node chênh lệch không quá 1",
            "Là cây nhị phân đầy đủ"
          ],
          "correctAnswer": "Là cây nhị phân đầy đủ",
          "reason": "Cây AVL là cây nhị phân tìm kiếm tự cân bằng, đảm bảo chiều cao hai cây con của mỗi node chênh lệch không quá 1, nhưng không nhất thiết phải là cây nhị phân đầy đủ."
        },
        {
          "id": 17,
          "question": "Cho đoạn code sau:\n```javascript\nfunction bar(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length; j++) {\n      sum += arr[i] * arr[j];\n    }\n  }\n  return sum;\n}\n```\nĐộ phức tạp thời gian của hàm `bar(arr)` là gì?",
          "options": ["O(n)", "O(log n)", "O(n log n)", "O(n^2)"],
          "correctAnswer": "O(n^2)",
          "reason": "Hàm `bar(arr)` có hai vòng lặp lồng nhau, mỗi vòng lặp chạy n lần (n là độ dài mảng), do đó độ phức tạp là O(n^2)."
        },
        {
          "id": 18,
          "question": "Phương pháp giải quyết đụng độ (collision resolution) nào trong bảng băm có thể dẫn đến hiện tượng clustering (tập trung)?",
          "options": [
            "Separate Chaining",
            "Open Addressing with Linear Probing",
            "Open Addressing with Quadratic Probing",
            "Open Addressing with Double Hashing"
          ],
          "correctAnswer": "Open Addressing with Linear Probing",
          "reason": "Linear Probing (dò tuyến tính) có thể tạo ra các cụm khóa liên tiếp nhau trong bảng băm, làm giảm hiệu suất tìm kiếm."
        },
        {
          "id": 19,
          "question": "Cho mảng `arr = [1, 3, 5, 7, 9]`. Nếu sử dụng tìm kiếm nhị phân để tìm kiếm giá trị 6, mảng con nào sẽ được xét đến ở bước thứ hai?",
          "options": ["`[1, 3]`", "`[5, 7, 9]`", "`[5]`", "`[7, 9]`"],
          "correctAnswer": "`[7, 9]`",
          "reason": "Bước 1: Xét `[1, 3, 5, 7, 9]`, giữa là 5 < 6. Bước 2: Xét `[7, 9]`."
        },
        {
          "id": 20,
          "question": "Để tìm phần tử nhỏ nhất trong một min-heap, ta cần thực hiện thao tác nào?",
          "options": [
            "Duyệt toàn bộ heap",
            "Truy cập phần tử gốc (root)",
            "Tìm kiếm nhị phân",
            "Không thể tìm được"
          ],
          "correctAnswer": "Truy cập phần tử gốc (root)",
          "reason": "Trong min-heap, phần tử nhỏ nhất luôn nằm ở gốc (root)."
        },
        {
          "id": 21,
          "question": "Phát biểu nào sau đây là đúng về danh sách liên kết đôi (Doubly Linked List)?",
          "options": [
            "Mỗi node chỉ có một con trỏ trỏ đến node tiếp theo.",
            "Mỗi node có hai con trỏ, một trỏ đến node tiếp theo và một trỏ đến node trước đó.",
            "Không thể duyệt ngược danh sách.",
            "Truy cập ngẫu nhiên phần tử nhanh hơn mảng."
          ],
          "correctAnswer": "Mỗi node có hai con trỏ, một trỏ đến node tiếp theo và một trỏ đến node trước đó.",
          "reason": "Danh sách liên kết đôi cho phép duyệt danh sách theo cả hai chiều nhờ có con trỏ next và prev."
        },
        {
          "id": 22,
          "question": "Trong triển khai hàng đợi (Queue) bằng mảng, nếu front = rear thì hàng đợi đang ở trạng thái nào?",
          "options": ["Đầy", "Rỗng", "Có một phần tử", "Không xác định"],
          "correctAnswer": "Rỗng",
          "reason": "Trong cách triển khai này, front và rear bằng nhau khi hàng đợi rỗng hoặc chỉ có một phần tử. Tuy nhiên, khi chỉ có một phần tử, ta thường quy ước front = rear -1 (hoặc một giá trị đặc biệt khác) để phân biệt. Do đó, front = rear thường chỉ ra hàng đợi rỗng."
        },
        {
          "id": 23,
          "question": "Khi nào thì thuật toán Merge Sort có độ phức tạp thời gian là O(n^2)?",
          "options": [
            "Khi mảng đã được sắp xếp.",
            "Khi mảng đã được sắp xếp ngược.",
            "Khi tất cả các phần tử trong mảng bằng nhau.",
            "Không bao giờ."
          ],
          "correctAnswer": "Không bao giờ.",
          "reason": "Merge Sort luôn có độ phức tạp O(n log n) trong mọi trường hợp."
        },
        {
          "id": 24,
          "question": "Thuật toán Quick Sort có độ phức tạp thời gian trung bình là bao nhiêu?",
          "options": ["O(n)", "O(log n)", "O(n log n)", "O(n^2)"],
          "correctAnswer": "O(n log n)",
          "reason": "Quick Sort có độ phức tạp trung bình là O(n log n), nhưng trong trường hợp xấu nhất có thể lên đến O(n^2)."
        },
        {
          "id": 25,
          "question": "Chọn phát biểu **sai**: Một cây nhị phân tìm kiếm:",
          "options": [
            "Cho phép tìm kiếm, chèn, xoá với độ phức tạp trung bình O(log n).",
            "Là cây nhị phân.",
            "Node con trái luôn nhỏ hơn node cha.",
            "Node con phải luôn lớn hơn hoặc bằng node cha"
          ],
          "correctAnswer": "Node con phải luôn lớn hơn hoặc bằng node cha",
          "reason": "Trong cây nhị phân tìm kiếm, tất cả các node trong cây con phải đều phải lớn hơn node cha, node con phải có thể bằng node cha"
        },
        {
          "id": 26,
          "question": "Cho đồ thị có hướng G = (V, E). Phát biểu nào sau đây là đúng?",
          "options": [
            "Tổng bậc vào của tất cả các đỉnh bằng tổng bậc ra của tất cả các đỉnh.",
            "Số cạnh bằng số đỉnh.",
            "Đồ thị luôn liên thông.",
            "Không thể có chu trình."
          ],
          "correctAnswer": "Tổng bậc vào của tất cả các đỉnh bằng tổng bậc ra của tất cả các đỉnh.",
          "reason": "Trong đồ thị có hướng, mỗi cạnh đều có một đỉnh đầu và một đỉnh cuối. Do đó, tổng số bậc vào của tất cả các đỉnh sẽ bằng tổng số bậc ra và bằng số cạnh."
        },
        {
          "id": 27,
          "question": "Kỹ thuật thiết kế giải thuật nào dựa trên việc lưu trữ kết quả của các bài toán con để sử dụng lại?",
          "options": [
            "Tham lam (Greedy)",
            "Chia để trị (Divide and Conquer)",
            "Quy hoạch động (Dynamic Programming)",
            "Quay lui (Backtracking)"
          ],
          "correctAnswer": "Quy hoạch động (Dynamic Programming)",
          "reason": "Quy hoạch động lưu trữ kết quả của các bài toán con trong bảng (memoization hoặc tabulation) để tránh phải tính toán lại, giúp cải thiện hiệu suất."
        },
        {
          "id": 28,
          "question": "Cho đoạn code sau:\n```javascript\nfunction mystery(n) {\n  if (n == 0) return 0;\n  return n + mystery(n - 1);\n}\n```\nĐộ phức tạp không gian của hàm `mystery(n)` là gì?",
          "options": ["O(1)", "O(n)", "O(log n)", "O(n^2)"],
          "correctAnswer": "O(n)",
          "reason": "Hàm `mystery(n)` sử dụng đệ quy, mỗi lần gọi đệ quy sẽ tốn thêm không gian bộ nhớ trên call stack. Do đó, độ phức tạp không gian là O(n)."
        },
        {
          "id": 29,
          "question": "Trong thuật toán Bellman-Ford, sau khi khởi tạo, mỗi đỉnh (ngoại trừ đỉnh nguồn) được gán nhãn khoảng cách là bao nhiêu?",
          "options": ["0", "1", "Vô cùng (Infinity)", "Không xác định"],
          "correctAnswer": "Vô cùng (Infinity)",
          "reason": "Ban đầu, tất cả các đỉnh (ngoại trừ đỉnh nguồn được gán nhãn 0) đều được gán nhãn khoảng cách là vô cùng, sau đó sẽ được cập nhật dần trong quá trình chạy thuật toán."
        },
        {
          "id": 30,
          "question": "Bài toán cái túi (Knapsack Problem) có thể được giải quyết hiệu quả bằng phương pháp nào?",
          "options": [
            "Tham lam (Greedy)",
            "Chia để trị (Divide and Conquer)",
            "Quy hoạch động (Dynamic Programming)",
            "Quay lui (Backtracking)"
          ],
          "correctAnswer": [
            "Quy hoạch động (Dynamic Programming)",
            "Quay lui (Backtracking)"
          ],
          "reason": "Bài toán cái túi 0/1 có thể giải bằng quy hoạch động hoặc quay lui (branch and bound để tối ưu). Bài toán cái túi dạng phân số có thể giải bằng phương pháp tham lam."
        },
        {
          "id": 31,
          "question": "Cấu trúc dữ liệu nào sau đây KHÔNG phải là cấu trúc dữ liệu tuyến tính?",
          "options": ["Array", "Linked List", "Stack", "Tree"],
          "correctAnswer": "Tree",
          "reason": "Tree (cây) là cấu trúc dữ liệu phi tuyến, trong khi Array, Linked List, Stack, Queue là các cấu trúc dữ liệu tuyến tính."
        },
        {
          "id": 32,
          "question": "Cho cây nhị phân dưới đây:\n\n```\n     1\n    / \\\n   2   3\n  / \\  /\n 4  5 6\n```\nThứ tự duyệt cây theo Preorder là gì?",
          "options": [
            "4 2 5 1 6 3",
            "1 2 4 5 3 6",
            "4 5 2 6 3 1",
            "1 3 6 2 5 4"
          ],
          "correctAnswer": "1 2 4 5 3 6",
          "reason": "Thứ tự duyệt Preorder là: Gốc - Trái - Phải. Do đó, kết quả là 1 2 4 5 3 6."
        },
        {
          "id": 33,
          "question": "Thuật toán nào sau đây được sử dụng để tìm đường đi trong đồ thị?",
          "options": [
            "Breadth-First Search (BFS)",
            "Depth-First Search (DFS)",
            "Cả hai đều đúng",
            "Không có cái nào đúng"
          ],
          "correctAnswer": "Cả hai đều đúng",
          "reason": "Cả BFS và DFS đều là các thuật toán duyệt đồ thị và có thể được sử dụng để tìm đường đi giữa các đỉnh."
        },
        {
          "id": 34,
          "question": "Cho mảng `arr = [1, 2, 3, 4, 5]`. Nếu dùng stack để đảo ngược mảng này, cần thực hiện bao nhiêu thao tác push?",
          "options": ["1", "3", "5", "10"],
          "correctAnswer": "5",
          "reason": "Cần push lần lượt 5 phần tử của mảng vào stack để đảo ngược mảng."
        },
        {
          "id": 35,
          "question": "Hash table giải quyết vấn đề đụng độ collision bằng cách nào?",
          "options": [
            "Separate Chaining",
            "Open Addressing",
            "Cả hai đều đúng",
            "Không có cái nào đúng"
          ],
          "correctAnswer": "Cả hai đều đúng",
          "reason": "Separate Chaining (dùng danh sách liên kết tại mỗi vị trí) và Open Addressing (thử các vị trí khác) là hai phương pháp chính để giải quyết đụng độ trong bảng băm."
        },
        {
          "id": 36,
          "question": "Khi nào thì Counting Sort hiệu quả hơn Merge Sort?",
          "options": [
            "Khi các phần tử có giá trị lớn.",
            "Khi các phần tử có giá trị phân bố trong một phạm vi hẹp.",
            "Khi mảng có kích thước lớn.",
            "Không bao giờ."
          ],
          "correctAnswer": "Khi các phần tử có giá trị phân bố trong một phạm vi hẹp.",
          "reason": "Counting Sort hiệu quả khi các phần tử có giá trị nguyên và phân bố trong một phạm vi hẹp, vì độ phức tạp của nó là O(n+k) với k là phạm vi giá trị."
        },
        {
          "id": 37,
          "question": "Thuật toán Prim dùng để làm gì?",
          "options": [
            "Tìm đường đi ngắn nhất",
            "Tìm cây bao trùm nhỏ nhất",
            "Sắp xếp mảng",
            "Tìm kiếm phần tử trong mảng"
          ],
          "correctAnswer": "Tìm cây bao trùm nhỏ nhất",
          "reason": "Thuật toán Prim được sử dụng để tìm cây bao trùm nhỏ nhất (Minimum Spanning Tree) trong đồ thị vô hướng có trọng số."
        },
        {
          "id": 38,
          "question": "Cho đồ thị có trọng số, làm thế nào để tìm đường đi ngắn nhất giữa hai đỉnh bất kỳ?",
          "options": [
            "Dijkstra",
            "Bellman-Ford",
            "Floyd-Warshall",
            "Tất cả đều đúng"
          ],
          "correctAnswer": "Tất cả đều đúng",
          "reason": "Dijkstra (đồ thị trọng số không âm), Bellman-Ford (đồ thị có thể có trọng số âm, không có chu trình âm), và Floyd-Warshall (mọi cặp đỉnh) đều có thể được sử dụng để tìm đường đi ngắn nhất."
        },
        {
          "id": 39,
          "question": "Cho đoạn code sau:\n```javascript\nfunction mystery(arr) {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 == 0) {\n      count++;\n    }\n  }\n  return count;\n}\n```\nHàm `mystery(arr)` thực hiện công việc gì?",
          "options": [
            "Đếm số phần tử chẵn trong mảng.",
            "Đếm số phần tử lẻ trong mảng.",
            "Tính tổng các phần tử chẵn trong mảng.",
            "Tính tổng các phần tử lẻ trong mảng."
          ],
          "correctAnswer": "Đếm số phần tử chẵn trong mảng.",
          "reason": "Hàm `mystery(arr)` duyệt qua mảng và tăng biến `count` mỗi khi gặp một phần tử chẵn."
        },
        {
          "id": 40,
          "question": "Giả sử bạn cần lưu trữ thông tin của 1 triệu học sinh, bao gồm tên, tuổi và điểm số. Cấu trúc dữ liệu nào sau đây là phù hợp nhất?",
          "options": ["Mảng", "Danh sách liên kết", "Stack", "Hash Table"],
          "correctAnswer": "Hash Table",
          "reason": "Hash Table cho phép tìm kiếm, chèn, xóa thông tin học sinh dựa trên tên (key) với độ phức tạp trung bình O(1), rất hiệu quả với số lượng lớn dữ liệu."
        },
        {
          "id": 41,
          "question": "Trong cây nhị phân, bậc của một node được định nghĩa là:",
          "options": [
            "Số lượng node con của node đó",
            "Số lượng cạnh nối với node đó",
            "Chiều cao của cây con có gốc là node đó",
            "Độ sâu của node đó trong cây"
          ],
          "correctAnswer": "Số lượng node con của node đó",
          "reason": "Bậc của một node trong cây nhị phân chính là số lượng node con (trái và phải) của node đó."
        },
        {
          "id": 42,
          "question": "Cho cây nhị phân dưới đây:\n\n```\n     1\n    / \\\n   2   3\n  / \\  /\n 4  5 6\n```\nThứ tự duyệt cây theo Inorder là gì?",
          "options": [
            "4 2 5 1 3 6",
            "1 2 4 5 3 6",
            "4 5 2 6 3 1",
            "1 3 6 2 5 4"
          ],
          "correctAnswer": "4 2 5 1 3 6",
          "reason": "Thứ tự duyệt Inorder là: Trái - Gốc - Phải. Do đó, kết quả là 4 2 5 1 3 6."
        },
        {
          "id": 43,
          "question": "Breadth-First Search (BFS) sử dụng cấu trúc dữ liệu nào?",
          "options": ["Stack", "Queue", "Linked List", "Tree"],
          "correctAnswer": "Queue",
          "reason": "BFS duyệt đồ thị theo chiều rộng, sử dụng hàng đợi (Queue) để lưu trữ các đỉnh cần duyệt."
        },
        {
          "id": 44,
          "question": "Depth-First Search (DFS) sử dụng cấu trúc dữ liệu nào?",
          "options": ["Stack", "Queue", "Linked List", "Tree"],
          "correctAnswer": "Stack",
          "reason": "DFS duyệt đồ thị theo chiều sâu, sử dụng ngăn xếp (Stack) để lưu trữ các đỉnh cần duyệt."
        },
        {
          "id": 45,
          "question": "Khi nào thì đồ thị được gọi là đồ thị liên thông (connected graph)?",
          "options": [
            "Khi có ít nhất một đường đi giữa hai đỉnh bất kỳ.",
            "Khi tất cả các đỉnh đều có bậc chẵn.",
            "Khi không có chu trình.",
            "Khi có đúng một đường đi giữa hai đỉnh bất kỳ."
          ],
          "correctAnswer": "Khi có ít nhất một đường đi giữa hai đỉnh bất kỳ.",
          "reason": "Đồ thị liên thông là đồ thị mà luôn tồn tại đường đi giữa mọi cặp đỉnh."
        },
        {
          "id": 46,
          "question": "Cho mảng `arr = [5, 2, 9, 1, 5, 6]`. Sau lần lặp đầu tiên của vòng lặp ngoài trong thuật toán Selection Sort, mảng sẽ trở thành như thế nào?",
          "options": [
            "`[1, 2, 9, 5, 5, 6]`",
            "`[2, 5, 9, 1, 5, 6]`",
            "`[5, 2, 9, 1, 5, 6]`",
            "`[1, 5, 2, 9, 5, 6]`"
          ],
          "correctAnswer": "`[1, 2, 9, 5, 5, 6]`",
          "reason": "Selection Sort tìm phần tử nhỏ nhất (1) và đổi chỗ với phần tử đầu tiên (5)."
        },
        {
          "id": 47,
          "question": "Kỹ thuật thiết kế giải thuật nào thường được sử dụng để giải các bài toán tối ưu tổ hợp?",
          "options": [
            "Chia để trị (Divide and Conquer)",
            "Tham lam (Greedy)",
            "Quy hoạch động (Dynamic Programming)",
            "Cả B và C đều đúng"
          ],
          "correctAnswer": "Cả B và C đều đúng",
          "reason": "Tham lam và quy hoạch động đều thường được sử dụng để giải các bài toán tối ưu tổ hợp. Tham lam tìm kiếm giải pháp tối ưu cục bộ, trong khi quy hoạch động tìm kiếm giải pháp tối ưu toàn cục bằng cách sử dụng bảng lưu trữ."
        },
        {
          "id": 48,
          "question": "Cho đoạn code sau:\n```javascript\nfunction whatDoesItDo(arr) {\n  const n = arr.length;\n  const stack = [];\n  for (let i = 0; i < n; i++) {\n    while (stack.length > 0 && arr[stack[stack.length - 1]] > arr[i]) {\n      stack.pop();\n    }\n    stack.push(i);\n  }\n  return stack;\n}\n```\nHàm `whatDoesItDo(arr)` trả về kết quả là một stack chứa các chỉ số. Chỉ số `i` có trong stack kết quả khi nào?",
          "options": [
            "`arr[i]` là phần tử lớn nhất trong mảng.",
            "`arr[i]` là phần tử nhỏ nhất trong mảng.",
            "Không có phần tử nào đứng sau `arr[i]` trong mảng mà nhỏ hơn `arr[i]`.",
            "Không có phần tử nào đứng trước `arr[i]` trong mảng mà lớn hơn `arr[i]`."
          ],
          "correctAnswer": "Không có phần tử nào đứng sau `arr[i]` trong mảng mà nhỏ hơn `arr[i]`.",
          "reason": "Hàm `whatDoesItDo(arr)` trả về một stack chứa các chỉ số của các phần tử trong mảng sao cho không có phần tử nào đứng sau nó trong mảng mà nhỏ hơn nó (xét từ trái sang phải). Đây là bài toán tìm mảng giảm không liên tục dài nhất."
        },
        {
          "id": 49,
          "question": "Giả sử bạn cần lưu trữ lịch sử duyệt web của người dùng. Cấu trúc dữ liệu nào sau đây là phù hợp nhất?",
          "options": ["Array", "Linked List", "Stack", "Queue"],
          "correctAnswer": "Stack",
          "reason": "Stack (ngăn xếp) phù hợp để lưu trữ lịch sử duyệt web, vì trang web mới nhất được truy cập sẽ nằm trên đỉnh stack (truy cập gần nhất - LIFO)."
        },
        {
          "id": 50,
          "question": "Trong triển khai Queue bằng danh sách liên kết, phần tử nào sẽ được lấy ra đầu tiên?",
          "options": [
            "Phần tử đầu tiên được thêm vào (head)",
            "Phần tử cuối cùng được thêm vào (tail)",
            "Phần tử ở giữa",
            "Không xác định"
          ],
          "correctAnswer": "Phần tử đầu tiên được thêm vào (head)",
          "reason": "Queue hoạt động theo nguyên tắc FIFO (First In, First Out), do đó phần tử đầu tiên được thêm vào (head) sẽ được lấy ra đầu tiên."
        },
        {
          "id": 51,
          "question": "Cho cây nhị phân tìm kiếm dưới đây:\n\n```\n     8\n    / \\\n   3   10\n  / \\    \\\n 1   6    14\n    / \\   /\n   4   7 13\n```\nNếu xóa node có giá trị 8 (gốc), node nào sẽ trở thành gốc mới?",
          "options": ["10", "3", "6", "7"],
          "correctAnswer": "10",
          "reason": "Khi xóa node gốc trong BST, ta thay thế nó bằng node ngoài cùng bên phải của cây con trái hoặc node ngoài cùng bên trái của cây con phải. Ở đây, ta thay bằng node ngoài cùng bên trái của cây con phải (10)."
        },
        {
          "id": 52,
          "question": "Trong đồ thị, chu trình (cycle) là gì?",
          "options": [
            "Một đường đi bắt đầu và kết thúc tại cùng một đỉnh.",
            "Một đường đi không có đỉnh nào lặp lại.",
            "Một đồ thị con liên thông.",
            "Một cây bao trùm."
          ],
          "correctAnswer": "Một đường đi bắt đầu và kết thúc tại cùng một đỉnh.",
          "reason": "Chu trình (cycle) trong đồ thị là một đường đi có đỉnh đầu và đỉnh cuối trùng nhau."
        },
        {
          "id": 53,
          "question": "Thuật toán nào sau đây KHÔNG sử dụng kỹ thuật Chia để trị (Divide and Conquer)?",
          "options": [
            "Merge Sort",
            "Quick Sort",
            "Binary Search",
            "Insertion Sort"
          ],
          "correctAnswer": "Insertion Sort",
          "reason": "Insertion Sort không chia bài toán thành các bài toán con nhỏ hơn để giải quyết, mà chèn từng phần tử vào vị trí thích hợp trong dãy con đã sắp xếp."
        },
        {
          "id": 54,
          "question": "Cho mảng `arr = [3, 7, 8, 5, 2, 1, 9, 5, 4]`. Sau lần chạy đầu tiên của thuật toán Merge, hai mảng con được tạo ra là gì?",
          "options": [
            "`[3, 7, 8, 5]` và `[2, 1, 9, 5, 4]`",
            "`[3, 7, 8]` và `[5, 2, 1, 9, 5, 4]`",
            "`[3, 7, 8, 5, 2]` và `[1, 9, 5, 4]`",
            "`[3]` và `[7, 8, 5, 2, 1, 9, 5, 4]`"
          ],
          "correctAnswer": " `[3, 7, 8, 5]` và `[2, 1, 9, 5, 4]`",
          "reason": "Thuật toán Merge trong Merge Sort chia đôi mảng ban đầu thành hai mảng con, do đó kết quả là `[3, 7, 8, 5]` và `[2, 1, 9, 5, 4]`."
        },
        {
          "id": 55,
          "question": "Giả sử bạn muốn triển khai một tính năng gợi ý từ (auto-suggest) khi người dùng nhập liệu. Cấu trúc dữ liệu nào sau đây là phù hợp nhất?",
          "options": ["Array", "Linked List", "Trie", "Hash Table"],
          "correctAnswer": "Trie",
          "reason": "Trie (cây tiền tố) là cấu trúc dữ liệu hiệu quả cho việc lưu trữ và tìm kiếm các chuỗi, đặc biệt là khi cần tìm kiếm các chuỗi có cùng tiền tố, rất phù hợp cho tính năng gợi ý từ."
        },
        {
          "id": 56,
          "question": "Cho đoạn code sau:\n```javascript\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n\n  insertAtEnd(data) {\n    const newNode = new Node(data);\n    if (!this.head) {\n      this.head = newNode;\n      return;\n    }\n    let current = this.head;\n    while (current.next) {\n      current = current.next;\n    }\n    current.next = newNode;\n  }\n}\n```\nĐộ phức tạp thời gian của phương thức `insertAtEnd` trong class `LinkedList` là gì?",
          "options": ["O(1)", "O(log n)", "O(n)", "O(n^2)"],
          "correctAnswer": "O(n)",
          "reason": "Trong trường hợp xấu nhất, phương thức `insertAtEnd` phải duyệt qua toàn bộ danh sách để tìm đến phần tử cuối cùng, do đó độ phức tạp là O(n)."
        },
        {
          "id": 57,
          "question": "Phát biểu nào sau đây là đúng về thuật toán Tham lam (Greedy)?",
          "options": [
            "Luôn tìm ra lời giải tối ưu toàn cục.",
            "Chọn phương án tốt nhất ở mỗi bước với hy vọng đạt được kết quả tối ưu toàn cục.",
            "Cân nhắc tất cả các trường hợp có thể xảy ra.",
            "Sử dụng đệ quy để giải quyết bài toán."
          ],
          "correctAnswer": "Chọn phương án tốt nhất ở mỗi bước với hy vọng đạt được kết quả tối ưu toàn cục.",
          "reason": "Thuật toán Tham lam đưa ra quyết định dựa trên thông tin hiện có mà không xem xét đến các bước sau này, với hy vọng đạt được kết quả tốt nhất."
        },
        {
          "id": 58,
          "question": "Trong cây đỏ-đen (Red-Black Tree), mỗi node có thể có màu gì?",
          "options": ["Đỏ", "Đen", "Đỏ hoặc Đen", "Xanh"],
          "correctAnswer": "Đỏ hoặc Đen",
          "reason": "Cây đỏ-đen sử dụng hai màu đỏ và đen cho các node để đảm bảo tính cân bằng."
        },
        {
          "id": 59,
          "question": "BFS và DFS, thuật toán nào tìm thấy đường đi ngắn nhất trong đồ thị không trọng số?",
          "options": ["BFS", "DFS", "Cả hai", "Không có cái nào"],
          "correctAnswer": "BFS",
          "reason": "BFS đảm bảo tìm thấy đường đi ngắn nhất (theo số cạnh) trong đồ thị không trọng số."
        },
        {
          "id": 60,
          "question": "Cho đồ thị G = (V, E) với V là số đỉnh và E là số cạnh. Khi nào thì biểu diễn đồ thị bằng danh sách kề (Adjacency List) hiệu quả hơn ma trận kề (Adjacency Matrix)?",
          "options": [
            "Khi đồ thị đầy đủ (complete graph).",
            "Khi đồ thị có hướng.",
            "Khi E lớn hơn rất nhiều so với V^2",
            "Khi E nhỏ hơn rất nhiều so với V^2"
          ],
          "correctAnswer": "Khi E nhỏ hơn rất nhiều so với V^2",
          "reason": "Danh sách kề tiết kiệm bộ nhớ hơn khi đồ thị thưa (ít cạnh, E nhỏ hơn rất nhiều so với V^2)."
        },
        {
          "id": 61,
          "question": "Cho cây AVL dưới đây. Thao tác nào sau đây sẽ làm mất cân bằng cây AVL?\n\n```\n      5\n    /   \\\n   3     8\n  / \\   / \\\n 2   4 7   9\n```",
          "options": ["Chèn 1", "Chèn 6", "Xoá 9", "Xoá 4"],
          "correctAnswer": "Chèn 1",
          "reason": "Chèn 1 vào cây AVL trên sẽ làm mất cân bằng tại node 3 (hệ số cân bằng là -2). Các thao tác còn lại không làm mất cân bằng cây."
        },
        {
          "id": 62,
          "question": "Khẳng định nào sau đây là đúng về thuật toán sắp xếp trộn (Merge Sort)?",
          "options": [
            "Là thuật toán sắp xếp tại chỗ (in-place).",
            "Độ phức tạp thời gian trong trường hợp xấu nhất là O(n^2).",
            "Là thuật toán sắp xếp ổn định (stable).",
            "Chỉ áp dụng được cho mảng có kích thước nhỏ."
          ],
          "correctAnswer": "Là thuật toán sắp xếp ổn định (stable).",
          "reason": "Merge Sort là thuật toán sắp xếp ổn định (giữ nguyên thứ tự ban đầu của các phần tử bằng nhau), có độ phức tạp O(n log n) trong mọi trường hợp, và không phải là in-place (cần thêm không gian nhớ)."
        },
        {
          "id": 63,
          "question": "Khi nào thì nên sử dụng thuật toán sắp xếp chèn (Insertion Sort)?",
          "options": [
            "Khi mảng có kích thước lớn.",
            "Khi mảng gần như đã được sắp xếp.",
            "Khi cần sắp xếp với độ phức tạp O(n log n).",
            "Khi mảng có các phần tử trùng lặp."
          ],
          "correctAnswer": "Khi mảng gần như đã được sắp xếp.",
          "reason": "Insertion Sort hiệu quả khi mảng gần như đã được sắp xếp, với độ phức tạp gần O(n) trong trường hợp đó."
        },
        {
          "id": 64,
          "question": "Cho đồ thị vô hướng G = (V, E). Điều kiện cần để G có chu trình Euler là gì?",
          "options": [
            "G phải liên thông.",
            "Mọi đỉnh của G đều phải có bậc chẵn.",
            "Cả A và B đều đúng.",
            "Không có điều kiện nào."
          ],
          "correctAnswer": "Cả A và B đều đúng.",
          "reason": "Một đồ thị vô hướng có chu trình Euler khi và chỉ khi nó liên thông và mọi đỉnh đều có bậc chẵn."
        },
        {
          "id": 65,
          "question": "Giả sử bạn đang viết một chương trình từ điển. Cấu trúc dữ liệu nào sau đây là phù hợp nhất để lưu trữ các từ và định nghĩa của chúng?",
          "options": ["Array", "Linked List", "Stack", "Hash Table"],
          "correctAnswer": "Hash Table",
          "reason": "Hash Table (bảng băm) cho phép tra cứu nhanh định nghĩa của một từ (key) với độ phức tạp trung bình O(1), rất phù hợp cho ứng dụng từ điển."
        },
        {
          "id": 66,
          "question": "Cho đoạn code sau:\n```javascript\nfunction mystery(arr) {\n  if (arr.length <= 1) {\n    return arr;\n  }\n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n  return merge(mystery(left), mystery(right));\n}\n\nfunction merge(left, right) {\n  // (Hàm merge hai mảng đã sắp xếp)\n}\n```\nHàm `mystery(arr)` thực hiện thuật toán sắp xếp nào?",
          "options": [
            "Quick Sort",
            "Merge Sort",
            "Insertion Sort",
            "Bubble Sort"
          ],
          "correctAnswer": "Merge Sort",
          "reason": "`mystery(arr)` sử dụng kỹ thuật chia để trị, chia đôi mảng thành hai phần, đệ quy sắp xếp từng phần và trộn lại. Đây là đặc trưng của thuật toán Merge Sort."
        },
        {
          "id": 67,
          "question": "Trong thuật toán Floyd-Warshall, ma trận khoảng cách ban đầu `D0[i][j]` (với `i != j`) được khởi tạo bằng gì?",
          "options": [
            "0",
            "1",
            "Trọng số của cạnh (i, j) nếu có, ngược lại là vô cùng (Infinity).",
            "Vô cùng (Infinity)."
          ],
          "correctAnswer": "Trọng số của cạnh (i, j) nếu có, ngược lại là vô cùng (Infinity).",
          "reason": "Trong Floyd-Warshall, `D0[i][j]` được khởi tạo bằng trọng số của cạnh (i, j) nếu có cạnh nối trực tiếp giữa i và j, ngược lại là vô cùng."
        },
        {
          "id": 68,
          "question": "Cây tìm kiếm nhị phân tự cân bằng (Self-balancing BST) đảm bảo điều gì?",
          "options": [
            "Chiều cao của cây luôn là log n (với n là số node).",
            "Mỗi node có đúng hai node con.",
            "Cây luôn đầy đủ.",
            "Thứ tự duyệt Inorder luôn trả về các node theo thứ tự tăng dần."
          ],
          "correctAnswer": "Chiều cao của cây luôn là log n (với n là số node).",
          "reason": "Cây tìm kiếm nhị phân tự cân bằng (như AVL, Red-Black Tree) đảm bảo chiều cao của cây luôn ở mức log n, giúp các thao tác tìm kiếm, chèn, xóa hiệu quả."
        },
        {
          "id": 69,
          "question": "Trong đồ thị có hướng, nếu tồn tại một chu trình (cycle) thì sao?",
          "options": [
            "Đồ thị không liên thông.",
            "Thuật toán Bellman-Ford không thể áp dụng.",
            "Thứ tự tô pô (topological sort) không tồn tại.",
            "Đồ thị là một cây."
          ],
          "correctAnswer": "Thứ tự tô pô (topological sort) không tồn tại.",
          "reason": "Thứ tự tô pô chỉ tồn tại trên đồ thị có hướng không có chu trình (DAG). Nếu đồ thị có chu trình, sẽ không thể sắp xếp các đỉnh theo thứ tự tô pô."
        },
        {
          "id": 70,
          "question": "Khi nào thì nên sử dụng quay lui (Backtracking)?",
          "options": [
            "Khi bài toán có thể được chia thành các bài toán con nhỏ hơn và lời giải của bài toán lớn có thể xây dựng từ lời giải của các bài toán con.",
            "Khi cần tìm một lời giải thỏa mãn một số ràng buộc, và ta có thể thử lần lượt các phương án.",
            "Khi bài toán yêu cầu tìm đường đi ngắn nhất trong đồ thị.",
            "Khi bài toán yêu cầu tìm cây bao trùm nhỏ nhất trong đồ thị."
          ],
          "correctAnswer": "Khi cần tìm một lời giải thỏa mãn một số ràng buộc, và ta có thể thử lần lượt các phương án.",
          "reason": "Quay lui là kỹ thuật thử từng phương án, nếu một phương án không thỏa mãn, ta quay lại bước trước đó và thử phương án khác."
        },
        {
          "id": 71,
          "question": "Bài toán Tháp Hà Nội (Tower of Hanoi) thường được giải quyết bằng phương pháp nào?",
          "options": [
            "Chia để trị (Divide and Conquer)",
            "Tham lam (Greedy)",
            "Quy hoạch động (Dynamic Programming)",
            "Quay lui (Backtracking)"
          ],
          "correctAnswer": [
            "Chia để trị (Divide and Conquer)",
            "Quay lui (Backtracking)"
          ],
          "reason": "Bài toán Tháp Hà Nội thường được giải bằng đệ quy, và bản chất của đệ quy trong trường hợp này cũng chính là chia để trị và quay lui"
        },
        {
          "id": 72,
          "question": "Trong thuật toán sắp xếp nổi bọt (Bubble Sort), phần tử nhỏ nhất sẽ \"nổi\" lên vị trí đầu tiên sau bao nhiêu lần lặp của vòng lặp ngoài?",
          "options": ["1", "n-1", "n", "Không xác định"],
          "correctAnswer": "1",
          "reason": "Sau lần lặp đầu tiên của vòng lặp ngoài trong Bubble Sort, phần tử nhỏ nhất sẽ được đưa về vị trí đầu tiên."
        },
        {
          "id": 73,
          "question": "Cho mảng `arr = [4, 2, 2, 8, 3, 3, 1]`. Khi sắp xếp mảng này bằng Quick Sort và chọn phần tử chốt (pivot) là phần tử đầu tiên, mảng sẽ được chia thành hai mảng con như thế nào sau bước phân hoạch (partition) đầu tiên?",
          "options": [
            "`[2, 2, 3, 3, 1]` và `[8]`",
            "`[2, 2, 1, 3, 3]` và `[8]`",
            "`[1, 2, 2, 3, 3]` và `[8]`",
            "`[3, 2, 2, 1, 3]` và `[8]`"
          ],
          "correctAnswer": "[2, 2, 1, 3, 3] và [8]",
          "reason": "Sau bước phân hoạch đầu tiên, các phần tử nhỏ hơn 4 (pivot) sẽ được chuyển sang bên trái và các phần tử lớn hơn hoặc bằng 4 sẽ được chuyển sang bên phải. Do đó, kết quả là `[2, 2, 1, 3, 3]` và `[8]` (phần tử 4 nằm giữa)."
        },
        {
          "id": 74,
          "question": "Cho đoạn code sau:\n```javascript\nfunction findSum(arr, target) {\n  const seen = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    const complement = target - arr[i];\n    if (seen.has(complement)) {\n      return true;\n    }\n    seen.add(arr[i]);\n  }\n  return false;\n}\n```\nHàm `findSum(arr, target)` kiểm tra điều gì?",
          "options": [
            "Trong mảng `arr` có tồn tại phần tử nào có giá trị bằng `target` hay không.",
            "Trong mảng `arr` có tồn tại hai phần tử có tổng bằng `target` hay không.",
            "Trong mảng `arr` có tồn tại hai phần tử có hiệu bằng `target` hay không.",
            "Trong mảng `arr` có tồn tại phần tử nào có giá trị gấp đôi `target` hay không."
          ],
          "correctAnswer": "Trong mảng `arr` có tồn tại hai phần tử có tổng bằng `target` hay không.",
          "reason": "Hàm `findSum` sử dụng một Set để lưu trữ các phần tử đã duyệt qua. Với mỗi phần tử, nó kiểm tra xem phần bù (target - arr[i]) đã có trong Set hay chưa. Nếu có, nghĩa là tồn tại hai phần tử có tổng bằng target."
        },
        {
          "id": 75,
          "question": "Cấu trúc dữ liệu nào sau đây KHÔNG hỗ trợ thao tác tìm kiếm (search) với độ phức tạp O(log n) trong trường hợp tốt nhất?",
          "options": [
            "Cây nhị phân tìm kiếm (BST)",
            "Cây AVL",
            "B-Tree",
            "Danh sách liên kết đơn (Singly Linked List)"
          ],
          "correctAnswer": "Danh sách liên kết đơn (Singly Linked List)",
          "reason": "Danh sách liên kết đơn chỉ cho phép tìm kiếm tuyến tính với độ phức tạp O(n). Các cấu trúc dữ liệu còn lại đều hỗ trợ tìm kiếm với độ phức tạp O(log n) trong trường hợp tốt nhất."
        },
        {
          "id": 76,
          "question": "Giả sử bạn đang phát triển một ứng dụng bản đồ và cần tìm đường đi ngắn nhất giữa hai thành phố. Thuật toán nào sau đây là phù hợp nhất?",
          "options": [
            "Depth-First Search (DFS)",
            "Insertion Sort",
            "Dijkstra",
            "Topological Sort"
          ],
          "correctAnswer": "Dijkstra",
          "reason": "Thuật toán Dijkstra được thiết kế để tìm đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh khác trong đồ thị có trọng số không âm, rất phù hợp cho bài toán tìm đường đi trên bản đồ."
        },
        {
          "id": 77,
          "question": "Trong cây, node không có node cha được gọi là gì?",
          "options": [
            "Lá (Leaf)",
            "Gốc (Root)",
            "Node trung gian (Internal Node)",
            "Node rỗng (Null Node)"
          ],
          "correctAnswer": "Gốc (Root)",
          "reason": "Node không có node cha trong cây được gọi là node gốc (root)."
        },
        {
          "id": 78,
          "question": "Cho đồ thị G = (V, E). Điều kiện cần và đủ để G có một cây bao trùm (Spanning Tree) là gì?",
          "options": [
            "G phải là đồ thị đầy đủ.",
            "G phải là đồ thị có hướng.",
            "G phải liên thông.",
            "G không được có chu trình."
          ],
          "correctAnswer": "G phải liên thông.",
          "reason": "Một đồ thị có cây bao trùm khi và chỉ khi nó liên thông."
        },
        {
          "id": 79,
          "question": "Trong thuật toán sắp xếp chọn (Selection Sort), ở lần lặp thứ `i` của vòng lặp ngoài, phần tử nào sẽ được đưa về đúng vị trí?",
          "options": [
            "Phần tử nhỏ nhất trong mảng.",
            "Phần tử lớn nhất trong mảng.",
            "Phần tử nhỏ nhất trong đoạn từ `arr[i]` đến cuối mảng.",
            "Phần tử lớn nhất trong đoạn từ `arr[i]` đến cuối mảng."
          ],
          "correctAnswer": "Phần tử nhỏ nhất trong đoạn từ `arr[i]` đến cuối mảng.",
          "reason": "Ở lần lặp thứ `i`, Selection Sort sẽ tìm phần tử nhỏ nhất trong đoạn từ `arr[i]` đến cuối mảng và hoán đổi nó với `arr[i]`."
        },
        {
          "id": 80,
          "question": "Cho đoạn code sau:\n```javascript\nfunction mystery(arr) {\n  const n = arr.length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result[i] = 0;\n    for (let j = 0; j <= i; j++) {\n      result[i] += arr[j];\n    }\n  }\n  return result;\n}\n```\nHàm `mystery(arr)` trả về mảng `result` có ý nghĩa gì?",
          "options": [
            "`result[i]` là tổng các phần tử từ `arr[0]` đến `arr[i]`.",
            "`result[i]` là tổng các phần tử từ `arr[i]` đến cuối mảng.",
            "`result[i]` là trung bình cộng các phần tử từ `arr[0]` đến `arr[i]`.",
            "`result[i]` là số lượng phần tử trong mảng nhỏ hơn `arr[i]`."
          ],
          "correctAnswer": "`result[i]` là tổng các phần tử từ `arr[0]` đến `arr[i]`.",
          "reason": "Vòng lặp bên trong tính tổng các phần tử từ `arr[0]` đến `arr[i]` và lưu vào `result[i]`."
        },
        {
          "id": 81,
          "question": "Cho cây nhị phân dưới đây:\n\n```\n      5\n    /   \\\n   3     8\n  /     / \\\n 2     7   9\n```\nThao tác nào sau đây sẽ KHÔNG làm thay đổi cấu trúc của cây?",
          "options": ["Xoá node 2", "Xoá node 7", "Xoá node 5", "Xoá node 9"],
          "correctAnswer": ["Xoá node 2", "Xoá node 7", "Xoá node 9"],
          "reason": "Xóa node lá (2, 7, 9) không làm thay đổi cấu trúc của cây. Xóa node 5 (gốc) sẽ làm thay đổi cấu trúc cây."
        },
        {
          "id": 82,
          "question": "Trong bảng băm, hiện tượng đụng độ (collision) xảy ra khi nào?",
          "options": [
            "Hai khóa khác nhau được băm vào cùng một chỉ số.",
            "Một khóa được băm vào một chỉ số đã bị chiếm bởi một khóa khác.",
            "Cả A và B đều đúng.",
            "Không có trường hợp nào ở trên."
          ],
          "correctAnswer": "Cả A và B đều đúng.",
          "reason": "Đụng độ xảy ra khi hai khóa khác nhau được hàm băm ánh xạ vào cùng một vị trí (chỉ số) trong bảng băm."
        },
        {
          "id": 83,
          "question": "Thuật toán sắp xếp nào sau đây là không ổn định (unstable)?",
          "options": [
            "Merge Sort",
            "Insertion Sort",
            "Bubble Sort",
            "Quick Sort"
          ],
          "correctAnswer": "Quick Sort",
          "reason": "Quick Sort là không ổn định vì thứ tự tương đối của các phần tử bằng nhau có thể bị thay đổi sau khi sắp xếp (phụ thuộc vào cách chọn pivot và cài đặt). Các thuật toán còn lại đều là sắp xếp ổn định."
        },
        {
          "id": 84,
          "question": "Cho mảng `arr = [6, 5, 3, 1, 8, 7, 2, 4]`. Sau khi thực hiện thuật toán Heap Sort, mảng sẽ trở thành như thế nào?",
          "options": [
            "`[1, 2, 3, 4, 5, 6, 7, 8]`",
            "`[8, 7, 6, 5, 4, 3, 2, 1]`",
            "`[1, 3, 2, 4, 8, 7, 6, 5]`",
            "`[8, 6, 7, 5, 4, 3, 2, 1]`"
          ],
          "correctAnswer": "`[1, 2, 3, 4, 5, 6, 7, 8]`",
          "reason": "Heap Sort sẽ sắp xếp mảng tăng dần, do đó kết quả là `[1, 2, 3, 4, 5, 6, 7, 8]`."
        },
        {
          "id": 85,
          "question": "Trong thuật toán Floyd-Warshall, `Dk[i][j]` biểu thị điều gì?",
          "options": [
            "Độ dài đường đi ngắn nhất từ i đến j.",
            "Độ dài đường đi ngắn nhất từ i đến j chỉ qua các đỉnh từ 1 đến k.",
            "Độ dài đường đi ngắn nhất từ i đến j chỉ qua đỉnh k.",
            "Số cạnh ít nhất trên đường đi từ i đến j."
          ],
          "correctAnswer": "Độ dài đường đi ngắn nhất từ i đến j chỉ qua các đỉnh từ 1 đến k.",
          "reason": "Trong Floyd-Warshall, `Dk[i][j]` biểu thị độ dài đường đi ngắn nhất từ đỉnh i đến đỉnh j mà chỉ đi qua các đỉnh trung gian có chỉ số từ 1 đến k."
        },
        {
          "id": 86,
          "question": "Cho đoạn code sau:\n```javascript\nfunction solve(n, a, b, c) {\n  if (n == 0) return 0;\n  if (n < 0) return -Infinity;\n\n  const res1 = solve(n - a, a, b, c);\n  const res2 = solve(n - b, a, b, c);\n  const res3 = solve(n - c, a, b, c);\n\n  return 1 + Math.max(res1, res2, res3);\n}\n```\nHàm `solve` đang giải quyết bài toán gì?",
          "options": [
            "Tìm số cách phân tích số n thành tổng các số a, b, c.",
            "Tìm cách phân tích số n thành tổng các số a, b, c sao cho sử dụng ít số nhất.",
            "Tìm cách phân tích số n thành tổng các số a, b, c sao cho sử dụng nhiều số nhất.",
            "Kiểm tra xem có thể phân tích số n thành tổng các số a, b, c hay không."
          ],
          "correctAnswer": "Tìm cách phân tích số n thành tổng các số a, b, c sao cho sử dụng nhiều số nhất.",
          "reason": "Hàm `solve` sử dụng đệ quy để thử tất cả các cách phân tích số n thành tổng các số a, b, c và trả về số lượng số lớn nhất có thể sử dụng (1 + ...)."
        },
        {
          "id": 87,
          "question": "Kỹ thuật thiết kế giải thuật nào phù hợp để giải bài toán tìm đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh còn lại trong đồ thị có trọng số không âm?",
          "options": [
            "Quay lui (Backtracking)",
            "Chia để trị (Divide and Conquer)",
            "Tham lam (Greedy)",
            "Nhánh cận (Branch and Bound)"
          ],
          "correctAnswer": "Tham lam (Greedy)",
          "reason": "Thuật toán Dijkstra, một thuật toán Tham lam, được sử dụng để giải bài toán tìm đường đi ngắn nhất từ một đỉnh đến tất cả các đỉnh còn lại trong đồ thị có trọng số không âm."
        },
        {
          "id": 88,
          "question": "Trong đồ thị có trọng số, trọng số của một cạnh thường biểu thị điều gì?",
          "options": [
            "Chi phí, độ dài, hoặc khoảng cách giữa hai đỉnh.",
            "Hướng của cạnh.",
            "Bậc của đỉnh.",
            "Thứ tự duyệt của cạnh."
          ],
          "correctAnswer": "Chi phí, độ dài, hoặc khoảng cách giữa hai đỉnh.",
          "reason": "Trọng số của cạnh trong đồ thị có trọng số thường biểu thị chi phí, độ dài, hoặc khoảng cách giữa hai đỉnh mà cạnh đó nối."
        },
        {
          "id": 89,
          "question": "Cho cây nhị phân tìm kiếm (BST). Phát biểu nào sau đây là **sai**?",
          "options": [
            "Tìm kiếm, chèn và xóa trung bình mất O(log n) thời gian.",
            "Cây con bên trái của một node chỉ chứa các node có giá trị nhỏ hơn node đó.",
            "Cây con bên phải của một node chỉ chứa các node có giá trị lớn hơn node đó.",
            "BST luôn là cây cân bằng."
          ],
          "correctAnswer": "BST luôn là cây cân bằng.",
          "reason": "BST không nhất thiết phải là cây cân bằng. Các cây AVL, cây đỏ-đen là các biến thể của BST tự cân bằng."
        },
        {
          "id": 90,
          "question": "Khi nào thì nên sử dụng BFS thay vì DFS?",
          "options": [
            "Khi cần tìm đường đi ngắn nhất (theo số cạnh) trong đồ thị không trọng số.",
            "Khi cần duyệt đồ thị theo chiều sâu.",
            "Khi không gian bộ nhớ bị hạn chế.",
            "Khi đồ thị có chu trình."
          ],
          "correctAnswer": "Khi cần tìm đường đi ngắn nhất (theo số cạnh) trong đồ thị không trọng số.",
          "reason": "BFS đảm bảo tìm thấy đường đi ngắn nhất (theo số cạnh) trong đồ thị không trọng số, trong khi DFS thì không."
        },
        {
          "id": 91,
          "question": "Cho đoạn code sau:\n```javascript\nfunction mystery(arr) {\n  const n = arr.length;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = 0; j < n - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        const temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n  return arr;\n}\n```\nHàm `mystery(arr)` thực hiện thuật toán sắp xếp nào?",
          "options": [
            "Insertion Sort",
            "Selection Sort",
            "Bubble Sort",
            "Merge Sort"
          ],
          "correctAnswer": "Bubble Sort",
          "reason": "Hàm `mystery(arr)` triển khai thuật toán sắp xếp nổi bọt (Bubble Sort), so sánh và đổi chỗ các cặp phần tử liền kề nếu chúng không đúng thứ tự."
        },
        {
          "id": 92,
          "question": "Trong thuật toán Dijkstra, nếu tại một bước, ta tìm thấy một đường đi mới đến đỉnh `v` ngắn hơn đường đi hiện tại, ta sẽ làm gì?",
          "options": [
            "Bỏ qua đường đi mới.",
            "Cập nhật lại khoảng cách đến đỉnh `v`.",
            "Đánh dấu đỉnh `v` là đã duyệt xong.",
            "Xóa đỉnh `v` khỏi hàng đợi ưu tiên."
          ],
          "correctAnswer": "Cập nhật lại khoảng cách đến đỉnh `v`.",
          "reason": "Nếu tìm thấy một đường đi mới đến đỉnh `v` ngắn hơn, ta sẽ cập nhật lại khoảng cách đến `v` và đỉnh cha của `v` trong hàng đợi ưu tiên."
        },
        {
          "id": 93,
          "question": "Cho đồ thị G = (V, E). Nếu G là đồ thị có hướng, không có chu trình và liên thông thì G là gì?",
          "options": ["Cây", "Rừng", "Đồ thị đầy đủ", "Không có cái nào đúng"],
          "correctAnswer": "Cây",
          "reason": "Đồ thị có hướng, không có chu trình và liên thông cũng chính là một cây có hướng"
        },
        {
          "id": 94,
          "question": "Trong thuật toán Kruskal, nếu hai đỉnh u và v đã thuộc cùng một thành phần liên thông thì sao?",
          "options": [
            "Thêm cạnh (u, v) vào cây bao trùm.",
            "Bỏ qua cạnh (u, v).",
            "Xóa cạnh (u, v) khỏi đồ thị.",
            "Không xác định."
          ],
          "correctAnswer": "Bỏ qua cạnh (u, v).",
          "reason": "Nếu hai đỉnh u và v đã thuộc cùng một thành phần liên thông, việc thêm cạnh (u, v) sẽ tạo thành chu trình, do đó ta bỏ qua cạnh này."
        },
        {
          "id": 95,
          "question": "Giả sử bạn đang phát triển một ứng dụng quản lý công việc (todo list). Bạn cần lưu trữ các công việc theo thứ tự ưu tiên. Cấu trúc dữ liệu nào sau đây là phù hợp nhất?",
          "options": ["Array", "Linked List", "Hash Table", "Priority Queue"],
          "correctAnswer": "Priority Queue",
          "reason": "Hàng đợi ưu tiên (Priority Queue) cho phép lấy ra công việc có độ ưu tiên cao nhất một cách hiệu quả, rất phù hợp cho ứng dụng quản lý công việc."
        },
        {
          "id": 96,
          "question": "Cho đoạn code sau:\n```javascript\nfunction mystery(n) {\n  const dp = [];\n  dp[0] = 0;\n  dp[1] = 1;\n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[n];\n}\n```\nHàm `mystery(n)` tính toán gì?",
          "options": [
            "Giai thừa của n.",
            "Số Fibonacci thứ n.",
            "Tổng các số từ 1 đến n.",
            "Lũy thừa của n."
          ],
          "correctAnswer": "Số Fibonacci thứ n.",
          "reason": "Hàm `mystery(n)` sử dụng kỹ thuật quy hoạch động (cụ thể là phương pháp tabulation) để tính số Fibonacci thứ n."
        },
        {
          "id": 97,
          "question": "Trong thuật toán sắp xếp nhanh (Quick Sort), việc lựa chọn phần tử chốt (pivot) ảnh hưởng như thế nào đến hiệu suất của thuật toán?",
          "options": [
            "Không ảnh hưởng gì.",
            "Chọn pivot tốt có thể giúp thuật toán đạt độ phức tạp O(n log n) trong trường hợp trung bình, chọn pivot xấu có thể khiến độ phức tạp lên đến O(n^2).",
            "Chọn pivot tốt có thể giúp thuật toán đạt độ phức tạp O(log n).",
            "Chọn pivot xấu có thể giúp thuật toán đạt độ phức tạp O(n)."
          ],
          "correctAnswer": "Chọn pivot tốt có thể giúp thuật toán đạt độ phức tạp O(n log n) trong trường hợp trung bình, chọn pivot xấu có thể khiến độ phức tạp lên đến O(n^2).",
          "reason": "Việc lựa chọn pivot ảnh hưởng lớn đến hiệu suất của Quick Sort. Chọn pivot tốt (gần với trung vị) giúp phân chia mảng thành hai phần cân bằng, đạt độ phức tạp O(n log n). Chọn pivot xấu (phần tử nhỏ nhất hoặc lớn nhất) khiến mảng bị lệch, dẫn đến độ phức tạp O(n^2)."
        },
        {
          "id": 98,
          "question": "Khẳng định nào sau đây là **sai** về quay lui (Backtracking)?",
          "options": [
            "Là một kỹ thuật thiết kế giải thuật.",
            "Thường được sử dụng để giải các bài toán thỏa mãn ràng buộc.",
            "Có thể cải tiến bằng kỹ thuật nhánh cận (Branch and Bound).",
            "Luôn tìm ra lời giải tối ưu cho mọi bài toán."
          ],
          "correctAnswer": "Luôn tìm ra lời giải tối ưu cho mọi bài toán.",
          "reason": "Quay lui không đảm bảo luôn tìm ra lời giải tối ưu, nó chỉ đơn thuần là thử tất cả các khả năng để tìm ra lời giải thỏa mãn ràng buộc."
        },
        {
          "id": 99,
          "question": "Cho đồ thị G = (V, E). Nếu G là đồ thị Euler thì sao?",
          "options": [
            "G có thể có đỉnh bậc lẻ.",
            "G chắc chắn có chu trình.",
            "G có thể không liên thông.",
            "G chắc chắn là đồ thị có hướng."
          ],
          "correctAnswer": "G chắc chắn có chu trình.",
          "reason": "Đồ thị Euler là đồ thị có chu trình Euler, do đó chắc chắn nó phải có chu trình."
        },
        {
          "id": 100,
          "question": "Trong thuật toán tô màu đồ thị, hai đỉnh kề nhau:",
          "options": [
            "Phải được tô cùng màu.",
            "Có thể được tô cùng màu hoặc khác màu.",
            "Phải được tô khác màu.",
            "Không có quy tắc nào về màu sắc."
          ],
          "correctAnswer": "Phải được tô khác màu.",
          "reason": "Trong thuật toán tô màu đồ thị, hai đỉnh kề nhau (có cạnh nối trực tiếp) phải được tô bằng hai màu khác nhau."
        }
      ]
    },
    {
      "id": 4,
      "title": "Operating Systems Quiz",
      "timeLimit": 1800,
      "questions": [
        {
          "id": 1,
          "question": "Chức năng chính của hệ điều hành là gì?",
          "options": [
            "Quản lý ứng dụng văn phòng",
            "Quản lý tài nguyên phần cứng",
            "Chạy trò chơi",
            "Soạn thảo văn bản"
          ],
          "correctAnswer": "Quản lý tài nguyên phần cứng",
          "reason": "Hệ điều hành là phần mềm hệ thống, có nhiệm vụ quản lý và điều phối tài nguyên phần cứng, cung cấp giao diện cho người dùng và các ứng dụng.",
          "relatedTopics": [
            "Khái niệm cơ bản về hệ điều hành",
            "Chức năng của hệ điều hành"
          ]
        },
        {
          "id": 2,
          "question": "Hệ điều hành nào sau đây là hệ điều hành đa nhiệm?",
          "options": ["MS-DOS", "Windows 10", "CP/M", "P-DOS"],
          "correctAnswer": "Windows 10",
          "reason": "Windows 10 cho phép nhiều ứng dụng chạy đồng thời. MS-DOS là hệ điều hành đơn nhiệm.",
          "relatedTopics": ["Các loại hệ điều hành", "Đa nhiệm"]
        },
        {
          "id": 3,
          "question": "Kiến trúc hệ điều hành nào mà toàn bộ hệ điều hành chạy trong kernel?",
          "options": ["Microkernel", "Monolithic", "Layered", "Modular"],
          "correctAnswer": "Monolithic",
          "reason": "Kiến trúc Monolithic có toàn bộ hệ điều hành (kernel, các dịch vụ) chạy trong một không gian bộ nhớ duy nhất.",
          "relatedTopics": ["Cấu trúc hệ điều hành", "Kiến trúc đơn khối"]
        },
        {
          "id": 4,
          "question": "Tiến trình là gì?",
          "options": [
            "Một phần mềm ứng dụng",
            "Một chương trình đang được thực thi",
            "Một thiết bị phần cứng",
            "Một tệp dữ liệu"
          ],
          "correctAnswer": "Một chương trình đang được thực thi",
          "reason": "Tiến trình là một thực thể hoạt động, đại diện cho một chương trình đang được CPU xử lý.",
          "relatedTopics": ["Tiến trình", "Khái niệm tiến trình"]
        },
        {
          "id": 5,
          "question": "Khối điều khiển tiến trình (PCB) chứa thông tin gì?",
          "options": [
            "Thông tin phần cứng máy tính",
            "Thông tin về địa chỉ mạng",
            "Thông tin về trạng thái tiến trình",
            "Thông tin về ứng dụng đang chạy"
          ],
          "correctAnswer": "Thông tin về trạng thái tiến trình",
          "reason": "PCB chứa các thông tin cần thiết để quản lý tiến trình, như trạng thái, bộ đếm chương trình, các thanh ghi.",
          "relatedTopics": ["Tiến trình", "Khối điều khiển tiến trình"]
        },
        {
          "id": 6,
          "question": "Trạng thái nào của tiến trình cho biết tiến trình đang chờ một sự kiện?",
          "options": ["Running", "Ready", "Waiting/Blocked", "Terminated"],
          "correctAnswer": "Waiting/Blocked",
          "reason": "Trạng thái Waiting/Blocked cho biết tiến trình đang chờ một sự kiện nào đó, ví dụ như I/O hoàn thành.",
          "relatedTopics": ["Tiến trình", "Trạng thái tiến trình"]
        },
        {
          "id": 7,
          "question": "Mục tiêu chính của lập lịch CPU là gì?",
          "options": [
            "Tối đa hóa bộ nhớ",
            "Tối thiểu hóa lỗi hệ thống",
            "Tối đa hóa hiệu suất CPU",
            "Tối đa hóa số lượng người dùng"
          ],
          "correctAnswer": "Tối đa hóa hiệu suất CPU",
          "reason": "Lập lịch CPU nhằm mục đích sử dụng CPU một cách hiệu quả nhất, tối đa hóa thông lượng, giảm thời gian chờ đợi.",
          "relatedTopics": ["Lập lịch CPU", "Mục tiêu lập lịch CPU"]
        },
        {
          "id": 8,
          "question": "Thuật toán lập lịch nào dựa trên nguyên tắc FIFO?",
          "options": [
            "Shortest-Job-First",
            "Round Robin",
            "First-Come, First-Served",
            "Priority Scheduling"
          ],
          "correctAnswer": "First-Come, First-Served",
          "reason": "FCFS phục vụ tiến trình theo thứ tự đến hàng đợi.",
          "relatedTopics": ["Lập lịch CPU", "Thuật toán FCFS"]
        },
        {
          "id": 9,
          "question": "Thuật toán lập lịch nào có thể xảy ra 'starvation'?",
          "options": [
            "Round Robin",
            "Shortest-Job-First",
            "First-Come, First-Served",
            "Priority Scheduling"
          ],
          "correctAnswer": "Priority Scheduling",
          "reason": "Priority Scheduling có thể gây ra tình trạng 'starvation' khi các tiến trình có độ ưu tiên thấp không bao giờ được cấp CPU.",
          "relatedTopics": [
            "Lập lịch CPU",
            "Thuật toán Priority Scheduling",
            "Starvation"
          ]
        },
        {
          "id": 10,
          "question": "Vấn đề 'race condition' xảy ra khi nào?",
          "options": [
            "Một tiến trình chạy quá nhanh",
            "Hai tiến trình tranh giành tài nguyên chung",
            "Một tiến trình bị lỗi",
            "Hệ thống hết bộ nhớ"
          ],
          "correctAnswer": "Hai tiến trình tranh giành tài nguyên chung",
          "reason": "Race condition xảy ra khi nhiều tiến trình truy cập đồng thời vào tài nguyên dùng chung, gây ra kết quả không xác định.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Race condition"]
        },
        {
          "id": 11,
          "question": "Miền găng (Critical Section) là gì?",
          "options": [
            "Một đoạn code có lỗi",
            "Một khu vực bộ nhớ",
            "Một đoạn code truy cập tài nguyên dùng chung",
            "Một hàm đặc biệt"
          ],
          "correctAnswer": "Một đoạn code truy cập tài nguyên dùng chung",
          "reason": "Miền găng là đoạn code mà trong đó tiến trình truy cập vào các tài nguyên dùng chung và cần có cơ chế bảo vệ để tránh race condition.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Miền găng"]
        },
        {
          "id": 12,
          "question": "Semaphore được sử dụng cho mục đích gì?",
          "options": [
            "Quản lý bộ nhớ",
            "Lập lịch CPU",
            "Đồng bộ hóa tiến trình",
            "Quản lý thiết bị I/O"
          ],
          "correctAnswer": "Đồng bộ hóa tiến trình",
          "reason": "Semaphore là một công cụ đồng bộ hóa được sử dụng để kiểm soát truy cập vào tài nguyên dùng chung giữa các tiến trình.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Semaphore"]
        },
        {
          "id": 13,
          "question": "Bế tắc (Deadlock) xảy ra khi nào?",
          "options": [
            "Một tiến trình chạy vô hạn",
            "Các tiến trình chờ nhau mãi mãi",
            "Hệ thống hết tài nguyên",
            "Một tiến trình gặp lỗi"
          ],
          "correctAnswer": "Các tiến trình chờ nhau mãi mãi",
          "reason": "Bế tắc xảy ra khi một tập hợp các tiến trình đang chờ một tài nguyên mà lại đang được giữ bởi một tiến trình khác trong tập đó, tạo thành một chu trình chờ đợi.",
          "relatedTopics": ["Bế tắc", "Khái niệm bế tắc"]
        },
        {
          "id": 14,
          "question": "Điều kiện nào sau đây không phải là điều kiện cần cho bế tắc?",
          "options": [
            "Loại trừ tương hỗ",
            "Giữ và chờ",
            "Không trưng dụng",
            "Đa nhiệm"
          ],
          "correctAnswer": "Đa nhiệm",
          "reason": "Đa nhiệm là một đặc điểm của hệ điều hành, không liên quan đến các điều kiện cần cho bế tắc.",
          "relatedTopics": ["Bế tắc", "Điều kiện cần cho bế tắc"]
        },
        {
          "id": 15,
          "question": "Thuật toán Banker's được sử dụng cho mục đích gì?",
          "options": [
            "Phòng ngừa bế tắc",
            "Tránh né bế tắc",
            "Phát hiện bế tắc",
            "Khắc phục bế tắc"
          ],
          "correctAnswer": "Tránh né bế tắc",
          "reason": "Thuật toán Banker's là một thuật toán được sử dụng để tránh bế tắc bằng cách kiểm tra trạng thái cấp phát tài nguyên có an toàn hay không.",
          "relatedTopics": ["Bế tắc", "Tránh né bế tắc", "Thuật toán Banker's"]
        },
        {
          "id": 16,
          "question": "MMU (Memory Management Unit) có chức năng gì?",
          "options": [
            "Quản lý CPU",
            "Quản lý thiết bị I/O",
            "Ánh xạ địa chỉ logic sang địa chỉ vật lý",
            "Quản lý mạng"
          ],
          "correctAnswer": "Ánh xạ địa chỉ logic sang địa chỉ vật lý",
          "reason": "MMU là một đơn vị phần cứng thực hiện việc ánh xạ địa chỉ logic do CPU tạo ra sang địa chỉ vật lý trong bộ nhớ.",
          "relatedTopics": ["Quản lý bộ nhớ", "MMU"]
        },
        {
          "id": 17,
          "question": "Phân vùng cố định trong quản lý bộ nhớ có nhược điểm gì?",
          "options": [
            "Phân mảnh ngoại vi",
            "Phân mảnh nội bộ",
            "Tốn nhiều thời gian",
            "Khó cài đặt"
          ],
          "correctAnswer": "Phân mảnh nội bộ",
          "reason": "Phân vùng cố định có thể gây ra phân mảnh nội bộ khi một tiến trình nhỏ được cấp một phân vùng lớn hơn kích thước của nó.",
          "relatedTopics": [
            "Quản lý bộ nhớ",
            "Phân vùng cố định",
            "Phân mảnh bộ nhớ"
          ]
        },
        {
          "id": 18,
          "question": "Phân trang (Paging) giải quyết vấn đề gì?",
          "options": [
            "Phân mảnh nội bộ",
            "Phân mảnh ngoại vi",
            "Bế tắc",
            "Race condition"
          ],
          "correctAnswer": "Phân mảnh ngoại vi",
          "reason": "Phân trang chia không gian địa chỉ logic và vật lý thành các khối có kích thước cố định, giúp loại bỏ phân mảnh ngoại vi.",
          "relatedTopics": ["Quản lý bộ nhớ", "Phân trang"]
        },
        {
          "id": 19,
          "question": "TLB (Translation Lookaside Buffer) có chức năng gì?",
          "options": [
            "Lưu trữ code chương trình",
            "Lưu trữ các entry của bảng trang thường xuyên dùng",
            "Lưu trữ dữ liệu người dùng",
            "Lưu trữ thông tin của thiết bị I/O"
          ],
          "correctAnswer": "Lưu trữ các entry của bảng trang thường xuyên dùng",
          "reason": "TLB là một bộ nhớ cache nhỏ, tốc độ cao để lưu trữ các ánh xạ trang/khung, giúp tăng tốc độ truy cập bộ nhớ.",
          "relatedTopics": ["Quản lý bộ nhớ", "TLB"]
        },
        {
          "id": 20,
          "question": "Lỗi trang (Page Fault) xảy ra khi nào?",
          "options": [
            "Trang được truy cập không có trong bộ nhớ",
            "Trang được truy cập bị lỗi",
            "Bộ nhớ đã đầy",
            "CPU quá tải"
          ],
          "correctAnswer": "Trang được truy cập không có trong bộ nhớ",
          "reason": "Lỗi trang xảy ra khi CPU cố gắng truy cập vào một trang không có trong bộ nhớ chính.",
          "relatedTopics": ["Quản lý bộ nhớ", "Lỗi trang"]
        },
        {
          "id": 21,
          "question": "Thuật toán thay thế trang nào dựa trên nguyên tắc 'First-In, First-Out'?",
          "options": ["LRU", "OPT", "FIFO", "LFU"],
          "correctAnswer": "FIFO",
          "reason": "FIFO thay thế trang được nạp vào bộ nhớ lâu nhất.",
          "relatedTopics": [
            "Quản lý bộ nhớ",
            "Thuật toán thay thế trang",
            "FIFO"
          ]
        },
        {
          "id": 22,
          "question": "Hệ thống tập tin (File System) có chức năng gì?",
          "options": [
            "Quản lý CPU",
            "Quản lý bộ nhớ",
            "Quản lý việc lưu trữ và truy xuất dữ liệu",
            "Quản lý thiết bị I/O"
          ],
          "correctAnswer": "Quản lý việc lưu trữ và truy xuất dữ liệu",
          "reason": "Hệ thống tập tin cung cấp một cách để tổ chức, lưu trữ và truy xuất dữ liệu trên các thiết bị lưu trữ thứ cấp.",
          "relatedTopics": ["Hệ thống tập tin"]
        },
        {
          "id": 23,
          "question": "Cấp phát không gian đĩa liên tục (Contiguous Allocation) có nhược điểm gì?",
          "options": [
            "Truy cập chậm",
            "Phân mảnh ngoại vi",
            "Khó quản lý",
            "Tốn bộ nhớ"
          ],
          "correctAnswer": "Phân mảnh ngoại vi",
          "reason": "Cấp phát liên tục có thể gây ra phân mảnh ngoại vi khi các khối đĩa trống bị phân tán.",
          "relatedTopics": ["Hệ thống tập tin", "Cấp phát không gian đĩa"]
        },
        {
          "id": 24,
          "question": "Đường dẫn (Pathname) trong hệ thống tập tin là gì?",
          "options": [
            "Tên tập tin",
            "Địa chỉ vật lý của tập tin",
            "Chuỗi các thư mục xác định vị trí tập tin",
            "Loại tập tin"
          ],
          "correctAnswer": "Chuỗi các thư mục xác định vị trí tập tin",
          "reason": "Đường dẫn là một cách để xác định vị trí của một tập tin trong hệ thống tập tin phân cấp.",
          "relatedTopics": ["Hệ thống tập tin", "Đường dẫn"]
        },
        {
          "id": 25,
          "question": "Hệ thống tập tin nào được sử dụng trong Linux?",
          "options": ["FAT", "NTFS", "ext4", "HFS+"],
          "correctAnswer": "ext4",
          "reason": "ext4 là một hệ thống tập tin phổ biến được sử dụng trong các hệ điều hành Linux.",
          "relatedTopics": ["Hệ thống tập tin", "ext4"]
        },
        {
          "id": 26,
          "question": "Mục tiêu chính của bảo mật (security) là gì?",
          "options": [
            "Tăng tốc hệ thống",
            "Bảo vệ tài nguyên",
            "Quản lý bộ nhớ",
            "Tối ưu hóa hiệu suất"
          ],
          "correctAnswer": "Bảo vệ tài nguyên",
          "reason": "Bảo mật hệ thống nhằm bảo vệ các tài nguyên khỏi sự truy cập trái phép hoặc các hoạt động gây hại.",
          "relatedTopics": ["Bảo mật và bảo vệ"]
        },
        {
          "id": 27,
          "question": "Tính bí mật (Confidentiality) trong bảo mật có nghĩa là gì?",
          "options": [
            "Đảm bảo dữ liệu luôn sẵn sàng",
            "Đảm bảo dữ liệu không bị thay đổi",
            "Đảm bảo dữ liệu chỉ được truy cập bởi người được ủy quyền",
            "Đảm bảo tính chính xác của dữ liệu"
          ],
          "correctAnswer": "Đảm bảo dữ liệu chỉ được truy cập bởi người được ủy quyền",
          "reason": "Tính bí mật đảm bảo rằng thông tin được giữ kín và chỉ được tiếp cận bởi những người có thẩm quyền.",
          "relatedTopics": ["Bảo mật và bảo vệ", "Tính bí mật"]
        },
        {
          "id": 28,
          "question": "Virus máy tính là gì?",
          "options": [
            "Một loại phần cứng",
            "Một chương trình tự sao chép và lây lan",
            "Một thiết bị mạng",
            "Một loại hệ điều hành"
          ],
          "correctAnswer": "Một chương trình tự sao chép và lây lan",
          "reason": "Virus máy tính là một loại mã độc có khả năng tự sao chép và lây lan sang các chương trình khác.",
          "relatedTopics": ["Bảo mật và bảo vệ", "Virus"]
        },
        {
          "id": 29,
          "question": "Xác thực (Authentication) có mục đích gì?",
          "options": [
            "Cấp quyền truy cập tài nguyên",
            "Xác minh danh tính người dùng",
            "Mã hóa dữ liệu",
            "Kiểm soát lưu lượng mạng"
          ],
          "correctAnswer": "Xác minh danh tính người dùng",
          "reason": "Xác thực là quá trình kiểm tra và xác minh danh tính của người dùng trước khi cấp quyền truy cập vào hệ thống.",
          "relatedTopics": ["Bảo mật và bảo vệ", "Xác thực"]
        },
        {
          "id": 30,
          "question": "Mật khẩu (password) thuộc phương pháp xác thực nào?",
          "options": [
            "Sinh trắc học",
            "Token",
            "Something you know",
            "Something you have"
          ],
          "correctAnswer": "Something you know",
          "reason": "Mật khẩu thuộc phương pháp xác thực dựa trên thông tin mà người dùng biết.",
          "relatedTopics": ["Bảo mật và bảo vệ", "Mật khẩu"]
        },
        {
          "id": 31,
          "question": "Danh sách kiểm soát truy cập (ACL) dùng để làm gì?",
          "options": [
            "Xác thực người dùng",
            "Kiểm soát quyền truy cập tài nguyên",
            "Mã hóa dữ liệu",
            "Phân tích lưu lượng mạng"
          ],
          "correctAnswer": "Kiểm soát quyền truy cập tài nguyên",
          "reason": "ACL là một danh sách các quyền truy cập được liên kết với mỗi tài nguyên, cho phép kiểm soát ai có quyền truy cập vào tài nguyên nào.",
          "relatedTopics": ["Bảo mật và bảo vệ", "ACL"]
        },
        {
          "id": 32,
          "question": "Mã hóa đối xứng (Symmetric Encryption) có đặc điểm gì?",
          "options": [
            "Sử dụng hai khóa khác nhau",
            "Sử dụng cùng một khóa cho cả mã hóa và giải mã",
            "Mã hóa bằng khóa công khai, giải mã bằng khóa riêng tư",
            "Không cần khóa"
          ],
          "correctAnswer": "Sử dụng cùng một khóa cho cả mã hóa và giải mã",
          "reason": "Mã hóa đối xứng sử dụng một khóa bí mật chung cho cả quá trình mã hóa và giải mã.",
          "relatedTopics": ["Bảo mật và bảo vệ", "Mã hóa đối xứng"]
        },
        {
          "id": 33,
          "question": "Tường lửa (Firewall) có vai trò gì trong bảo mật?",
          "options": [
            "Mã hóa dữ liệu",
            "Kiểm soát lưu lượng mạng",
            "Phát hiện virus",
            "Quản lý tài khoản người dùng"
          ],
          "correctAnswer": "Kiểm soát lưu lượng mạng",
          "reason": "Tường lửa là một hệ thống kiểm soát lưu lượng mạng, ngăn chặn các truy cập trái phép vào hệ thống.",
          "relatedTopics": ["Bảo mật và bảo vệ", "Tường lửa"]
        },
        {
          "id": 34,
          "question": "Hệ thống phát hiện xâm nhập (IDS) dùng để làm gì?",
          "options": [
            "Ngăn chặn virus",
            "Phát hiện các hoạt động đáng ngờ",
            "Mã hóa dữ liệu",
            "Xác thực người dùng"
          ],
          "correctAnswer": "Phát hiện các hoạt động đáng ngờ",
          "reason": "IDS giám sát lưu lượng mạng và hệ thống để phát hiện các dấu hiệu xâm nhập.",
          "relatedTopics": ["Bảo mật và bảo vệ", "IDS"]
        },
        {
          "id": 35,
          "question": "Phương thức truyền dữ liệu nào mà CPU trực tiếp điều khiển I/O?",
          "options": [
            "DMA",
            "Interrupt-driven I/O",
            "Programmed I/O",
            "Spooling"
          ],
          "correctAnswer": "Programmed I/O",
          "reason": "Trong programmed I/O, CPU trực tiếp kiểm soát quá trình truyền dữ liệu giữa CPU và thiết bị I/O.",
          "relatedTopics": ["Hệ thống I/O", "Programmed I/O"]
        },
        {
          "id": 36,
          "question": "Interrupt-driven I/O hoạt động như thế nào?",
          "options": [
            "CPU chủ động truyền dữ liệu",
            "CPU chờ thiết bị sẵn sàng rồi truyền dữ liệu",
            "Thiết bị thông báo cho CPU khi sẵn sàng truyền dữ liệu",
            "DMA tự động truyền dữ liệu"
          ],
          "correctAnswer": "Thiết bị thông báo cho CPU khi sẵn sàng truyền dữ liệu",
          "reason": "Trong Interrupt-driven I/O, thiết bị I/O sẽ gửi tín hiệu ngắt cho CPU khi có dữ liệu cần truyền.",
          "relatedTopics": ["Hệ thống I/O", "Interrupt-driven I/O"]
        },
        {
          "id": 37,
          "question": "DMA (Direct Memory Access) có lợi ích gì?",
          "options": [
            "Tăng tốc độ truyền dữ liệu",
            "Giảm tải cho CPU",
            "Đơn giản hóa quá trình truyền dữ liệu",
            "Tăng tính bảo mật"
          ],
          "correctAnswer": "Giảm tải cho CPU",
          "reason": "DMA cho phép thiết bị I/O truyền dữ liệu trực tiếp vào bộ nhớ mà không cần sự can thiệp của CPU, giảm tải cho CPU.",
          "relatedTopics": ["Hệ thống I/O", "DMA"]
        },
        {
          "id": 38,
          "question": "Buffering được sử dụng để làm gì?",
          "options": [
            "Tăng tốc CPU",
            "Đồng bộ tốc độ I/O",
            "Mã hóa dữ liệu",
            "Quản lý bộ nhớ"
          ],
          "correctAnswer": "Đồng bộ tốc độ I/O",
          "reason": "Buffering sử dụng bộ đệm để lưu trữ tạm thời dữ liệu, giúp đồng bộ tốc độ giữa các thiết bị I/O có tốc độ khác nhau.",
          "relatedTopics": ["Hệ thống I/O", "Buffering"]
        },
        {
          "id": 39,
          "question": "Spooling thường được dùng để làm gì?",
          "options": [
            "Quản lý CPU",
            "Lưu trữ dữ liệu tạm thời cho máy in",
            "Mã hóa dữ liệu",
            "Kết nối mạng"
          ],
          "correctAnswer": "Lưu trữ dữ liệu tạm thời cho máy in",
          "reason": "Spooling dùng đĩa làm bộ đệm để lưu trữ dữ liệu cần in, cho phép CPU tiếp tục thực hiện các công việc khác mà không phải chờ máy in.",
          "relatedTopics": ["Hệ thống I/O", "Spooling"]
        },
        {
          "id": 40,
          "question": "Cache được dùng để làm gì?",
          "options": [
            "Lưu trữ dữ liệu lâu dài",
            "Tăng tốc độ truy cập dữ liệu thường xuyên dùng",
            "Mã hóa dữ liệu",
            "Kiểm soát thiết bị I/O"
          ],
          "correctAnswer": "Tăng tốc độ truy cập dữ liệu thường xuyên dùng",
          "reason": "Cache là một bộ nhớ nhanh được sử dụng để lưu trữ dữ liệu được truy cập thường xuyên, giúp tăng tốc độ truy cập.",
          "relatedTopics": ["Hệ thống I/O", "Caching"]
        },
        {
          "id": 41,
          "question": "Device driver (trình điều khiển thiết bị) có vai trò gì?",
          "options": [
            "Điều khiển CPU",
            "Cung cấp giao diện giữa hệ điều hành và thiết bị",
            "Quản lý bộ nhớ",
            "Tăng tốc độ mạng"
          ],
          "correctAnswer": "Cung cấp giao diện giữa hệ điều hành và thiết bị",
          "reason": "Device driver là phần mềm cho phép hệ điều hành tương tác với các thiết bị phần cứng cụ thể.",
          "relatedTopics": ["Hệ thống I/O", "Device driver"]
        },
        {
          "id": 42,
          "question": "System call là gì?",
          "options": [
            "Một loại lệnh của CPU",
            "Một giao diện giữa ứng dụng và hệ điều hành",
            "Một loại thiết bị I/O",
            "Một loại thuật toán"
          ],
          "correctAnswer": "Một giao diện giữa ứng dụng và hệ điều hành",
          "reason": "System call là một API cho phép chương trình ứng dụng yêu cầu dịch vụ từ kernel của hệ điều hành.",
          "relatedTopics": ["System Calls"]
        },
        {
          "id": 43,
          "question": "Máy ảo (Virtual Machine) là gì?",
          "options": [
            "Một máy tính vật lý",
            "Một phần mềm mô phỏng máy tính vật lý",
            "Một thiết bị mạng",
            "Một hệ điều hành"
          ],
          "correctAnswer": "Một phần mềm mô phỏng máy tính vật lý",
          "reason": "Máy ảo là một phần mềm cho phép chạy một hệ điều hành khác trên một máy tính vật lý.",
          "relatedTopics": ["Virtual Machines"]
        },
        {
          "id": 44,
          "question": "Kernel là gì?",
          "options": [
            "Một phần mềm ứng dụng",
            "Phần cốt lõi của hệ điều hành",
            "Một thiết bị phần cứng",
            "Một thư viện lập trình"
          ],
          "correctAnswer": "Phần cốt lõi của hệ điều hành",
          "reason": "Kernel là phần mềm cơ bản của hệ điều hành, quản lý tài nguyên và cung cấp dịch vụ cơ bản.",
          "relatedTopics": ["Kernel"]
        },
        {
          "id": 45,
          "question": "Shell là gì?",
          "options": [
            "Một phần mềm ứng dụng",
            "Một giao diện dòng lệnh cho người dùng",
            "Một loại bộ nhớ",
            "Một thiết bị phần cứng"
          ],
          "correctAnswer": "Một giao diện dòng lệnh cho người dùng",
          "reason": "Shell cung cấp một giao diện cho phép người dùng tương tác với hệ điều hành thông qua các lệnh văn bản.",
          "relatedTopics": ["Shell"]
        },
        {
          "id": 46,
          "question": "API (Application Programming Interface) là gì?",
          "options": [
            "Một ngôn ngữ lập trình",
            "Một tập hợp các giao thức cho phép ứng dụng giao tiếp",
            "Một loại thiết bị I/O",
            "Một hệ điều hành"
          ],
          "correctAnswer": "Một tập hợp các giao thức cho phép ứng dụng giao tiếp",
          "reason": "API là một tập hợp các định nghĩa, giao thức và công cụ cho phép các ứng dụng phần mềm giao tiếp và tương tác với nhau.",
          "relatedTopics": ["API"]
        },
        {
          "id": 47,
          "question": "Hệ điều hành thời gian thực (Real-time OS) được sử dụng trong trường hợp nào?",
          "options": [
            "Ứng dụng văn phòng",
            "Hệ thống nhúng",
            "Máy chủ web",
            "Trò chơi"
          ],
          "correctAnswer": "Hệ thống nhúng",
          "reason": "Hệ điều hành thời gian thực được sử dụng trong các hệ thống nhúng mà thời gian phản hồi là yếu tố quan trọng.",
          "relatedTopics": [
            "Các loại hệ điều hành",
            "Hệ điều hành thời gian thực"
          ]
        },
        {
          "id": 48,
          "question": "Sự khác biệt giữa đa nhiệm ưu tiên (preemptive multitasking) và đa nhiệm hợp tác (cooperative multitasking) là gì?",
          "options": [
            "Số lượng tiến trình có thể chạy",
            "Cách tiến trình nhường CPU",
            "Kích thước bộ nhớ",
            "Tốc độ xử lý"
          ],
          "correctAnswer": "Cách tiến trình nhường CPU",
          "reason": "Trong đa nhiệm ưu tiên, hệ điều hành can thiệp và quyết định thời gian chạy của các tiến trình, còn trong đa nhiệm hợp tác, tiến trình tự nhường CPU.",
          "relatedTopics": [
            "Các loại hệ điều hành",
            "Đa nhiệm",
            "Đa nhiệm ưu tiên",
            "Đa nhiệm hợp tác"
          ]
        },
        {
          "id": 49,
          "question": "Hệ điều hành phân tán (Distributed OS) là gì?",
          "options": [
            "Hệ điều hành chạy trên một máy tính",
            "Hệ điều hành chạy trên nhiều máy tính được liên kết với nhau",
            "Hệ điều hành nhúng",
            "Hệ điều hành thời gian thực"
          ],
          "correctAnswer": "Hệ điều hành chạy trên nhiều máy tính được liên kết với nhau",
          "reason": "Hệ điều hành phân tán quản lý một nhóm máy tính để chúng hoạt động như một hệ thống thống nhất.",
          "relatedTopics": ["Các loại hệ điều hành", "Hệ điều hành phân tán"]
        },
        {
          "id": 50,
          "question": "Ưu điểm của kiến trúc Microkernel so với kiến trúc Monolithic là gì?",
          "options": [
            "Dễ lập trình hơn",
            "Hiệu suất cao hơn",
            "Tính bảo mật và tin cậy cao hơn",
            "Dễ triển khai hơn"
          ],
          "correctAnswer": "Tính bảo mật và tin cậy cao hơn",
          "reason": "Microkernel có ít code hơn trong kernel, làm giảm nguy cơ lỗi và tăng tính bảo mật.",
          "relatedTopics": [
            "Cấu trúc hệ điều hành",
            "Microkernel",
            "Monolithic"
          ]
        },
        {
          "id": 51,
          "question": "Luồng (Thread) là gì?",
          "options": [
            "Một chương trình đang chạy",
            "Một đơn vị thực thi cơ bản trong tiến trình",
            "Một tệp dữ liệu",
            "Một thiết bị phần cứng"
          ],
          "correctAnswer": "Một đơn vị thực thi cơ bản trong tiến trình",
          "reason": "Luồng là một chuỗi các lệnh thực thi trong một tiến trình, và nhiều luồng có thể chạy đồng thời trong cùng một tiến trình.",
          "relatedTopics": ["Tiến trình", "Luồng"]
        },
        {
          "id": 52,
          "question": "Luồng mức người dùng (User-Level Thread) được quản lý bởi ai?",
          "options": [
            "Kernel",
            "Thư viện luồng ở mức người dùng",
            "CPU",
            "BIOS"
          ],
          "correctAnswer": "Thư viện luồng ở mức người dùng",
          "reason": "Luồng mức người dùng được quản lý bởi thư viện luồng trong không gian người dùng mà không cần sự can thiệp của kernel.",
          "relatedTopics": ["Tiến trình", "Luồng mức người dùng"]
        },
        {
          "id": 53,
          "question": "Giao tiếp giữa các tiến trình (IPC) có mục đích gì?",
          "options": [
            "Chia sẻ bộ nhớ",
            "Đồng bộ hóa tiến trình",
            "Cho phép các tiến trình giao tiếp và chia sẻ dữ liệu",
            "Kiểm soát tài nguyên"
          ],
          "correctAnswer": "Cho phép các tiến trình giao tiếp và chia sẻ dữ liệu",
          "reason": "IPC là cơ chế cho phép các tiến trình khác nhau có thể trao đổi thông tin và làm việc cùng nhau.",
          "relatedTopics": ["Tiến trình", "Giao tiếp giữa các tiến trình"]
        },
        {
          "id": 54,
          "question": "Bộ nhớ chia sẻ (Shared Memory) là gì?",
          "options": [
            "Bộ nhớ chỉ dùng cho một tiến trình",
            "Bộ nhớ dùng chung bởi nhiều tiến trình",
            "Bộ nhớ ảo",
            "Bộ nhớ ROM"
          ],
          "correctAnswer": "Bộ nhớ dùng chung bởi nhiều tiến trình",
          "reason": "Trong bộ nhớ chia sẻ, các tiến trình có thể truy cập và chia sẻ dữ liệu trong cùng một vùng bộ nhớ.",
          "relatedTopics": [
            "Tiến trình",
            "Giao tiếp giữa các tiến trình",
            "Bộ nhớ chia sẻ"
          ]
        },
        {
          "id": 55,
          "question": "Trao đổi thông điệp (Message Passing) là gì?",
          "options": [
            "Giao tiếp thông qua bộ nhớ dùng chung",
            "Giao tiếp bằng cách gửi và nhận thông điệp",
            "Giao tiếp trực tiếp với kernel",
            "Giao tiếp bằng interrupt"
          ],
          "correctAnswer": "Giao tiếp bằng cách gửi và nhận thông điệp",
          "reason": "Trao đổi thông điệp cho phép các tiến trình giao tiếp thông qua việc gửi và nhận các thông điệp.",
          "relatedTopics": [
            "Tiến trình",
            "Giao tiếp giữa các tiến trình",
            "Trao đổi thông điệp"
          ]
        },
        {
          "id": 56,
          "question": "Hàng đợi thông điệp (Message Queue) được dùng để làm gì?",
          "options": [
            "Lập lịch CPU",
            "Quản lý bộ nhớ",
            "Lưu trữ thông điệp giữa các tiến trình",
            "Quản lý thiết bị I/O"
          ],
          "correctAnswer": "Lưu trữ thông điệp giữa các tiến trình",
          "reason": "Hàng đợi thông điệp là một cấu trúc dữ liệu để lưu trữ thông điệp mà các tiến trình gửi và nhận.",
          "relatedTopics": [
            "Tiến trình",
            "Giao tiếp giữa các tiến trình",
            "Trao đổi thông điệp"
          ]
        },
        {
          "id": 57,
          "question": "Ống dẫn (Pipes) là gì?",
          "options": [
            "Một loại thiết bị I/O",
            "Một cơ chế truyền dữ liệu giữa các tiến trình liên quan",
            "Một bộ nhớ cache",
            "Một cơ chế điều khiển CPU"
          ],
          "correctAnswer": "Một cơ chế truyền dữ liệu giữa các tiến trình liên quan",
          "reason": "Ống dẫn là một cơ chế IPC cho phép các tiến trình liên quan (ví dụ, tiến trình cha và con) giao tiếp với nhau.",
          "relatedTopics": [
            "Tiến trình",
            "Giao tiếp giữa các tiến trình",
            "Ống dẫn"
          ]
        },
        {
          "id": 58,
          "question": "Tiêu chí nào quan trọng để đánh giá hiệu quả của thuật toán lập lịch CPU?",
          "options": [
            "Kích thước bộ nhớ",
            "Thời gian CPU nhàn rỗi",
            "Thời gian chờ đợi trung bình",
            "Số lượng chương trình"
          ],
          "correctAnswer": "Thời gian chờ đợi trung bình",
          "reason": "Thời gian chờ đợi trung bình của các tiến trình là một trong những tiêu chí quan trọng để đánh giá hiệu quả của thuật toán lập lịch.",
          "relatedTopics": ["Lập lịch CPU", "Tiêu chí đánh giá"]
        },
        {
          "id": 59,
          "question": "Thời gian quay vòng (Turnaround Time) được định nghĩa là gì?",
          "options": [
            "Thời gian tiến trình chạy CPU",
            "Thời gian tiến trình chờ trong hàng đợi",
            "Thời gian từ khi nạp đến khi hoàn thành",
            "Thời gian CPU nhàn rỗi"
          ],
          "correctAnswer": "Thời gian từ khi nạp đến khi hoàn thành",
          "reason": "Turnaround Time là tổng thời gian một tiến trình ở trong hệ thống, từ khi được nạp vào đến khi hoàn thành.",
          "relatedTopics": ["Lập lịch CPU", "Tiêu chí đánh giá"]
        },
        {
          "id": 61,
          "question": "Thời gian đáp ứng (Response Time) là gì?",
          "options": [
            "Thời gian hoàn thành của tiến trình",
            "Thời gian chờ đợi trong hàng đợi",
            "Thời gian từ khi gửi yêu cầu đến khi có phản hồi đầu tiên",
            "Thời gian CPU thực hiện một tác vụ"
          ],
          "correctAnswer": "Thời gian từ khi gửi yêu cầu đến khi có phản hồi đầu tiên",
          "reason": "Response Time là thời gian từ khi người dùng gửi yêu cầu đến khi hệ thống bắt đầu phản hồi (không cần hoàn thành).",
          "relatedTopics": ["Lập lịch CPU", "Tiêu chí đánh giá"]
        },
        {
          "id": 62,
          "question": "Thuật toán lập lịch nào chia thời gian CPU thành các quantum và phân phối cho các tiến trình?",
          "options": [
            "Shortest-Job-First",
            "Priority Scheduling",
            "First-Come, First-Served",
            "Round Robin"
          ],
          "correctAnswer": "Round Robin",
          "reason": "Round Robin sử dụng quantum để chia sẻ thời gian CPU giữa các tiến trình.",
          "relatedTopics": ["Lập lịch CPU", "Round Robin"]
        },
        {
          "id": 63,
          "question": "Thuật toán Shortest-Job-First (SJF) có ưu điểm gì?",
          "options": [
            "Đơn giản dễ cài đặt",
            "Không có starvation",
            "Thời gian chờ trung bình nhỏ nhất",
            "Thời gian đáp ứng nhanh nhất"
          ],
          "correctAnswer": "Thời gian chờ trung bình nhỏ nhất",
          "reason": "SJF, khi có thời gian thực thi chính xác, cung cấp thời gian chờ trung bình nhỏ nhất trong số các thuật toán lập lịch.",
          "relatedTopics": ["Lập lịch CPU", "Shortest-Job-First"]
        },
        {
          "id": 64,
          "question": "Thuật toán lập lịch nào có thể ưu tiên các tiến trình dựa trên độ ưu tiên?",
          "options": [
            "First-Come, First-Served",
            "Shortest-Job-First",
            "Round Robin",
            "Priority Scheduling"
          ],
          "correctAnswer": "Priority Scheduling",
          "reason": "Priority Scheduling cho phép gán độ ưu tiên cho tiến trình và phục vụ tiến trình có độ ưu tiên cao hơn trước.",
          "relatedTopics": ["Lập lịch CPU", "Priority Scheduling"]
        },
        {
          "id": 65,
          "question": "Nguyên tắc 'loại trừ tương hỗ' trong đồng bộ hóa tiến trình là gì?",
          "options": [
            "Cho phép nhiều tiến trình truy cập miền găng cùng lúc",
            "Chỉ cho phép một tiến trình truy cập miền găng tại một thời điểm",
            "Ngăn chặn mọi tiến trình truy cập miền găng",
            "Cho phép các tiến trình thay đổi thứ tự truy cập"
          ],
          "correctAnswer": "Chỉ cho phép một tiến trình truy cập miền găng tại một thời điểm",
          "reason": "Loại trừ tương hỗ đảm bảo rằng chỉ có một tiến trình được thực thi trong miền găng tại một thời điểm.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Loại trừ tương hỗ"]
        },
        {
          "id": 66,
          "question": "Thao tác wait() trong semaphore có ý nghĩa gì?",
          "options": [
            "Tăng giá trị semaphore",
            "Giảm giá trị semaphore",
            "Kiểm tra giá trị semaphore",
            "Hủy semaphore"
          ],
          "correctAnswer": "Giảm giá trị semaphore",
          "reason": "Thao tác wait() giảm giá trị semaphore và có thể khiến tiến trình bị block nếu giá trị semaphore bằng 0.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Semaphore"]
        },
        {
          "id": 67,
          "question": "Thao tác signal() trong semaphore có ý nghĩa gì?",
          "options": [
            "Tăng giá trị semaphore",
            "Giảm giá trị semaphore",
            "Kiểm tra giá trị semaphore",
            "Hủy semaphore"
          ],
          "correctAnswer": "Tăng giá trị semaphore",
          "reason": "Thao tác signal() tăng giá trị semaphore và có thể đánh thức một tiến trình đang block trên semaphore đó.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Semaphore"]
        },
        {
          "id": 68,
          "question": "Mutex là gì?",
          "options": [
            "Một loại biến điều kiện",
            "Một dạng semaphore nhị phân",
            "Một cơ chế lập lịch CPU",
            "Một cơ chế quản lý bộ nhớ"
          ],
          "correctAnswer": "Một dạng semaphore nhị phân",
          "reason": "Mutex là một dạng semaphore nhị phân, được sử dụng để đảm bảo loại trừ tương hỗ.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Mutex"]
        },
        {
          "id": 69,
          "question": "Monitor là gì?",
          "options": [
            "Một loại semaphore",
            "Một ngôn ngữ lập trình",
            "Một cấu trúc ngôn ngữ lập trình cung cấp cơ chế đồng bộ hóa",
            "Một cơ chế cấp phát bộ nhớ"
          ],
          "correctAnswer": "Một cấu trúc ngôn ngữ lập trình cung cấp cơ chế đồng bộ hóa",
          "reason": "Monitor là một cấu trúc ngôn ngữ lập trình cung cấp cơ chế đồng bộ hóa cao cấp hơn so với semaphore.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Monitor"]
        },
        {
          "id": 70,
          "question": "Biến điều kiện (Condition Variable) được sử dụng khi nào?",
          "options": [
            "Khi các tiến trình muốn chia sẻ bộ nhớ",
            "Khi các tiến trình muốn thay đổi quyền truy cập tài nguyên",
            "Khi các tiến trình cần chờ đợi một điều kiện nào đó",
            "Khi các tiến trình muốn kết thúc"
          ],
          "correctAnswer": "Khi các tiến trình cần chờ đợi một điều kiện nào đó",
          "reason": "Biến điều kiện được sử dụng bên trong monitor để các tiến trình có thể chờ đợi một điều kiện cụ thể nào đó.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Biến điều kiện"]
        },
        {
          "id": 71,
          "question": "Thao tác wait() trên biến điều kiện có ý nghĩa gì?",
          "options": [
            "Đánh thức một tiến trình đang chờ trên biến điều kiện",
            "Block tiến trình và đưa vào hàng đợi của biến điều kiện",
            "Tăng giá trị của biến điều kiện",
            "Giảm giá trị của biến điều kiện"
          ],
          "correctAnswer": "Block tiến trình và đưa vào hàng đợi của biến điều kiện",
          "reason": "Thao tác wait() block tiến trình hiện tại và đưa nó vào hàng đợi của biến điều kiện, chờ đến khi được đánh thức.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Biến điều kiện"]
        },
        {
          "id": 72,
          "question": "Thao tác signal() trên biến điều kiện có ý nghĩa gì?",
          "options": [
            "Block một tiến trình",
            "Đánh thức một tiến trình đang chờ trên biến điều kiện",
            "Tăng giá trị của biến điều kiện",
            "Giảm giá trị của biến điều kiện"
          ],
          "correctAnswer": "Đánh thức một tiến trình đang chờ trên biến điều kiện",
          "reason": "Thao tác signal() đánh thức một trong các tiến trình đang block trên biến điều kiện đó.",
          "relatedTopics": ["Đồng bộ hóa tiến trình", "Biến điều kiện"]
        },
        {
          "id": 73,
          "question": "Điều kiện 'giữ và chờ' trong bế tắc có nghĩa là gì?",
          "options": [
            "Tiến trình đang giữ ít nhất một tài nguyên và đang chờ thêm tài nguyên",
            "Tiến trình đang không giữ tài nguyên nào",
            "Tiến trình đang chờ I/O",
            "Tiến trình đã hoàn thành"
          ],
          "correctAnswer": "Tiến trình đang giữ ít nhất một tài nguyên và đang chờ thêm tài nguyên",
          "reason": "Điều kiện 'giữ và chờ' xảy ra khi tiến trình đang giữ ít nhất một tài nguyên và đồng thời chờ đợi để có thêm tài nguyên đang được giữ bởi các tiến trình khác.",
          "relatedTopics": ["Bế tắc", "Điều kiện cần cho bế tắc"]
        },
        {
          "id": 74,
          "question": "Điều kiện 'không trưng dụng' trong bế tắc có nghĩa là gì?",
          "options": [
            "Tài nguyên có thể được thu hồi từ tiến trình",
            "Tài nguyên không thể bị thu hồi từ tiến trình",
            "Tiến trình tự nguyện nhường tài nguyên",
            "Tiến trình không cần tài nguyên"
          ],
          "correctAnswer": "Tài nguyên không thể bị thu hồi từ tiến trình",
          "reason": "Điều kiện 'không trưng dụng' nghĩa là hệ điều hành không thể cưỡng chế thu hồi tài nguyên từ một tiến trình đang giữ nó.",
          "relatedTopics": ["Bế tắc", "Điều kiện cần cho bế tắc"]
        },
        {
          "id": 75,
          "question": "Điều kiện 'chu trình chờ' trong bế tắc có nghĩa là gì?",
          "options": [
            "Các tiến trình chờ nhau theo một chuỗi",
            "Các tiến trình chờ ngẫu nhiên",
            "Các tiến trình không chờ nhau",
            "Các tiến trình chờ I/O"
          ],
          "correctAnswer": "Các tiến trình chờ nhau theo một chuỗi",
          "reason": "Điều kiện 'chu trình chờ' nghĩa là tồn tại một chu trình các tiến trình, trong đó mỗi tiến trình đang chờ một tài nguyên mà đang được giữ bởi tiến trình kế tiếp trong chu trình.",
          "relatedTopics": ["Bế tắc", "Điều kiện cần cho bế tắc"]
        },
        {
          "id": 76,
          "question": "Phương pháp 'phòng ngừa bế tắc' hoạt động như thế nào?",
          "options": [
            "Cho phép bế tắc xảy ra rồi khắc phục",
            "Kiểm tra hệ thống để tránh bế tắc",
            "Ngăn chặn ít nhất một trong các điều kiện cần cho bế tắc",
            "Bỏ qua vấn đề bế tắc"
          ],
          "correctAnswer": "Ngăn chặn ít nhất một trong các điều kiện cần cho bế tắc",
          "reason": "Phòng ngừa bế tắc là việc loại bỏ ít nhất một trong bốn điều kiện cần để bế tắc xảy ra.",
          "relatedTopics": ["Bế tắc", "Phòng ngừa bế tắc"]
        },
        {
          "id": 77,
          "question": "Phương pháp 'tránh né bế tắc' hoạt động như thế nào?",
          "options": [
            "Cho phép bế tắc xảy ra rồi khắc phục",
            "Kiểm tra trạng thái để đảm bảo không có bế tắc",
            "Ngăn chặn các điều kiện cần cho bế tắc",
            "Bỏ qua vấn đề bế tắc"
          ],
          "correctAnswer": "Kiểm tra trạng thái để đảm bảo không có bế tắc",
          "reason": "Tránh né bế tắc là việc kiểm tra trạng thái cấp phát tài nguyên trước khi cấp để đảm bảo hệ thống luôn ở trạng thái an toàn.",
          "relatedTopics": ["Bế tắc", "Tránh né bế tắc"]
        },
        {
          "id": 78,
          "question": "Phương pháp 'phát hiện và phục hồi' bế tắc hoạt động như thế nào?",
          "options": [
            "Cho phép bế tắc xảy ra, sau đó phát hiện và khắc phục",
            "Ngăn chặn các điều kiện cần cho bế tắc",
            "Kiểm tra trạng thái để tránh bế tắc",
            "Bỏ qua vấn đề bế tắc"
          ],
          "correctAnswer": "Cho phép bế tắc xảy ra, sau đó phát hiện và khắc phục",
          "reason": "Phát hiện và phục hồi là việc phát hiện bế tắc khi nó xảy ra, sau đó tìm cách phục hồi hệ thống.",
          "relatedTopics": ["Bế tắc", "Phát hiện và phục hồi"]
        },
        {
          "id": 79,
          "question": "Địa chỉ logic (Logical Address) là gì?",
          "options": [
            "Địa chỉ được nhìn thấy bởi bộ nhớ",
            "Địa chỉ do CPU tạo ra",
            "Địa chỉ của thiết bị I/O",
            "Địa chỉ của ROM"
          ],
          "correctAnswer": "Địa chỉ do CPU tạo ra",
          "reason": "Địa chỉ logic là địa chỉ được tạo ra bởi CPU và được sử dụng để tham chiếu đến các vị trí bộ nhớ.",
          "relatedTopics": ["Quản lý bộ nhớ", "Địa chỉ logic"]
        },
        {
          "id": 80,
          "question": "Địa chỉ vật lý (Physical Address) là gì?",
          "options": [
            "Địa chỉ do CPU tạo ra",
            "Địa chỉ được nhìn thấy bởi bộ nhớ",
            "Địa chỉ của thiết bị I/O",
            "Địa chỉ của ROM"
          ],
          "correctAnswer": "Địa chỉ được nhìn thấy bởi bộ nhớ",
          "reason": "Địa chỉ vật lý là địa chỉ thực tế được sử dụng để truy cập vào bộ nhớ.",
          "relatedTopics": ["Quản lý bộ nhớ", "Địa chỉ vật lý"]
        },
        {
          "id": 81,
          "question": "Phương pháp phân vùng động (Dynamic Partitioning) trong quản lý bộ nhớ hoạt động như thế nào?",
          "options": [
            "Chia bộ nhớ thành các phân vùng cố định",
            "Chia bộ nhớ thành các phân vùng có kích thước thay đổi",
            "Không phân vùng bộ nhớ",
            "Chia bộ nhớ theo trang"
          ],
          "correctAnswer": "Chia bộ nhớ thành các phân vùng có kích thước thay đổi",
          "reason": "Phân vùng động cho phép tạo các phân vùng có kích thước khác nhau tùy theo kích thước của tiến trình.",
          "relatedTopics": ["Quản lý bộ nhớ", "Phân vùng động"]
        },
        {
          "id": 82,
          "question": "Thuật toán 'First-fit' trong phân vùng động hoạt động như thế nào?",
          "options": [
            "Cấp phát phân vùng trống lớn nhất",
            "Cấp phát phân vùng trống nhỏ nhất",
            "Cấp phát phân vùng trống đầu tiên đủ lớn",
            "Cấp phát ngẫu nhiên"
          ],
          "correctAnswer": "Cấp phát phân vùng trống đầu tiên đủ lớn",
          "reason": "First-fit cấp phát phân vùng trống đầu tiên mà có đủ kích thước để chứa tiến trình.",
          "relatedTopics": ["Quản lý bộ nhớ", "Phân vùng động", "First-fit"]
        },
        {
          "id": 83,
          "question": "Thuật toán 'Best-fit' trong phân vùng động hoạt động như thế nào?",
          "options": [
            "Cấp phát phân vùng trống lớn nhất",
            "Cấp phát phân vùng trống nhỏ nhất đủ lớn",
            "Cấp phát phân vùng trống đầu tiên đủ lớn",
            "Cấp phát ngẫu nhiên"
          ],
          "correctAnswer": "Cấp phát phân vùng trống nhỏ nhất đủ lớn",
          "reason": "Best-fit tìm phân vùng trống nhỏ nhất nhưng vẫn đủ để chứa tiến trình.",
          "relatedTopics": ["Quản lý bộ nhớ", "Phân vùng động", "Best-fit"]
        },
        {
          "id": 84,
          "question": "Phân mảnh ngoại vi (External Fragmentation) là gì?",
          "options": [
            "Bộ nhớ không đủ để chứa tiến trình",
            "Bộ nhớ bị chia nhỏ thành các phân vùng nhỏ, không thể dùng",
            "Bộ nhớ bị lỗi",
            "Bộ nhớ không được phân vùng"
          ],
          "correctAnswer": "Bộ nhớ bị chia nhỏ thành các phân vùng nhỏ, không thể dùng",
          "reason": "Phân mảnh ngoại vi xảy ra khi bộ nhớ có đủ dung lượng trống nhưng không liên tục để chứa một tiến trình.",
          "relatedTopics": ["Quản lý bộ nhớ", "Phân mảnh bộ nhớ"]
        },
        {
          "id": 85,
          "question": "Phân mảnh nội bộ (Internal Fragmentation) là gì?",
          "options": [
            "Bộ nhớ bị chia nhỏ thành các phân vùng nhỏ",
            "Không gian bộ nhớ không được sử dụng trong một phân vùng",
            "Bộ nhớ bị lỗi",
            "Bộ nhớ không đủ để chứa tiến trình"
          ],
          "correctAnswer": "Không gian bộ nhớ không được sử dụng trong một phân vùng",
          "reason": "Phân mảnh nội bộ xảy ra khi một phân vùng được cấp phát cho tiến trình lớn hơn kích thước của tiến trình, gây lãng phí bộ nhớ trong phân vùng đó.",
          "relatedTopics": ["Quản lý bộ nhớ", "Phân mảnh bộ nhớ"]
        },
        {
          "id": 86,
          "question": "Bảng trang (Page Table) được sử dụng để làm gì?",
          "options": [
            "Lưu trữ các tiến trình",
            "Ánh xạ trang logic sang khung vật lý",
            "Lưu trữ dữ liệu",
            "Lập lịch CPU"
          ],
          "correctAnswer": "Ánh xạ trang logic sang khung vật lý",
          "reason": "Bảng trang là một cấu trúc dữ liệu để ánh xạ địa chỉ trang logic sang địa chỉ khung vật lý trong bộ nhớ.",
          "relatedTopics": ["Quản lý bộ nhớ", "Bảng trang"]
        },
        {
          "id": 87,
          "question": "Trong phân trang theo yêu cầu (Demand Paging), các trang được nạp vào bộ nhớ khi nào?",
          "options": [
            "Khi khởi động hệ thống",
            "Khi tiến trình được tạo",
            "Khi có tham chiếu đến trang đó",
            "Khi bộ nhớ còn trống"
          ],
          "correctAnswer": "Khi có tham chiếu đến trang đó",
          "reason": "Trong phân trang theo yêu cầu, các trang chỉ được nạp vào bộ nhớ khi CPU tham chiếu đến chúng.",
          "relatedTopics": ["Quản lý bộ nhớ", "Phân trang theo yêu cầu"]
        },
        {
          "id": 88,
          "question": "Thuật toán thay thế trang LRU (Least Recently Used) hoạt động như thế nào?",
          "options": [
            "Thay thế trang được nạp vào bộ nhớ lâu nhất",
            "Thay thế trang ít được sử dụng gần đây nhất",
            "Thay thế trang được sử dụng thường xuyên nhất",
            "Thay thế trang ngẫu nhiên"
          ],
          "correctAnswer": "Thay thế trang ít được sử dụng gần đây nhất",
          "reason": "LRU thay thế trang nào ít được sử dụng nhất trong khoảng thời gian gần đây nhất.",
          "relatedTopics": [
            "Quản lý bộ nhớ",
            "Thuật toán thay thế trang",
            "LRU"
          ]
        },
        {
          "id": 89,
          "question": "Thuật toán thay thế trang OPT (Optimal) có đặc điểm gì?",
          "options": [
            "Dễ cài đặt",
            "Hiệu suất thấp",
            "Thay thế trang sẽ không được sử dụng trong thời gian dài nhất",
            "Thay thế trang được sử dụng nhiều nhất"
          ],
          "correctAnswer": "Thay thế trang sẽ không được sử dụng trong thời gian dài nhất",
          "reason": "OPT thay thế trang nào sẽ không được sử dụng trong tương lai lâu nhất. Đây là thuật toán tối ưu nhưng không thể thực hiện được trong thực tế.",
          "relatedTopics": [
            "Quản lý bộ nhớ",
            "Thuật toán thay thế trang",
            "OPT"
          ]
        },
        {
          "id": 90,
          "question": "Cấp phát liên tục (Contiguous Allocation) trong hệ thống tập tin là gì?",
          "options": [
            "Mỗi tập tin chiếm các khối đĩa không liên tiếp",
            "Mỗi tập tin chiếm các khối đĩa liên tiếp",
            "Các tập tin chia sẻ khối đĩa",
            "Cấp phát ngẫu nhiên"
          ],
          "correctAnswer": "Mỗi tập tin chiếm các khối đĩa liên tiếp",
          "reason": "Cấp phát liên tục là việc cấp phát cho mỗi tập tin một tập các khối đĩa liên tiếp.",
          "relatedTopics": ["Hệ thống tập tin", "Cấp phát không gian đĩa"]
        },
        {
          "id": 91,
          "question": "Cấp phát liên kết (Linked Allocation) trong hệ thống tập tin là gì?",
          "options": [
            "Mỗi tập tin chiếm các khối đĩa không liên tiếp được liên kết với nhau",
            "Mỗi tập tin chiếm các khối đĩa liên tiếp",
            "Các tập tin chia sẻ khối đĩa",
            "Cấp phát ngẫu nhiên"
          ],
          "correctAnswer": "Mỗi tập tin chiếm các khối đĩa không liên tiếp được liên kết với nhau",
          "reason": "Cấp phát liên kết dùng danh sách liên kết để quản lý các khối đĩa của tập tin.",
          "relatedTopics": ["Hệ thống tập tin", "Cấp phát không gian đĩa"]
        },
        {
          "id": 92,
          "question": "Cấp phát theo chỉ mục (Indexed Allocation) trong hệ thống tập tin là gì?",
          "options": [
            "Mỗi tập tin có một khối chỉ mục chứa các con trỏ đến các khối đĩa",
            "Mỗi tập tin chiếm các khối đĩa liên tiếp",
            "Các tập tin chia sẻ khối đĩa",
            "Cấp phát ngẫu nhiên"
          ],
          "correctAnswer": "Mỗi tập tin có một khối chỉ mục chứa các con trỏ đến các khối đĩa",
          "reason": "Cấp phát theo chỉ mục dùng khối chỉ mục để quản lý các khối đĩa của tập tin.",
          "relatedTopics": ["Hệ thống tập tin", "Cấp phát không gian đĩa"]
        },
        {
          "id": 93,
          "question": "Một thư mục (Directory) trong hệ thống tập tin có chức năng gì?",
          "options": [
            "Lưu trữ dữ liệu",
            "Chứa thông tin về các tập tin và thư mục con",
            "Lưu trữ các chương trình",
            "Lưu trữ thông tin hệ thống"
          ],
          "correctAnswer": "Chứa thông tin về các tập tin và thư mục con",
          "reason": "Thư mục được dùng để tổ chức và quản lý các tập tin và thư mục con trong hệ thống tập tin.",
          "relatedTopics": ["Hệ thống tập tin", "Thư mục"]
        },
        {
          "id": 94,
          "question": "Tường lửa (Firewall) hoạt động ở lớp mạng nào?",
          "options": [
            "Lớp ứng dụng",
            "Lớp vận chuyển",
            "Lớp mạng",
            "Lớp liên kết dữ liệu"
          ],
          "correctAnswer": "Lớp mạng",
          "reason": "Tường lửa thường hoạt động ở lớp mạng để kiểm soát lưu lượng truy cập dựa trên địa chỉ IP và cổng.",
          "relatedTopics": ["Bảo mật và bảo vệ", "Tường lửa"]
        },
        {
          "id": 95,
          "question": "Sinh trắc học (Biometrics) là gì?",
          "options": [
            "Một loại mật khẩu",
            "Một thiết bị token",
            "Một phương pháp xác thực dùng đặc điểm sinh học",
            "Một phương pháp mã hóa dữ liệu"
          ],
          "correctAnswer": "Một phương pháp xác thực dùng đặc điểm sinh học",
          "reason": "Sinh trắc học dùng các đặc điểm sinh học của con người (vân tay, khuôn mặt,...) để xác thực.",
          "relatedTopics": ["Bảo mật và bảo vệ", "Sinh trắc học"]
        },
        {
          "id": 96,
          "question": "Denial-of-Service (DoS) attack là gì?",
          "options": [
            "Tấn công để đánh cắp dữ liệu",
            "Tấn công để làm cho hệ thống không thể sử dụng",
            "Tấn công để thay đổi dữ liệu",
            "Tấn công để phát tán virus"
          ],
          "correctAnswer": "Tấn công để làm cho hệ thống không thể sử dụng",
          "reason": "Tấn công DoS là cuộc tấn công nhằm mục đích làm cho hệ thống hoặc dịch vụ không thể truy cập được.",
          "relatedTopics": ["Bảo mật và bảo vệ", "DoS"]
        },
        {
          "id": 97,
          "question": "Distributed Denial-of-Service (DDoS) attack là gì?",
          "options": [
            "Tấn công DoS từ một máy",
            "Tấn công DoS từ nhiều máy",
            "Tấn công để đánh cắp dữ liệu",
            "Tấn công để thay đổi dữ liệu"
          ],
          "correctAnswer": "Tấn công DoS từ nhiều máy",
          "reason": "Tấn công DDoS là cuộc tấn công DoS được thực hiện từ nhiều máy tính khác nhau.",
          "relatedTopics": ["Bảo mật và bảo vệ", "DDoS"]
        },
        {
          "id": 98,
          "question": "Mã hóa bất đối xứng (Asymmetric Encryption) có đặc điểm gì?",
          "options": [
            "Sử dụng cùng một khóa để mã hóa và giải mã",
            "Sử dụng hai khóa khác nhau",
            "Không cần khóa",
            "Sử dụng một khóa duy nhất"
          ],
          "correctAnswer": "Sử dụng hai khóa khác nhau",
          "reason": "Mã hóa bất đối xứng dùng cặp khóa: khóa công khai để mã hóa và khóa riêng tư để giải mã.",
          "relatedTopics": ["Bảo mật và bảo vệ", "Mã hóa bất đối xứng"]
        },
        {
          "id": 99,
          "question": "Trình điều khiển thiết bị (Device Driver) làm gì?",
          "options": [
            "Điều khiển CPU",
            "Cung cấp giao diện giữa hệ điều hành và thiết bị phần cứng",
            "Quản lý bộ nhớ",
            "Tăng tốc độ mạng"
          ],
          "correctAnswer": "Cung cấp giao diện giữa hệ điều hành và thiết bị phần cứng",
          "reason": "Device driver là phần mềm cho phép hệ điều hành tương tác với phần cứng cụ thể.",
          "relatedTopics": ["Hệ thống I/O", "Device Driver"]
        },
        {
          "id": 100,
          "question": "Mục đích của việc sử dụng API (Application Programming Interface) trong hệ điều hành là gì?",
          "options": [
            "Điều khiển CPU",
            "Cung cấp giao diện cho các ứng dụng tương tác với HĐH",
            "Quản lý bộ nhớ",
            "Tăng tốc độ mạng"
          ],
          "correctAnswer": "Cung cấp giao diện cho các ứng dụng tương tác với HĐH",
          "reason": "API cho phép các ứng dụng gọi các chức năng của hệ điều hành để thực hiện các tác vụ.",
          "relatedTopics": ["API"]
        }
      ]
    },
    {
      "id": 5,
      "title": "Computer Science Quiz",
      "timeLimit": 2700,
      "questions": [
        {
          "id": 1,
          "question": "Trong mạng máy tính, giao thức nào đảm bảo truyền dữ liệu tin cậy?",
          "options": ["TCP", "UDP", "IP", "HTTP"],
          "correctAnswer": "TCP",
          "reason": "TCP (Transmission Control Protocol) cung cấp cơ chế kiểm soát lỗi, sắp xếp thứ tự gói tin và truyền lại, đảm bảo dữ liệu được truyền đi một cách tin cậy. Cần học về các giao thức tầng vận chuyển (Transport Layer)."
        },
        {
          "id": 2,
          "question": "Cấu trúc dữ liệu nào sau đây hoạt động theo nguyên tắc LIFO (Last In, First Out)?",
          "options": ["Queue", "Stack", "Linked List", "Tree"],
          "correctAnswer": "Stack",
          "reason": "Stack là cấu trúc dữ liệu mà phần tử được thêm vào cuối cùng sẽ được lấy ra đầu tiên. Cần học về các cấu trúc dữ liệu cơ bản và nguyên tắc hoạt động."
        },
        {
          "id": 3,
          "question": "Độ phức tạp thời gian của thuật toán tìm kiếm nhị phân (Binary Search) trên mảng đã sắp xếp là gì?",
          "options": ["O(n)", "O(log n)", "O(n^2)", "O(n log n)"],
          "correctAnswer": "O(log n)",
          "reason": "Tìm kiếm nhị phân chia đôi không gian tìm kiếm sau mỗi bước, dẫn đến độ phức tạp logarit. Cần học về phân tích độ phức tạp thuật toán (Big O notation)."
        },
        {
          "id": 4,
          "question": "Bộ nhớ nào sau đây có tốc độ truy cập nhanh nhất?",
          "options": ["RAM", "Cache", "SSD", "HDD"],
          "correctAnswer": "Cache",
          "reason": "Cache là bộ nhớ nhỏ, được đặt gần CPU, lưu trữ dữ liệu thường xuyên được sử dụng để giảm thời gian truy cập. Cần học về phân cấp bộ nhớ (Memory Hierarchy) trong kiến trúc máy tính."
        },
        {
          "id": 5,
          "question": "Tiến trình (Process) đang ở trạng thái nào khi nó đang chờ đợi một sự kiện (ví dụ: I/O hoàn tất)?",
          "options": ["Running", "Ready", "Blocked/Waiting", "Terminated"],
          "correctAnswer": "Blocked/Waiting",
          "reason": "Khi một tiến trình chờ đợi I/O hoặc sự kiện khác, nó sẽ chuyển sang trạng thái Blocked/Waiting. Cần học về vòng đời tiến trình (Process Life Cycle) trong hệ điều hành."
        },
        {
          "id": 6,
          "question": "Trong lập trình hướng đối tượng, tính chất nào cho phép che giấu thông tin nội bộ của đối tượng?",
          "options": [
            "Kế thừa (Inheritance)",
            "Đa hình (Polymorphism)",
            "Đóng gói (Encapsulation)",
            "Trừu tượng (Abstraction)"
          ],
          "correctAnswer": "Đóng gói (Encapsulation)",
          "reason": "Encapsulation che giấu dữ liệu và phương thức nội bộ, chỉ cho phép truy cập thông qua các phương thức public. Cần học về 4 tính chất cơ bản của lập trình hướng đối tượng."
        },
        {
          "id": 7,
          "question": "Ngôn ngữ lập trình nào sau đây là ngôn ngữ thông dịch (interpreted)?",
          "options": ["C", "C++", "Java", "Python"],
          "correctAnswer": "Python",
          "reason": "Python là ngôn ngữ thông dịch, mã nguồn được thực thi từng dòng bởi trình thông dịch. Cần học về sự khác biệt giữa ngôn ngữ biên dịch và thông dịch."
        },
        {
          "id": 8,
          "question": "Trong cơ sở dữ liệu quan hệ, khóa ngoại (Foreign Key) dùng để làm gì?",
          "options": [
            "Định danh duy nhất một bản ghi",
            "Tham chiếu đến khóa chính của bảng khác",
            "Sắp xếp dữ liệu",
            "Đánh chỉ mục"
          ],
          "correctAnswer": "Tham chiếu đến khóa chính của bảng khác",
          "reason": "Khóa ngoại tạo mối quan hệ giữa các bảng, đảm bảo tính toàn vẹn tham chiếu. Cần học về các loại khóa trong cơ sở dữ liệu quan hệ."
        },
        {
          "id": 9,
          "question": "Mô hình phát triển phần mềm nào sau đây phù hợp với các dự án có yêu cầu thay đổi thường xuyên?",
          "options": ["Waterfall", "Agile", "Spiral", "V-Model"],
          "correctAnswer": "Agile",
          "reason": "Agile nhấn mạnh vào việc phát triển lặp và thích ứng nhanh với thay đổi. Cần học về các mô hình phát triển phần mềm (Software Development Life Cycle - SDLC)."
        },
        {
          "id": 10,
          "question": "Ai là người chịu trách nhiệm chính trong việc lập kế hoạch và điều phối các hoạt động của dự án?",
          "options": [
            "Lập trình viên",
            "Kiểm thử viên",
            "Quản lý dự án",
            "Nhà phân tích nghiệp vụ"
          ],
          "correctAnswer": "Quản lý dự án",
          "reason": "Quản lý dự án chịu trách nhiệm lập kế hoạch, điều phối, giám sát và kiểm soát dự án. Cần học về vai trò và trách nhiệm trong quản lý dự án."
        },
        {
          "id": 11,
          "question": "Câu lệnh SQL nào được sử dụng để thêm dữ liệu vào bảng?",
          "options": ["SELECT", "INSERT", "UPDATE", "DELETE"],
          "correctAnswer": "INSERT",
          "reason": "Câu lệnh INSERT INTO được dùng để thêm bản ghi mới vào bảng. Cần học về các câu lệnh DML (Data Manipulation Language) trong SQL."
        },
        {
          "id": 12,
          "question": "Biểu thức chính quy nào sau đây khớp với tất cả các chuỗi bắt đầu bằng 'a' và kết thúc bằng 'b'?",
          "options": ["^a.*b$", "^a+b$", "a*b$", "ab+"],
          "correctAnswer": "^a.*b$",
          "reason": "^ đại diện cho bắt đầu chuỗi, . đại diện cho bất kì kí tự nào, * đại diện cho không có hoặc nhiều kí tự, $ đại diện cho kết thúc chuỗi . Cần học về cú pháp và các ký tự đặc biệt trong Regular Expression."
        },
        {
          "id": 13,
          "question": "Đoạn mã Java sau đây bị lỗi gì? \n```java\npublic class Main {\n    public static void main(String[] args) {\n        int x = 10\n        System.out.println(x);\n    }\n}\n```",
          "options": [
            "Thiếu dấu chấm phẩy",
            "Sai kiểu dữ liệu",
            "Sai tên biến",
            "Không có lỗi"
          ],
          "correctAnswer": "Thiếu dấu chấm phẩy",
          "reason": "Thiếu dấu chấm phẩy sau khai báo `int x = 10`. Cần học về cú pháp cơ bản của Java, lỗi syntax."
        },
        {
          "id": 14,
          "question": "Trong Java, từ khóa `final` dùng để làm gì?",
          "options": [
            "Khai báo hằng số",
            "Ngăn lớp kế thừa",
            "Ngăn phương thức bị ghi đè",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": "Tất cả các đáp án trên",
          "reason": "`final` có thể dùng cho biến (hằng số), lớp (không thể kế thừa), và phương thức (không thể ghi đè). Cần học về các từ khóa và phạm vi truy cập trong Java."
        },
        {
          "id": 15,
          "question": "Câu lệnh SQL nào sau đây dùng để xóa toàn bộ dữ liệu trong bảng `customers` nhưng giữ nguyên cấu trúc bảng?",
          "options": [
            "DELETE FROM customers",
            "DROP TABLE customers",
            "TRUNCATE TABLE customers",
            "ALTER TABLE customers"
          ],
          "correctAnswer": "TRUNCATE TABLE customers",
          "reason": "`TRUNCATE TABLE` xóa toàn bộ dữ liệu nhanh hơn `DELETE` và không ghi log. Cần học về sự khác biệt giữa `DELETE`, `TRUNCATE`, và `DROP`."
        },
        {
          "id": 16,
          "question": "Điều gì xảy ra khi hai luồng (threads) cùng truy cập và thay đổi một biến chia sẻ mà không có cơ chế đồng bộ hóa?",
          "options": [
            "Deadlock",
            "Race condition",
            "Starvation",
            "Segmentation fault"
          ],
          "correctAnswer": "Race condition",
          "reason": "Race condition xảy ra khi kết quả thực thi phụ thuộc vào thứ tự không xác định của các luồng. Cần học về lập trình đa luồng (Multithreading) và đồng bộ hóa (Synchronization)."
        },
        {
          "id": 17,
          "question": "Phương thức khởi tạo (constructor) trong Java có đặc điểm gì?",
          "options": [
            "Có cùng tên với lớp",
            "Không có kiểu trả về",
            "Được gọi khi đối tượng được tạo",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": "Tất cả các đáp án trên",
          "reason": "Constructor có cùng tên với lớp, không có kiểu trả về, và tự động gọi khi tạo đối tượng. Cần học về constructor và vòng đời của đối tượng trong Java."
        },
        {
          "id": 18,
          "question": "Trong SQL, mệnh đề `WHERE` được sử dụng để làm gì?",
          "options": [
            "Sắp xếp kết quả",
            "Lọc kết quả theo điều kiện",
            "Kết hợp các bảng",
            "Nhóm các bản ghi"
          ],
          "correctAnswer": "Lọc kết quả theo điều kiện",
          "reason": "Mệnh đề `WHERE` chỉ định điều kiện để lọc các bản ghi trả về từ câu lệnh `SELECT`. Cần học về các mệnh đề trong câu lệnh `SELECT`."
        },
        {
          "id": 19,
          "question": "Khái niệm \"garbage collection\" trong Java liên quan đến việc gì?",
          "options": [
            "Thu gom rác thải",
            "Tự động giải phóng bộ nhớ không còn được sử dụng",
            "Xóa các đối tượng",
            "Tối ưu hóa mã"
          ],
          "correctAnswer": "Tự động giải phóng bộ nhớ không còn được sử dụng",
          "reason": "Garbage collection tự động thu hồi bộ nhớ cấp phát cho các đối tượng không còn được tham chiếu. Cần học về quản lý bộ nhớ trong Java."
        },
        {
          "id": 20,
          "question": "Trong quản lý dự án, biểu đồ Gantt được sử dụng để làm gì?",
          "options": [
            "Phân tích rủi ro",
            "Theo dõi tiến độ công việc",
            "Xác định yêu cầu",
            "Ước lượng chi phí"
          ],
          "correctAnswer": "Theo dõi tiến độ công việc",
          "reason": "Biểu đồ Gantt biểu diễn các công việc theo thời gian, giúp trực quan hóa tiến độ dự án. Cần học về các công cụ quản lý dự án."
        },
        {
          "id": 21,
          "question": "Trong Java, `ArrayList` và `LinkedList` khác nhau như thế nào?",
          "options": [
            "`ArrayList` lưu trữ dữ liệu liên tục trong bộ nhớ, `LinkedList` thì không",
            "`ArrayList` truy cập phần tử nhanh hơn, `LinkedList` thêm/xóa phần tử nhanh hơn",
            "Cả hai đáp án trên đều đúng",
            "Cả hai đáp án trên đều sai"
          ],
          "correctAnswer": "Cả hai đáp án trên đều đúng",
          "reason": "`ArrayList` dùng mảng động, `LinkedList` dùng danh sách liên kết đôi. Cần học về các cấu trúc dữ liệu collection trong Java."
        },
        {
          "id": 22,
          "question": "Lệnh `git clone` dùng để làm gì?",
          "options": [
            "Tạo một repository mới",
            "Sao chép một repository từ xa về máy local",
            "Đẩy thay đổi lên repository từ xa",
            "Gộp nhánh"
          ],
          "correctAnswer": "Sao chép một repository từ xa về máy local",
          "reason": "`git clone` tạo một bản sao của repository trên máy local. Cần học về các lệnh cơ bản của Git."
        },
        {
          "id": 23,
          "question": "Trong SQL, từ khóa `JOIN` dùng để làm gì?",
          "options": [
            "Kết hợp dữ liệu từ nhiều bảng dựa trên một cột chung",
            "Tạo bảng mới",
            "Thêm dữ liệu vào bảng",
            "Xóa dữ liệu khỏi bảng"
          ],
          "correctAnswer": "Kết hợp dữ liệu từ nhiều bảng dựa trên một cột chung",
          "reason": "`JOIN` cho phép truy vấn dữ liệu từ nhiều bảng liên quan. Cần học về các loại `JOIN` (INNER, LEFT, RIGHT, FULL)."
        },
        {
          "id": 24,
          "question": "Trong lập trình hướng đối tượng, đa kế thừa (multiple inheritance) là gì?",
          "options": [
            "Một lớp kế thừa từ nhiều lớp cha",
            "Một lớp cha có nhiều lớp con",
            "Một phương thức có nhiều cách triển khai",
            "Một đối tượng có nhiều thuộc tính"
          ],
          "correctAnswer": "Một lớp kế thừa từ nhiều lớp cha",
          "reason": "Đa kế thừa cho phép một lớp con kế thừa các đặc tính từ nhiều lớp cha. Cần học về các loại kế thừa và vấn đề diamond problem."
        },
        {
          "id": 25,
          "question": "Trong Java, interface dùng để làm gì?",
          "options": [
            "Định nghĩa một khuôn mẫu cho các lớp",
            "Cung cấp các phương thức trừu tượng",
            "Hỗ trợ đa kế thừa",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": "Tất cả các đáp án trên",
          "reason": "Interface định nghĩa hợp đồng mà các lớp cài đặt (implement) phải tuân theo. Cần học về interface và sự khác biệt với abstract class."
        },
        {
          "id": 26,
          "question": "Trong SQL, `GROUP BY` dùng để làm gì?",
          "options": [
            "Sắp xếp kết quả",
            "Nhóm các hàng có cùng giá trị ở một hoặc nhiều cột",
            "Lọc kết quả",
            "Kết hợp các bảng"
          ],
          "correctAnswer": "Nhóm các hàng có cùng giá trị ở một hoặc nhiều cột",
          "reason": "`GROUP BY` thường đi kèm với các hàm tổng hợp (aggregate functions) như `COUNT`, `SUM`, `AVG`. Cần học về `GROUP BY` và các hàm tổng hợp."
        },
        {
          "id": 27,
          "question": "Biểu thức chính quy `d+` khớp với chuỗi nào sau đây?",
          "options": [
            "Một hoặc nhiều ký tự chữ",
            "Một hoặc nhiều ký tự số",
            "Một ký tự bất kỳ",
            "Một khoảng trắng"
          ],
          "correctAnswer": "Một hoặc nhiều ký tự số",
          "reason": "`d` đại diện cho ký tự số, `+` đại diện cho một hoặc nhiều lần xuất hiện. Cần học về các lớp ký tự (character classes) trong Regular Expression."
        },
        {
          "id": 28,
          "question": "Đoạn mã Java sau sẽ in ra kết quả gì?\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = \"Hello\";\n        String s2 = new String(\"Hello\");\n        System.out.println(s1 == s2);\n    }\n}\n```",
          "options": ["true", "false", "Lỗi biên dịch", "Lỗi thực thi"],
          "correctAnswer": "false",
          "reason": "Toán tử `==` so sánh tham chiếu của hai đối tượng String, `s1` tham chiếu đến chuỗi trong String pool, `s2` là một đối tượng mới trên heap . Cần học về String pool và cách so sánh chuỗi trong Java (`equals()`)."
        },
        {
          "id": 29,
          "question": "Trong cơ sở dữ liệu, ACID là viết tắt của những thuộc tính nào?",
          "options": [
            "Atomicity, Consistency, Isolation, Durability",
            "Accuracy, Completeness, Integrity, Dependability",
            "Availability, Confidentiality, Integrity, Durability",
            "Authentication, Confidentiality, Integrity, Dependability"
          ],
          "correctAnswer": "Atomicity, Consistency, Isolation, Durability",
          "reason": "ACID đảm bảo tính tin cậy của các giao tác cơ sở dữ liệu. Cần học về các thuộc tính của giao tác (transactions) trong DBMS."
        },
        {
          "id": 30,
          "question": "Mục đích chính của kiểm thử phần mềm (software testing) là gì?",
          "options": [
            "Tìm ra lỗi (bugs) trong phần mềm",
            "Đảm bảo phần mềm đáp ứng yêu cầu",
            "Nâng cao chất lượng phần mềm",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": "Tất cả các đáp án trên",
          "reason": "Kiểm thử nhằm phát hiện lỗi, đảm bảo chất lượng và đáp ứng yêu cầu. Cần học về các loại kiểm thử và quy trình kiểm thử phần mềm."
        }
      ]
    },
    {
      "id": 6,
      "title": "Computer Science Quiz 2",
      "timeLimit": 1200,
      "questions": [
        {
          "id": 1,
          "question": "Trong Java, điều gì xảy ra khi một exception được ném ra trong khối `try`, nhưng không có khối `catch` nào phù hợp và cũng không có khối `finally`?",
          "options": [
            "Chương trình tiếp tục thực thi từ câu lệnh ngay sau khối `try-catch`.",
            "Exception đó sẽ bị bỏ qua.",
            "Chương trình sẽ kết thúc và exception đó được xử lý bởi default exception handler.",
            "Một lỗi biên dịch sẽ xảy ra."
          ],
          "correctAnswer": "Chương trình sẽ kết thúc và exception đó được xử lý bởi default exception handler.",
          "reason": "Khi không có khối `catch` phù hợp, exception sẽ được truyền ngược lên call stack cho đến khi được xử lý (hoặc đến default handler). Cần học sâu về xử lý ngoại lệ (exception handling) trong Java, call stack, uncaught exception."
        },
        {
          "id": 2,
          "question": "Đoạn mã Java sau in ra kết quả gì?\n```java\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"A\");\n            badMethod();\n            System.out.println(\"B\");\n        } catch (Exception ex) {\n            System.out.println(\"C\");\n        } finally {\n            System.out.println(\"D\");\n        }\n    }\n    \n    public static void badMethod() throws Exception {\n        throw new Exception();\n    }\n}\n```",
          "options": ["ABCD", "AD", "ACD", "ABD"],
          "correctAnswer": "ACD",
          "reason": "badMethod() ném ra exception, `A` in ra trước, `B` không được in vì exception, `C` in ra vì vào catch, `D` in ra vì finally luôn chạy. Cần hiểu rõ luồng thực thi của `try-catch-finally`."
        },
        {
          "id": 3,
          "question": "Trong Java, `transient` keyword được sử dụng với biến instance để làm gì?",
          "options": [
            "Cho biết biến đó có thể thay đổi bởi nhiều luồng.",
            "Cho biết biến đó không phải là một phần của trạng thái bền vững (persistent state) của đối tượng.",
            "Cho biết biến đó không thể được truy cập từ bên ngoài lớp.",
            "Cho biết biến đó là một hằng số."
          ],
          "correctAnswer": "Cho biết biến đó không phải là một phần của trạng thái bền vững (persistent state) của đối tượng.",
          "reason": "Biến `transient` sẽ không được serialize khi đối tượng được lưu trữ. Cần học về serialization trong Java và các từ khóa liên quan."
        },
        {
          "id": 4,
          "question": "Điều gì xảy ra với garbage collection trong Java khi một đối tượng có nhiều tham chiếu, nhưng tất cả các tham chiếu đó đều nằm trong các đối tượng không còn được tham chiếu đến?",
          "options": [
            "Đối tượng sẽ không bao giờ được thu gom.",
            "Đối tượng sẽ được thu gom ngay lập tức.",
            "Đối tượng sẽ được thu gom khi bộ nhớ yếu.",
            "Đối tượng sẽ được thu gom trong lần chạy garbage collection tiếp theo."
          ],
          "correctAnswer": "Đối tượng sẽ được thu gom trong lần chạy garbage collection tiếp theo.",
          "reason": "Garbage collector xác định các đối tượng không còn reachable và thu hồi bộ nhớ của chúng. Cần học sâu về các thuật toán garbage collection (e.g., mark and sweep, generational)."
        },
        {
          "id": 5,
          "question": "Kết quả của đoạn mã sau:\n```java\npublic class Main {\n    interface I {\n        default void print() {\n            System.out.println(\"Interface\");\n        }\n    }\n    static class A implements I {\n        public void print() {\n            System.out.println(\"Class A\");\n        }\n    }\n    public static void main(String[] args) {\n       I a = new A();\n       a.print();\n    }\n}\n```",
          "options": ["Interface", "Class A", "Lỗi biên dịch", "Lỗi runtime"],
          "correctAnswer": "Class A",
          "reason": "Phương thức `print()` trong class `A` override default method trong interface `I`. Cần hiểu rõ về default method trong interface và thứ tự ưu tiên khi override."
        },
        {
          "id": 6,
          "question": "Giả sử có bảng `Orders` với các cột `OrderID` (INT, PRIMARY KEY), `CustomerID` (INT), `OrderDate` (DATE), `TotalAmount` (DECIMAL). Câu lệnh SQL nào trả về tổng `TotalAmount` của các đơn hàng theo từng tháng trong năm 2023, chỉ bao gồm các tháng có tổng `TotalAmount` lớn hơn 1000?",
          "options": [
            "```sql\nSELECT MONTH(OrderDate), SUM(TotalAmount) FROM Orders WHERE YEAR(OrderDate) = 2023 GROUP BY MONTH(OrderDate) HAVING SUM(TotalAmount) > 1000;\n```",
            "```sql\nSELECT MONTH(OrderDate), SUM(TotalAmount) FROM Orders WHERE YEAR(OrderDate) = 2023 AND SUM(TotalAmount) > 1000 GROUP BY MONTH(OrderDate);\n```",
            "```sql\nSELECT MONTH(OrderDate), SUM(TotalAmount) FROM Orders WHERE YEAR(OrderDate) = 2023 GROUP BY MONTH(OrderDate) WHERE SUM(TotalAmount) > 1000;\n```",
            "```sql\nSELECT MONTH(OrderDate), SUM(TotalAmount) FROM Orders HAVING SUM(TotalAmount) > 1000 WHERE YEAR(OrderDate) = 2023 GROUP BY MONTH(OrderDate);\n```"
          ],
          "correctAnswer": "```sql\nSELECT MONTH(OrderDate), SUM(TotalAmount) FROM Orders WHERE YEAR(OrderDate) = 2023 GROUP BY MONTH(OrderDate) HAVING SUM(TotalAmount) > 1000;\n```",
          "reason": "`WHERE` lọc theo năm, `GROUP BY` nhóm theo tháng, `HAVING` lọc theo tổng `TotalAmount` sau khi đã nhóm. Cần học về thứ tự thực hiện các mệnh đề trong SQL, phân biệt `WHERE` và `HAVING`."
        },
        {
          "id": 7,
          "question": "Cho bảng `Employees` với các cột `EmployeeID` (INT, PRIMARY KEY), `DepartmentID` (INT), `Salary` (DECIMAL). Câu lệnh SQL nào sau đây trả về `DepartmentID` có mức lương trung bình cao thứ hai?",
          "options": [
            "```sql\nSELECT DepartmentID FROM Employees GROUP BY DepartmentID ORDER BY AVG(Salary) DESC LIMIT 1 OFFSET 1;\n```",
            "```sql\nSELECT DepartmentID FROM Employees GROUP BY DepartmentID ORDER BY AVG(Salary) DESC LIMIT 2;\n```",
            "```sql\nSELECT DepartmentID FROM Employees ORDER BY AVG(Salary) DESC LIMIT 1, 1;\n```",
            "```sql\nSELECT DepartmentID FROM Employees GROUP BY DepartmentID HAVING AVG(Salary) = (SELECT MAX(AVG(Salary)) FROM Employees GROUP BY DepartmentID);\n```"
          ],
          "correctAnswer": "```sql\nSELECT DepartmentID FROM Employees GROUP BY DepartmentID ORDER BY AVG(Salary) DESC LIMIT 1 OFFSET 1;\n```",
          "reason": "Tính lương trung bình theo phòng ban, sắp xếp giảm dần, bỏ qua dòng đầu tiên (`OFFSET 1`) và lấy dòng thứ hai (`LIMIT 1`). Cần học về `LIMIT`, `OFFSET`, subquery, window function (nếu có)."
        },
        {
          "id": 8,
          "question": "Cho bảng `Products` với cột `ProductID` (INT, PRIMARY KEY), `CategoryID` (INT), `Price` (DECIMAL). Câu lệnh SQL nào sau đây trả về tất cả các sản phẩm có giá cao hơn mức giá trung bình của các sản phẩm trong cùng `CategoryID`?",
          "options": [
            "```sql\nSELECT * FROM Products p1 WHERE Price > (SELECT AVG(Price) FROM Products p2 WHERE p2.CategoryID = p1.CategoryID);\n```",
            "```sql\nSELECT * FROM Products WHERE Price > AVG(Price) GROUP BY CategoryID;\n```",
            "```sql\nSELECT * FROM Products WHERE Price > (SELECT AVG(Price) FROM Products) GROUP BY CategoryID;\n```",
            "```sql\nSELECT * FROM Products p1 WHERE Price > ALL (SELECT AVG(Price) FROM Products p2 WHERE p2.CategoryID = p1.CategoryID);\n```"
          ],
          "correctAnswer": "```sql\nSELECT * FROM Products p1 WHERE Price > (SELECT AVG(Price) FROM Products p2 WHERE p2.CategoryID = p1.CategoryID);\n```",
          "reason": "Sử dụng subquery để tính giá trung bình theo từng `CategoryID` và so sánh với giá của từng sản phẩm. Cần học về correlated subquery."
        },
        {
          "id": 9,
          "question": "Trong SQL, `FULL OUTER JOIN` trả về kết quả như thế nào?",
          "options": [
            "Tất cả các bản ghi từ bảng bên trái, và các bản ghi khớp từ bảng bên phải. Các bản ghi không khớp từ bảng bên phải sẽ có giá trị `NULL`.",
            "Tất cả các bản ghi từ bảng bên phải, và các bản ghi khớp từ bảng bên trái. Các bản ghi không khớp từ bảng bên trái sẽ có giá trị `NULL`.",
            "Chỉ các bản ghi có giá trị khớp ở cả hai bảng.",
            "Tất cả các bản ghi từ cả hai bảng. Các bản ghi không khớp ở mỗi bảng sẽ có giá trị `NULL` ở các cột tương ứng của bảng kia."
          ],
          "correctAnswer": "Tất cả các bản ghi từ cả hai bảng. Các bản ghi không khớp ở mỗi bảng sẽ có giá trị `NULL` ở các cột tương ứng của bảng kia.",
          "reason": "`FULL OUTER JOIN` trả về tất cả các dòng từ cả hai bảng, điền `NULL` vào các cột thiếu. Cần hiểu rõ sự khác biệt giữa các loại `JOIN`."
        },
        {
          "id": 10,
          "question": "Với bảng `Customers` (CustomerID, City, Country) và `Orders` (OrderID, CustomerID, OrderDate). Truy vấn SQL nào trả về tất cả các thành phố (City) có ít nhất một khách hàng đã đặt hàng vào ngày '2023-10-26'?",
          "options": [
            "```sql\nSELECT DISTINCT c.City FROM Customers c JOIN Orders o ON c.CustomerID = o.CustomerID WHERE o.OrderDate = '2023-10-26';\n```",
            "```sql\nSELECT c.City FROM Customers c WHERE EXISTS (SELECT 1 FROM Orders o WHERE o.CustomerID = c.CustomerID AND o.OrderDate = '2023-10-26');\n```",
            "```sql\nSELECT c.City FROM Customers c INNER JOIN Orders o ON c.CustomerID = o.CustomerID AND o.OrderDate = '2023-10-26';\n```",
            "```sql\nSELECT c.City FROM Customers c, Orders o WHERE c.CustomerID = o.CustomerID AND o.OrderDate = '2023-10-26';\n```"
          ],
          "correctAnswer": "```sql\nSELECT DISTINCT c.City FROM Customers c JOIN Orders o ON c.CustomerID = o.CustomerID WHERE o.OrderDate = '2023-10-26';\n```",
          "reason": "Kết hợp hai bảng `Customers` và `Orders` dựa trên `CustomerID`, lọc ra các đơn hàng có `OrderDate` là '2023-10-26', sau đó trả về distinct `City`. Cần học về `JOIN`, `DISTINCT`, `EXISTS`."
        },
        {
          "id": 11,
          "question": "Trong kiến trúc máy tính, kỹ thuật pipeline làm tăng hiệu năng bằng cách nào?",
          "options": [
            "Tăng tốc độ xung nhịp của CPU.",
            "Thực hiện nhiều lệnh đồng thời ở các giai đoạn khác nhau.",
            "Giảm số lượng thanh ghi trong CPU.",
            "Tăng kích thước bộ nhớ cache."
          ],
          "correctAnswer": "Thực hiện nhiều lệnh đồng thời ở các giai đoạn khác nhau.",
          "reason": "Pipeline cho phép nhiều lệnh được thực thi đồng thời ở các giai đoạn khác nhau của pipeline. Cần học về pipeline, hazards (structural, data, control) và cách giải quyết."
        },
        {
          "id": 12,
          "question": "Chiến lược ghi (write strategy) nào trong bộ nhớ cache đảm bảo rằng dữ liệu luôn được ghi đồng thời vào cả cache và bộ nhớ chính?",
          "options": [
            "Write-through",
            "Write-back",
            "Write-allocate",
            "No-write allocate"
          ],
          "correctAnswer": "Write-through",
          "reason": "Write-through đảm bảo tính nhất quán dữ liệu cao hơn, nhưng chậm hơn write-back. Cần học về các chiến lược ghi trong cache và ưu nhược điểm."
        },
        {
          "id": 13,
          "question": "Trong hệ điều hành, kỹ thuật phân trang (paging) giúp gì trong việc quản lý bộ nhớ?",
          "options": [
            "Giảm thiểu hiện tượng phân mảnh ngoại vi (external fragmentation).",
            "Cho phép các tiến trình có thể có không gian địa chỉ lớn hơn kích thước bộ nhớ vật lý.",
            "Cả hai đáp án trên đều đúng.",
            "Cả hai đáp án trên đều sai."
          ],
          "correctAnswer": "Cả hai đáp án trên đều đúng.",
          "reason": "Phân trang chia bộ nhớ thành các trang có kích thước cố định, loại bỏ phân mảnh ngoại vi và cho phép non-contiguous allocation. Cần học về phân trang, bảng trang (page table), TLB, và phân đoạn (segmentation)."
        },
        {
          "id": 14,
          "question": "Thuật toán Banker's algorithm được sử dụng trong hệ điều hành để làm gì?",
          "options": [
            "Phát hiện deadlock.",
            "Ngăn chặn deadlock.",
            "Khôi phục từ deadlock.",
            "Lập lịch CPU."
          ],
          "correctAnswer": "Ngăn chặn deadlock.",
          "reason": "Thuật toán Banker's algorithm đảm bảo hệ thống luôn ở trạng thái an toàn (safe state) để tránh deadlock. Cần học về deadlock, các điều kiện dẫn đến deadlock, và các chiến lược xử lý (prevention, avoidance, detection, recovery)."
        },
        {
          "id": 15,
          "question": "Trong lập trình hướng đối tượng, \"Liskov Substitution Principle\" phát biểu điều gì?",
          "options": [
            "Các đối tượng của một lớp cha có thể được thay thế bằng các đối tượng của lớp con mà không làm thay đổi tính đúng đắn của chương trình.",
            "Một lớp chỉ nên có một lý do duy nhất để thay đổi.",
            "Phần mềm nên mở cho việc mở rộng, nhưng đóng cho việc sửa đổi.",
            "Phụ thuộc vào abstraction, đừng phụ thuộc vào concretion."
          ],
          "correctAnswer": "Các đối tượng của một lớp cha có thể được thay thế bằng các đối tượng của lớp con mà không làm thay đổi tính đúng đắn của chương trình.",
          "reason": "Đây là nguyên lý quan trọng đảm bảo tính kế thừa và đa hình hoạt động đúng đắn. Cần học về SOLID principles trong thiết kế hướng đối tượng."
        },
        {
          "id": 16,
          "question": "Trong thiết kế cơ sở dữ liệu, dạng chuẩn 3NF (Third Normal Form) yêu cầu điều gì?",
          "options": [
            "Loại bỏ tất cả các phụ thuộc hàm bắc cầu.",
            "Mọi thuộc tính không khóa đều phụ thuộc đầy đủ vào khóa chính.",
            "Loại bỏ dư thừa dữ liệu.",
            "Tất cả các đáp án trên."
          ],
          "correctAnswer": "Tất cả các đáp án trên.",
          "reason": "3NF đảm bảo loại bỏ phụ thuộc hàm bắc cầu, phụ thuộc đầy đủ vào khóa chính và giảm thiểu dư thừa. Cần học về các dạng chuẩn (1NF, 2NF, 3NF, BCNF) và quá trình chuẩn hóa (normalization)."
        },
        {
          "id": 17,
          "question": "Trong kiểm thử phần mềm, \"equivalence partitioning\" là kỹ thuật kiểm thử hộp đen dùng để làm gì?",
          "options": [
            "Chia input domain thành các lớp tương đương, mỗi lớp được đại diện bởi một test case.",
            "Kiểm tra luồng điều khiển bên trong của chương trình.",
            "Kiểm tra các giá trị biên của input.",
            "Kiểm tra tất cả các đường dẫn có thể có trong chương trình."
          ],
          "correctAnswer": "Chia input domain thành các lớp tương đương, mỗi lớp được đại diện bởi một test case.",
          "reason": "Giảm số lượng test case cần thiết bằng cách chọn các giá trị đại diện cho các nhóm tương đương. Cần học về các kỹ thuật kiểm thử hộp đen (black-box testing) và hộp trắng (white-box testing)."
        },
        {
          "id": 18,
          "question": "Trong quản lý dự án, kỹ thuật PERT (Program Evaluation and Review Technique) khác gì so với CPM (Critical Path Method)?",
          "options": [
            "PERT sử dụng thời gian xác định cho các công việc, trong khi CPM sử dụng thời gian xác suất.",
            "PERT sử dụng thời gian xác suất cho các công việc, trong khi CPM sử dụng thời gian xác định.",
            "PERT phù hợp với các dự án nghiên cứu và phát triển, trong khi CPM phù hợp với các dự án xây dựng.",
            "Cả B và C đều đúng."
          ],
          "correctAnswer": "Cả B và C đều đúng.",
          "reason": "PERT tính đến yếu tố không chắc chắn trong thời gian hoàn thành công việc. Cần học về PERT, CPM, critical path, float/slack."
        },
        {
          "id": 19,
          "question": "Giao thức định tuyến RIP (Routing Information Protocol) sử dụng thuật toán nào?",
          "options": [
            "Distance Vector",
            "Link State",
            "Path Vector",
            "Shortest Path First"
          ],
          "correctAnswer": "Distance Vector",
          "reason": "RIP sử dụng distance vector, có nhược điểm là chậm hội tụ và dễ bị routing loop. Cần học về distance vector, link state, các giao thức định tuyến (RIP, OSPF, BGP)."
        },
        {
          "id": 20,
          "question": "Trong mạng máy tính, cơ chế CSMA/CD (Carrier Sense Multiple Access with Collision Detection) được sử dụng ở tầng nào của mô hình OSI?",
          "options": [
            "Physical Layer",
            "Data Link Layer",
            "Network Layer",
            "Transport Layer"
          ],
          "correctAnswer": "Data Link Layer",
          "reason": "CSMA/CD là cơ chế điều khiển truy cập đường truyền, thuộc tầng Data Link. Cần học về mô hình OSI, các giao thức ở từng tầng, và các phương pháp điều khiển truy cập đường truyền (CSMA/CD, CSMA/CA, Token Ring)."
        },
        {
          "id": 21,
          "question": "Đặc điểm chính của kiến trúc bộ nhớ Harvard là gì?",
          "options": [
            "Sử dụng chung một không gian địa chỉ cho cả lệnh và dữ liệu",
            "Sử dụng hai không gian địa chỉ riêng biệt cho lệnh và dữ liệu",
            "Chỉ sử dụng bộ nhớ cache cho dữ liệu",
            "Chỉ sử dụng bộ nhớ cache cho lệnh"
          ],
          "correctAnswer": "Sử dụng hai không gian địa chỉ riêng biệt cho lệnh và dữ liệu",
          "reason": "Kiến trúc Harvard cho phép truy cập đồng thời vào lệnh và dữ liệu, tăng tốc độ xử lý. Cần phân biệt với kiến trúc Von Neumann."
        },
        {
          "id": 22,
          "question": "Trong hệ điều hành, khi nào thì xảy ra hiện tượng thrashing?",
          "options": [
            "Khi CPU quá tải",
            "Khi xảy ra quá nhiều lỗi trang (page faults) dẫn đến hệ thống dành phần lớn thời gian để thay thế trang thay vì thực hiện công việc hữu ích",
            "Khi một tiến trình bị deadlock",
            "Khi ổ đĩa bị lỗi"
          ],
          "correctAnswer": "Khi xảy ra quá nhiều lỗi trang (page faults) dẫn đến hệ thống dành phần lớn thời gian để thay thế trang thay vì thực hiện công việc hữu ích",
          "reason": "Thrashing làm giảm hiệu năng hệ thống nghiêm trọng. Cần học về quản lý bộ nhớ ảo, thay thế trang (page replacement algorithms) và working set model."
        },
        {
          "id": 23,
          "question": "Trong Java, `Phantom Read` là gì in context của transaction?",
          "options": [
            "Một transaction đọc cùng một dữ liệu hai lần và nhận được các giá trị khác nhau do một transaction khác đã cập nhật dữ liệu đó.",
            "Một transaction đọc dữ liệu đã bị xóa bởi một transaction khác.",
            "Một transaction đọc dữ liệu mà transaction khác đã chèn vào sau lần đọc đầu tiên.",
            "Một transaction không thể đọc dữ liệu do transaction khác đang giữ khóa trên dữ liệu đó."
          ],
          "correctAnswer": "Một transaction đọc dữ liệu mà transaction khác đã chèn vào sau lần đọc đầu tiên.",
          "reason": "Phantom read xảy ra khi transaction thứ hai chèn thêm bản ghi thỏa mãn điều kiện truy vấn của transaction thứ nhất, dẫn tới 2 lần query cho ra 2 kết quả khác nhau. Cần học về các mức cô lập (isolation levels) trong cơ sở dữ liệu (Read Uncommitted, Read Committed, Repeatable Read, Serializable)."
        },
        {
          "id": 24,
          "question": "Biểu thức chính quy `^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$` dùng để kiểm tra điều gì?",
          "options": [
            "Chuỗi có ít nhất 8 ký tự, bao gồm chữ thường, chữ hoa và số",
            "Chuỗi có đúng 8 ký tự, bao gồm chữ thường, chữ hoa và số",
            "Chuỗi bắt đầu bằng chữ thường, tiếp theo là chữ hoa và kết thúc bằng số",
            "Chuỗi có ít nhất một chữ thường, một chữ hoa và một số"
          ],
          "correctAnswer": "Chuỗi có ít nhất 8 ký tự, bao gồm chữ thường, chữ hoa và số",
          "reason": "Sử dụng lookahead `(?=...)` để kiểm tra sự hiện diện của ít nhất một chữ thường, một chữ hoa, một số và `[a-zA-Z\\d]{8,}` để đảm bảo có ít nhất 8 ký tự. Cần học về lookahead, lookbehind trong regular expression."
        },
        {
          "id": 25,
          "question": "Trong SQL, sự khác biệt chính giữa `UNION` và `UNION ALL` là gì?",
          "options": [
            "`UNION` loại bỏ các bản ghi trùng lặp, trong khi `UNION ALL` thì không.",
            "`UNION ALL` loại bỏ các bản ghi trùng lặp, trong khi `UNION` thì không.",
            "`UNION` chỉ hoạt động trên các bảng có cùng số lượng cột, trong khi `UNION ALL` có thể hoạt động trên các bảng có số lượng cột khác nhau.",
            "Không có sự khác biệt nào cả."
          ],
          "correctAnswer": "`UNION` loại bỏ các bản ghi trùng lặp, trong khi `UNION ALL` thì không.",
          "reason": "`UNION ALL` nhanh hơn `UNION` vì không phải kiểm tra trùng lặp. Cần học về các phép hợp (union) trong SQL."
        },
        {
          "id": 26,
          "question": "Trong Java, khi nào nên sử dụng `StringBuilder` thay vì `String`?",
          "options": [
            "Khi cần nối chuỗi trong một vòng lặp.",
            "Khi cần thay đổi nội dung chuỗi nhiều lần.",
            "Khi cần một chuỗi bất biến (immutable).",
            "Cả A và B đều đúng."
          ],
          "correctAnswer": "Cả A và B đều đúng.",
          "reason": "`String` là bất biến, tạo đối tượng mới mỗi lần thay đổi, `StringBuilder` có thể thay đổi (mutable), hiệu quả hơn khi thao tác chuỗi nhiều lần. Cần học về `String`, `StringBuilder`, `StringBuffer`."
        },
        {
          "id": 27,
          "question": "Trong cơ sở dữ liệu, `Two-Phase Locking (2PL)` là một giao thức concurrency control đảm bảo điều gì?",
          "options": [
            "Tính nhất quán (consistency)",
            "Tính cô lập (isolation)",
            "Tính bền vững (durability)",
            "Cả A và B"
          ],
          "correctAnswer": "Cả A và B",
          "reason": "2PL đảm bảo các giao dịch diễn ra một cách tuần tự (serializable) bằng cách yêu cầu mỗi giao dịch phải có hai giai đoạn: growing phase (chỉ xin lock) và shrinking phase (chỉ giải phóng lock). Cần học về concurrency control, locking, timestamp ordering."
        },
        {
          "id": 28,
          "question": "Trong phát triển phần mềm, TDD (Test-Driven Development) yêu cầu điều gì?",
          "options": [
            "Viết test case trước khi viết code.",
            "Viết code trước khi viết test case.",
            "Viết test case đồng thời với viết code.",
            "Không cần viết test case."
          ],
          "correctAnswer": "Viết test case trước khi viết code.",
          "reason": "TDD giúp đảm bảo code thỏa mãn yêu cầu và dễ bảo trì hơn. Cần học về TDD, red-green-refactor cycle."
        },
        {
          "id": 29,
          "question": "Trong Java Generics, wildcard `<?> ` đại diện cho điều gì?",
          "options": [
            "Một kiểu dữ liệu bất kỳ.",
            "Một kiểu dữ liệu cụ thể nhưng chưa biết.",
            "Một kiểu dữ liệu không xác định.",
            "Một kiểu dữ liệu nguyên thủy."
          ],
          "correctAnswer": "Một kiểu dữ liệu bất kỳ.",
          "reason": "Wildcard cho phép thao tác với các kiểu dữ liệu tổng quát một cách linh hoạt. Cần học về generics, bounded wildcards (`<? extends T>`, `<? super T>`)."
        },
        {
          "id": 30,
          "question": "Trong Javascript, cơ chế 'event bubbling' là gì?",
          "options": [
            "Sự kiện được kích hoạt trên một phần tử, sau đó lan truyền (bubble up) lên các phần tử cha của nó.",
            "Sự kiện được kích hoạt trên một phần tử, sau đó lan truyền xuống các phần tử con của nó.",
            "Sự kiện chỉ được kích hoạt trên phần tử gốc.",
            "Sự kiện được kích hoạt đồng thời trên tất cả các phần tử."
          ],
          "correctAnswer": "Sự kiện được kích hoạt trên một phần tử, sau đó lan truyền (bubble up) lên các phần tử cha của nó.",
          "reason": "Cần phân biệt với event capturing. Cần học về event handling trong Javascript, DOM event flow."
        }
      ]
    },
    {
      "id": 7,
      "title": "Tricky Computer Science Quiz 3",
      "timeLimit": 1000,
      "questions": [
        {
          "id": 1,
          "question": "Đoạn mã Java sau in ra kết quả gì?\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int i = 0;\n        i = i++ + i;\n        System.out.println(i);\n    }\n}\n```",
          "options": ["0", "1", "2", "Lỗi biên dịch"],
          "correctAnswer": "1",
          "reason": "`i++` trả về giá trị của `i` trước khi tăng, sau đó `i` mới được tăng lên 1. Do đó, `i = 0 + 1 = 1`. Cần chú ý đến thứ tự thực hiện của toán tử `++` (post-increment)."
        },
        {
          "id": 2,
          "question": "Điều gì xảy ra khi đoạn mã Java sau được thực thi?\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Integer a = 1000;\n        Integer b = 1000;\n        System.out.println(a == b);\n    }\n}\n```",
          "options": [
            "true",
            "false",
            "Lỗi biên dịch",
            "Kết quả không xác định"
          ],
          "correctAnswer": "false",
          "reason": "Integer caching chỉ áp dụng cho các giá trị từ -128 đến 127. `a` và `b` là hai đối tượng `Integer` khác nhau có giá trị 1000. Cần học về Integer caching và phân biệt `==` với `equals()`."
        },
        {
          "id": 3,
          "question": "Đoạn mã Java sau bị lỗi gì?\n```java\npublic class Main {\n    public static void main(String[] args) {\n        for (int i = 0; i < 5; i++); {\n            System.out.println(i);\n        }\n    }\n}\n```",
          "options": [
            "Lỗi cú pháp: biến `i` không được định nghĩa",
            "Lỗi cú pháp: vòng lặp for không có thân",
            "Lỗi logic: vòng lặp vô hạn",
            "Không có lỗi"
          ],
          "correctAnswer": "Lỗi cú pháp: biến `i` không được định nghĩa",
          "reason": "Dấu `;` sau `for` làm cho vòng lặp `for` kết thúc ngay lập tức, `i` chỉ có phạm vi trong `for` nên sẽ lỗi khi ra ngoài `for`. Cần chú ý đến phạm vi của biến và các dấu chấm phẩy (`;`) thừa."
        },
        {
          "id": 4,
          "question": "Đoạn mã sau biên dịch thành công không?\n```java\npublic class Main {\n  public static void main(String[] args) {\n    try{\n      return;\n    } finally {\n      System.out.println(\"Finally\");\n    }\n  }\n}\n```",
          "options": ["Có", "Không"],
          "correctAnswer": "Có",
          "reason": "Khối finally luôn được thực thi kể cả khi có return trong try, \"Finally\" vẫn sẽ được in ra"
        },
        {
          "id": 5,
          "question": "Điều gì xảy ra khi đoạn mã Java sau được thực thi?\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String s = null;\n        System.out.println(\"\" + s);\n    }\n}\n```",
          "options": [
            "In ra \"null\"",
            "Ném ra NullPointerException",
            "Lỗi biên dịch",
            "In ra chuỗi rỗng"
          ],
          "correctAnswer": "In ra \"null\"",
          "reason": "Khi `null` được nối với chuỗi, nó sẽ được chuyển đổi thành chuỗi \"null\". Cần phân biệt giữa `null` và chuỗi rỗng."
        },
        {
          "id": 6,
          "question": "Kết quả của đoạn mã sau?\n```java\npublic class Main{\n  static int x = 10;\n  public static void main(String[] args) {\n      Main a = new Main();\n      Main b = new Main();\n      a.x = 20;\n      System.out.println(b.x);\n  }\n}\n```",
          "options": ["10", "20", "Lỗi biên dịch", "Kết quả khác"],
          "correctAnswer": "20",
          "reason": "x là biến static, a.x = 20 sẽ thay đổi giá trị của biến static x, do đó khi gọi b.x cũng sẽ in ra 20"
        },
        {
          "id": 7,
          "question": "Đoạn mã sau xày ra lỗi gì?\n```java\npublic class Main {\n    public static void main(String[] args) {\n      Object obj = new Integer(10);\n      String s = (String) obj;\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi runtime: ClassCastException",
            "Lỗi runtime: NullPointerException",
            "Lỗi biên dịch"
          ],
          "correctAnswer": "Lỗi runtime: ClassCastException",
          "reason": "Không thể ép kiểu `Integer` sang `String` trực tiếp, gây ra lỗi `ClassCastException` khi chạy. Cần học về ép kiểu (casting) và các quy tắc."
        },
        {
          "id": 8,
          "question": "Kết quả của đoạn mã sau?\n```java\npublic class A {\n  public void print(){\n    System.out.println(\"A\");\n  }\n}\npublic class B extends A {\n  public void print(){\n    System.out.println(\"B\");\n  }\n  public static void main(String[] args) {\n    A a = new B();\n    a.print();\n  }\n}\n```",
          "options": ["A", "B", "Lỗi biên dịch", "Lỗi runtime"],
          "correctAnswer": "B",
          "reason": "Tính đa hình, phương thức print() của B sẽ được gọi"
        },
        {
          "id": 9,
          "question": "Trong SQL, mệnh đề nào sau đây có thể được sử dụng để thêm ràng buộc (constraint) vào bảng sau khi bảng đã được tạo?",
          "options": [
            "CREATE TABLE",
            "ALTER TABLE",
            "UPDATE TABLE",
            "INSERT INTO"
          ],
          "correctAnswer": "ALTER TABLE",
          "reason": "`ALTER TABLE` được sử dụng để thêm, xóa, hoặc sửa đổi các cột và ràng buộc trong bảng đã tồn tại. Cần học về `ALTER TABLE` và các loại ràng buộc (constraints)."
        },
        {
          "id": 10,
          "question": "Trong SQL, từ khóa nào được sử dụng để loại bỏ các giá trị trùng lặp từ kết quả truy vấn?",
          "options": ["UNIQUE", "DISTINCT", "NO DUPLICATE", "GROUP BY"],
          "correctAnswer": "DISTINCT",
          "reason": "`DISTINCT` đảm bảo rằng các giá trị trong cột được chọn là duy nhất. Cần phân biệt `DISTINCT` với `GROUP BY`."
        },
        {
          "id": 11,
          "question": "Điều kiện nào sau đây là BẮT BUỘC để xảy ra deadlock?",
          "options": [
            "Mutual Exclusion",
            "Hold and Wait",
            "No Preemption",
            "Circular Wait",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": "Tất cả các đáp án trên",
          "reason": "Cả bốn điều kiện (Coffman conditions) đều phải xảy ra đồng thời thì deadlock mới có thể xảy ra. Cần học kỹ về deadlock và các điều kiện xảy ra."
        },
        {
          "id": 12,
          "question": "Trong transaction của cơ sở dữ liệu, nếu một transaction không thể hoàn thành (ví dụ: do mất điện), thì thuộc tính nào đảm bảo rằng tất cả các thay đổi của transaction đó sẽ được hoàn tác?",
          "options": ["Atomicity", "Consistency", "Isolation", "Durability"],
          "correctAnswer": "Atomicity",
          "reason": "Atomicity đảm bảo tính \"được ăn cả, ngã về không\" của transaction. Cần học về ACID properties."
        },
        {
          "id": 13,
          "question": "Trong Java, khi một lớp implement nhiều interface có cùng phương thức default, điều gì sẽ xảy ra?",
          "options": [
            "Lớp đó phải override phương thức default đó.",
            "Phương thức default của interface đầu tiên được sử dụng.",
            "Phương thức default của interface cuối cùng được sử dụng.",
            "Một lỗi biên dịch sẽ xảy ra nếu lớp đó không override phương thức default đó."
          ],
          "correctAnswer": "Một lỗi biên dịch sẽ xảy ra nếu lớp đó không override phương thức default đó.",
          "reason": "Trình biên dịch không thể tự quyết định nên sử dụng phương thức default nào, cần lập trình viên chỉ định rõ bằng cách override. Cần học về default method inheritance conflict."
        },
        {
          "id": 14,
          "question": "Kỹ thuật \"dirty read\" trong concurrency control của cơ sở dữ liệu xảy ra khi nào?",
          "options": [
            "Một transaction đọc dữ liệu đã được ghi bởi một transaction khác nhưng chưa được commit.",
            "Một transaction đọc dữ liệu đã bị xóa bởi một transaction khác.",
            "Một transaction đọc dữ liệu mà transaction khác đã chèn vào sau lần đọc đầu tiên.",
            "Một transaction ghi đè dữ liệu mà transaction khác đang đọc."
          ],
          "correctAnswer": "Một transaction đọc dữ liệu đã được ghi bởi một transaction khác nhưng chưa được commit.",
          "reason": "Dirty read có thể dẫn đến mất mát dữ liệu nếu transaction ghi dữ liệu đó rollback. Cần học về các mức cô lập (isolation levels) và các vấn đề có thể xảy ra (dirty read, non-repeatable read, phantom read)."
        },
        {
          "id": 15,
          "question": "Trong quản lý dự án, \"slack time\" (hay \"float time\") của một activity là gì?",
          "options": [
            "Khoảng thời gian activity đó có thể bị trì hoãn mà không làm ảnh hưởng đến thời gian hoàn thành dự án.",
            "Khoảng thời gian activity đó có thể bị trì hoãn mà không làm ảnh hưởng đến các activity tiếp theo.",
            "Khoảng thời gian cần thiết để hoàn thành activity đó.",
            "Khoảng thời gian dự trữ cho các rủi ro."
          ],
          "correctAnswer": "Khoảng thời gian activity đó có thể bị trì hoãn mà không làm ảnh hưởng đến thời gian hoàn thành dự án.",
          "reason": "Slack time cho biết mức độ linh hoạt trong việc lập lịch cho activity. Cần học về critical path method (CPM) và cách tính slack/float."
        },
        {
          "id": 16,
          "question": "Trong Javascript, closure là gì?",
          "options": [
            "Một hàm có thể truy cập các biến trong phạm vi của nó, ngay cả khi hàm đó được gọi bên ngoài phạm vi đó.",
            "Một cách để đóng gói dữ liệu và phương thức trong một đối tượng.",
            "Một kỹ thuật để ẩn các biến bên trong một hàm.",
            "Một loại hàm đặc biệt chỉ có thể được gọi một lần."
          ],
          "correctAnswer": "Một hàm có thể truy cập các biến trong phạm vi của nó, ngay cả khi hàm đó được gọi bên ngoài phạm vi đó.",
          "reason": "Closure cho phép tạo các biến \"private\" trong Javascript. Cần học về scope, closure, và cách hoạt động của chúng."
        },
        {
          "id": 17,
          "question": "Trong kiểm thử phần mềm, loại kiểm thử nào tập trung vào việc kiểm tra cách các module/thành phần hoạt động cùng nhau sau khi chúng đã được kiểm tra riêng lẻ?",
          "options": [
            "Unit testing",
            "Integration testing",
            "System testing",
            "Acceptance testing"
          ],
          "correctAnswer": "Integration testing",
          "reason": "Integration testing kiểm tra giao diện và luồng dữ liệu giữa các module. Cần học về các loại kiểm thử và mục đích của chúng."
        },
        {
          "id": 18,
          "question": "Trong Java, `static` method có thể truy cập trực tiếp đến thành viên nào của lớp?",
          "options": [
            "Chỉ các biến `static`.",
            "Chỉ các biến instance.",
            "Cả biến `static` và biến instance.",
            "Không thể truy cập bất kỳ biến nào."
          ],
          "correctAnswer": "Chỉ các biến `static`.",
          "reason": "`static` method thuộc về lớp, không thuộc về instance cụ thể nào, do đó không thể truy cập trực tiếp biến instance. Cần học về `static` và sự khác biệt giữa static members và instance members."
        },
        {
          "id": 19,
          "question": "Trong SQL, subquery (truy vấn con) là gì?",
          "options": [
            "Một truy vấn được lồng bên trong một truy vấn khác.",
            "Một truy vấn được sử dụng để tạo bảng tạm thời.",
            "Một truy vấn được sử dụng để cập nhật dữ liệu.",
            "Một truy vấn được sử dụng để xóa dữ liệu."
          ],
          "correctAnswer": "Một truy vấn được lồng bên trong một truy vấn khác.",
          "reason": "Subquery có thể được sử dụng trong mệnh đề `SELECT`, `FROM`, `WHERE`, `HAVING`. Cần học về các loại subquery (scalar, multiple-row, correlated) và cách sử dụng."
        },
        {
          "id": 20,
          "question": "Trong mạng máy tính, giao thức nào sau đây hoạt động ở tầng Network của mô hình OSI?",
          "options": ["TCP", "UDP", "IP", "HTTP"],
          "correctAnswer": "IP",
          "reason": "IP (Internet Protocol) chịu trách nhiệm định tuyến các gói tin giữa các mạng khác nhau. Cần học về mô hình OSI và các giao thức ở từng tầng."
        },
        {
          "id": 21,
          "question": "Trong lập trình hướng đối tượng, các nguyên tắc SOLID là:",
          "options": [
            "Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion",
            "Simple, Object-Oriented, Lightweight, Independent, Dynamic",
            "Secure, Optimized, Lightweight, Integrated, Distributed",
            "Scalable, Operable, Logical, Isolated, Decentralized"
          ],
          "correctAnswer": "Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion",
          "reason": "SOLID principles giúp thiết kế phần mềm dễ bảo trì, mở rộng và tái sử dụng. Cần hiểu rõ từng nguyên tắc và cách áp dụng."
        },
        {
          "id": 22,
          "question": "Trong biểu đồ Gantt, đường găng (critical path) là gì?",
          "options": [
            "Chuỗi các công việc không có thời gian dự trữ.",
            "Chuỗi các công việc quan trọng nhất của dự án.",
            "Chuỗi các công việc có tổng thời gian thực hiện dài nhất.",
            "Chuỗi các công việc cần nhiều nguồn lực nhất."
          ],
          "correctAnswer": "Chuỗi các công việc có tổng thời gian thực hiện dài nhất.",
          "reason": "Critical path xác định thời gian hoàn thành tối thiểu của dự án. Cần học về critical path method (CPM) và cách xác định critical path."
        },
        {
          "id": 23,
          "question": "Trong Java, anonymous class là gì?",
          "options": [
            "Một class không có tên.",
            "Một class được định nghĩa bên trong một method.",
            "Một class được sử dụng để tạo các đối tượng chỉ dùng một lần.",
            "Tất cả các đáp án trên."
          ],
          "correctAnswer": "Tất cả các đáp án trên.",
          "reason": "Anonymous class thường được sử dụng để implement interface hoặc extend class một cách nhanh chóng mà không cần tạo một class riêng biệt. Cần học về anonymous class, inner class, nested class."
        },
        {
          "id": 24,
          "question": "Trong SQL, `LEFT JOIN` trả về kết quả như thế nào?",
          "options": [
            "Tất cả các bản ghi từ bảng bên trái, và các bản ghi khớp từ bảng bên phải. Các bản ghi không khớp từ bảng bên phải sẽ có giá trị `NULL`.",
            "Tất cả các bản ghi từ bảng bên phải, và các bản ghi khớp từ bảng bên trái. Các bản ghi không khớp từ bảng bên trái sẽ có giá trị `NULL`.",
            "Chỉ các bản ghi có giá trị khớp ở cả hai bảng.",
            "Tất cả các bản ghi từ cả hai bảng. Các bản ghi không khớp ở mỗi bảng sẽ có giá trị `NULL` ở các cột tương ứng của bảng kia."
          ],
          "correctAnswer": "Tất cả các bản ghi từ bảng bên trái, và các bản ghi khớp từ bảng bên phải. Các bản ghi không khớp từ bảng bên phải sẽ có giá trị `NULL`.",
          "reason": "Cần phân biệt `LEFT JOIN`, `RIGHT JOIN`, `INNER JOIN`, `FULL OUTER JOIN`."
        },
        {
          "id": 25,
          "question": "Chọn các câu trả lời đúng về interface trong Java:",
          "options": [
            "Interface có thể chứa phương thức `static`.",
            "Interface có thể chứa phương thức `default`.",
            "Interface có thể chứa phương thức `private`.",
            "Interface có thể chứa thuộc tính (fields)."
          ],
          "correctAnswer": [
            "Interface có thể chứa phương thức `static`.",
            "Interface có thể chứa phương thức `default`.",
            "Interface có thể chứa phương thức `private`.",
            "Interface có thể chứa thuộc tính (fields)."
          ],
          "reason": "Từ Java 8, interface có thể chứa `static` và `default` methods. Từ Java 9, interface có thể chứa `private` method. Interface có thể chứa các `public static final` field. Cần cập nhật kiến thức về các tính năng mới của interface trong các phiên bản Java gần đây."
        },
        {
          "id": 26,
          "question": "Trong Javascript, `===` so sánh như thế nào?",
          "options": [
            "So sánh giá trị sau khi đã ép kiểu.",
            "So sánh cả giá trị và kiểu dữ liệu.",
            "Chỉ so sánh kiểu dữ liệu.",
            "So sánh tham chiếu của hai đối tượng."
          ],
          "correctAnswer": "So sánh cả giá trị và kiểu dữ liệu.",
          "reason": "Cần phân biệt `==` (loose equality) và `===` (strict equality)."
        },
        {
          "id": 27,
          "question": "Những phương pháp nào KHÔNG thể override trong java?",
          "options": [
            "static method",
            "final method",
            "private method",
            "public method"
          ],
          "correctAnswer": ["static method", "final method", "private method"],
          "reason": "static method thuộc về lớp, final method không thể bị override, private method có phạm vi trong class khai báo nên cũng không thể override. Cần hiểu rõ về overriding và các hạn chế."
        },
        {
          "id": 28,
          "question": "Regular expression `\\b(\\w+)\\s+\\1\\b` khớp với chuỗi nào?",
          "options": [
            "Các từ viết hoa",
            "Các từ lặp lại liền nhau",
            "Các từ có ít nhất một chữ số",
            "Các từ có dấu gạch dưới"
          ],
          "correctAnswer": "Các từ lặp lại liền nhau",
          "reason": "`\\b` khớp với ranh giới từ, `(\\w+)` khớp với một từ và lưu vào group 1, `\\s+` khớp với một hoặc nhiều khoảng trắng, `\\1` tham chiếu đến group 1 (từ đã khớp trước đó). Cần học về backreference trong regular expression."
        },
        {
          "id": 29,
          "question": "Trong cơ sở dữ liệu, nếu hai transaction cùng cập nhật một bản ghi, nhưng transaction thứ hai chỉ commit sau khi transaction thứ nhất đã commit, thì vấn đề concurrency nào KHÔNG thể xảy ra?",
          "options": [
            "Dirty read",
            "Non-repeatable read",
            "Phantom read",
            "Lost update"
          ],
          "correctAnswer": ["Lost update"],
          "reason": "Lost update không thể xảy ra vì các thay đổi được thực hiện tuần tự. Cần hiểu rõ về các vấn đề concurrency."
        },
        {
          "id": 30,
          "question": "Cho bảng `Employees` với các cột `EmployeeID`, `DepartmentID`, `Salary`. Câu lệnh SQL nào trả về `EmployeeID` của nhân viên có mức lương cao thứ ba trong mỗi bộ phận?",
          "options": [
            "```sql\nSELECT EmployeeID FROM ( SELECT EmployeeID, DepartmentID, Salary, ROW_NUMBER() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) as rn FROM Employees ) ranked WHERE rn = 3;\n```",
            "```sql\nSELECT EmployeeID FROM Employees WHERE Salary = (SELECT MAX(Salary) FROM Employees);\n```",
            "```sql\nSELECT EmployeeID, DepartmentID, Salary FROM Employees e1 WHERE 2 = (SELECT COUNT(DISTINCT Salary) FROM Employees e2 WHERE e2.Salary > e1.Salary AND e1.DepartmentID = e2.DepartmentID);\n```",
            "Cả A và C đều đúng"
          ],
          "correctAnswer": "Cả A và C đều đúng",
          "reason": "Câu A sử dụng window function `ROW_NUMBER()`. Câu C sử dụng correlated subquery để đếm số lượng mức lương lớn hơn. Cần học về window functions và correlated subqueries, cách tìm top N."
        }
      ]
    },
    {
      "id": 8,
      "title": "Tổng hợp Kiến thức Khoa học Máy tính - Đề 2",
      "timeLimit": 3600,
      "questions": [
        {
          "id": 1,
          "question": "Thiết bị nào sau đây hoạt động ở tầng Liên kết dữ liệu (Data Link Layer) của mô hình OSI?",
          "options": ["Router", "Switch", "Hub", "Repeater"],
          "correctAnswer": "Switch",
          "reason": "Switch hoạt động ở tầng Liên kết dữ liệu, sử dụng địa chỉ MAC để chuyển tiếp gói dữ liệu."
        },
        {
          "id": 2,
          "question": "Thuật toán sắp xếp nào có độ phức tạp thời gian trung bình là O(n log n)?",
          "options": [
            "Bubble Sort",
            "Insertion Sort",
            "Merge Sort",
            "Selection Sort"
          ],
          "correctAnswer": "Merge Sort",
          "reason": "Merge Sort sử dụng phương pháp chia để trị và có độ phức tạp thời gian là O(n log n)."
        },
        {
          "id": 3,
          "question": "Bộ nhớ ảo (Virtual Memory) được sử dụng để làm gì?",
          "options": [
            "Tăng tốc độ truy cập bộ nhớ",
            "Mở rộng dung lượng bộ nhớ RAM",
            "Lưu trữ dữ liệu tạm thời",
            "Cung cấp bộ nhớ cache"
          ],
          "correctAnswer": "Mở rộng dung lượng bộ nhớ RAM",
          "reason": "Bộ nhớ ảo sử dụng không gian đĩa để mở rộng bộ nhớ RAM, cho phép chạy các chương trình lớn hơn dung lượng RAM thực tế."
        },
        {
          "id": 4,
          "question": "Lịch trình nào sau đây ưu tiên các tiến trình có thời gian thực thi ngắn nhất?",
          "options": ["FCFS", "Round Robin", "SJF", "Priority Scheduling"],
          "correctAnswer": "SJF",
          "reason": "SJF (Shortest Job First) ưu tiên các tiến trình có thời gian thực thi ngắn nhất để tối ưu hóa thời gian chờ trung bình."
        },
        {
          "id": 5,
          "question": "Tính chất nào sau đây không phải là của lập trình hướng đối tượng?",
          "options": [
            "Kế thừa (Inheritance)",
            "Đa hình (Polymorphism)",
            "Trừu tượng (Abstraction)",
            "Lập trình hàm (Functional programming)"
          ],
          "correctAnswer": "Lập trình hàm (Functional programming)",
          "reason": "Lập trình hàm là một mô hình lập trình khác, không phải là một tính chất của lập trình hướng đối tượng."
        },
        {
          "id": 6,
          "question": "Đâu là lỗi cú pháp trong đoạn mã Java sau?\n`public class MyClass {\n public static void main(String args[]) {\n System.out.println(\"Hello\" \n}\n}`",
          "options": [
            "Thiếu dấu chấm phẩy ở cuối dòng System.out.println()",
            "Thiếu dấu ngoặc đơn đóng ở System.out.println()",
            "Sử dụng sai cú pháp args[]",
            "Không có lỗi cú pháp"
          ],
          "correctAnswer": "Thiếu dấu ngoặc đơn đóng ở System.out.println()",
          "reason": "Hàm `println` bị thiếu dấu ngoặc đơn đóng `)`. "
        },
        {
          "id": 7,
          "question": "Câu lệnh SQL nào được sử dụng để lấy dữ liệu từ bảng?",
          "options": ["INSERT", "UPDATE", "SELECT", "DELETE"],
          "correctAnswer": "SELECT",
          "reason": "Câu lệnh SELECT được sử dụng để truy vấn và lấy dữ liệu từ cơ sở dữ liệu."
        },
        {
          "id": 8,
          "question": "Trong kỹ nghệ phần mềm, mô hình nào phù hợp khi yêu cầu của dự án không rõ ràng và có thể thay đổi?",
          "options": [
            "Mô hình thác nước (Waterfall)",
            "Mô hình xoắn ốc (Spiral)",
            "Mô hình Agile",
            "Mô hình V"
          ],
          "correctAnswer": "Mô hình Agile",
          "reason": "Mô hình Agile linh hoạt, cho phép thay đổi yêu cầu trong quá trình phát triển."
        },
        {
          "id": 9,
          "question": "Công cụ nào thường được sử dụng để quản lý các phiên bản mã nguồn?",
          "options": ["MS Project", "Git", "Jira", "Trello"],
          "correctAnswer": "Git",
          "reason": "Git là một hệ thống quản lý phiên bản phân tán phổ biến."
        },
        {
          "id": 10,
          "question": "Địa chỉ IP nào là một địa chỉ loopback?",
          "options": ["192.168.1.1", "10.0.0.1", "127.0.0.1", "172.16.0.1"],
          "correctAnswer": "127.0.0.1",
          "reason": "Địa chỉ 127.0.0.1 là địa chỉ loopback, dùng để kiểm tra các kết nối mạng trên máy tính cục bộ."
        },
        {
          "id": 11,
          "question": "Cấu trúc dữ liệu nào sau đây thường được sử dụng để cài đặt hàng đợi (Queue)?",
          "options": ["Stack", "Array", "Linked list", "Tree"],
          "correctAnswer": "Linked list",
          "reason": "Hàng đợi (Queue) thường được triển khai bằng danh sách liên kết vì nó hỗ trợ hiệu quả các thao tác thêm vào cuối và xóa ở đầu."
        },
        {
          "id": 12,
          "question": "Phương pháp nào được sử dụng để chuyển địa chỉ logic thành địa chỉ vật lý trong bộ nhớ?",
          "options": [
            "Paging",
            "Caching",
            "Segmentation",
            "Translation Lookaside Buffer (TLB)"
          ],
          "correctAnswer": "Paging",
          "reason": "Paging là một phương pháp quản lý bộ nhớ, nó chia không gian nhớ thành các trang có kích thước cố định."
        },
        {
          "id": 13,
          "question": "Thuật ngữ 'deadlock' (bế tắc) trong hệ điều hành là gì?",
          "options": [
            "Tiến trình bị tạm dừng vô hạn",
            "Tiến trình sử dụng quá nhiều CPU",
            "Tiến trình hoàn thành công việc",
            "Tiến trình bị lỗi"
          ],
          "correctAnswer": "Tiến trình bị tạm dừng vô hạn",
          "reason": "Deadlock xảy ra khi hai hoặc nhiều tiến trình chờ đợi tài nguyên mà các tiến trình khác đang nắm giữ, dẫn đến không tiến triển được."
        },
        {
          "id": 14,
          "question": "Tính chất nào sau đây của OOP cho phép một đối tượng có thể có nhiều hình thức?",
          "options": [
            "Đóng gói (Encapsulation)",
            "Kế thừa (Inheritance)",
            "Đa hình (Polymorphism)",
            "Trừu tượng (Abstraction)"
          ],
          "correctAnswer": "Đa hình (Polymorphism)",
          "reason": "Tính đa hình cho phép các đối tượng của các lớp khác nhau phản ứng khác nhau khi cùng một phương thức được gọi."
        },
        {
          "id": 15,
          "question": "Đâu là lỗi cú pháp trong đoạn mã Java sau:\n`int number = \"10\";`",
          "options": [
            "Sử dụng sai kiểu dữ liệu",
            "Thiếu dấu chấm phẩy",
            "Sử dụng sai tên biến",
            "Không có lỗi cú pháp"
          ],
          "correctAnswer": "Sử dụng sai kiểu dữ liệu",
          "reason": "Biến `number` được khai báo là kiểu `int`, nhưng lại được gán giá trị kiểu `String`."
        },
        {
          "id": 16,
          "question": "Lệnh SQL nào được sử dụng để thêm một cột vào bảng?",
          "options": [
            "CREATE TABLE",
            "ALTER TABLE",
            "DROP TABLE",
            "INSERT INTO"
          ],
          "correctAnswer": "ALTER TABLE",
          "reason": "Câu lệnh ALTER TABLE được sử dụng để thay đổi cấu trúc của bảng, bao gồm thêm, xóa, hoặc thay đổi cột."
        },
        {
          "id": 17,
          "question": "Trong quy trình phát triển phần mềm, kiểm thử nào tập trung vào việc kiểm tra từng đơn vị mã nguồn?",
          "options": [
            "Kiểm thử hệ thống",
            "Kiểm thử tích hợp",
            "Kiểm thử đơn vị",
            "Kiểm thử chấp nhận"
          ],
          "correctAnswer": "Kiểm thử đơn vị",
          "reason": "Kiểm thử đơn vị (Unit testing) tập trung vào việc kiểm tra các thành phần nhỏ nhất của phần mềm, thường là các hàm hoặc lớp."
        },
        {
          "id": 18,
          "question": "Gantt Chart thường được sử dụng trong quản lý dự án để làm gì?",
          "options": [
            "Quản lý rủi ro",
            "Lên lịch trình dự án",
            "Quản lý chi phí",
            "Phân công công việc"
          ],
          "correctAnswer": "Lên lịch trình dự án",
          "reason": "Gantt Chart hiển thị lịch trình dự án, bao gồm các công việc, thời gian bắt đầu, thời gian kết thúc, và sự phụ thuộc giữa các công việc."
        },
        {
          "id": 19,
          "question": "Địa chỉ MAC là gì?",
          "options": [
            "Địa chỉ logic của thiết bị",
            "Địa chỉ vật lý của thiết bị",
            "Địa chỉ IP của thiết bị",
            "Địa chỉ cổng của thiết bị"
          ],
          "correctAnswer": "Địa chỉ vật lý của thiết bị",
          "reason": "Địa chỉ MAC là một địa chỉ phần cứng duy nhất được gán cho mỗi thiết bị mạng."
        },
        {
          "id": 20,
          "question": "Cây nào sau đây được sử dụng để biểu diễn cấu trúc phân cấp?",
          "options": ["Heap", "Binary Search Tree", "Graph", "Linked list"],
          "correctAnswer": "Binary Search Tree",
          "reason": "Cây nhị phân tìm kiếm thường được sử dụng để biểu diễn dữ liệu theo cấu trúc phân cấp, cho phép tìm kiếm, chèn, xóa một cách hiệu quả."
        },
        {
          "id": 21,
          "question": "Trong kiến trúc máy tính, thuật ngữ 'hit rate' dùng để chỉ điều gì?",
          "options": [
            "Tỉ lệ truy cập thành công bộ nhớ cache",
            "Tỉ lệ truy cập thất bại bộ nhớ cache",
            "Tỉ lệ lỗi trang",
            "Tỉ lệ truy cập bộ nhớ chính"
          ],
          "correctAnswer": "Tỉ lệ truy cập thành công bộ nhớ cache",
          "reason": "'Hit rate' đo lường tỉ lệ số lần dữ liệu được tìm thấy trong bộ nhớ cache so với tổng số lần truy cập bộ nhớ."
        },
        {
          "id": 22,
          "question": "Thuật ngữ 'thrashing' trong hệ điều hành là gì?",
          "options": [
            "Hiện tượng trang bị hoán đổi liên tục",
            "Hiện tượng lỗi trang",
            "Hiện tượng tắc nghẽn",
            "Hiện tượng thiếu bộ nhớ"
          ],
          "correctAnswer": "Hiện tượng trang bị hoán đổi liên tục",
          "reason": "Thrashing xảy ra khi hệ thống dành quá nhiều thời gian để hoán đổi các trang bộ nhớ giữa RAM và đĩa, dẫn đến hiệu suất kém."
        },
        {
          "id": 23,
          "question": "Trong Java, 'interface' là gì?",
          "options": [
            "Một lớp trừu tượng",
            "Một lớp chứa các thuộc tính",
            "Một bản thiết kế cho lớp",
            "Một đối tượng"
          ],
          "correctAnswer": "Một bản thiết kế cho lớp",
          "reason": "Interface trong Java định nghĩa các phương thức mà các lớp thực hiện phải tuân theo, là một bản thiết kế cho lớp."
        },
        {
          "id": 24,
          "question": "Đâu là lỗi cú pháp trong đoạn mã SQL sau:\n `SELECT name FROM users WHERE age = 20`",
          "options": [
            "Thiếu dấu chấm phẩy",
            "Thiếu từ khóa FROM",
            "Thiếu điều kiện WHERE",
            "Không có lỗi cú pháp"
          ],
          "correctAnswer": "Không có lỗi cú pháp",
          "reason": "Câu lệnh này hoàn toàn đúng cú pháp SQL."
        },
        {
          "id": 25,
          "question": "Trong cơ sở dữ liệu, 'foreign key' dùng để làm gì?",
          "options": [
            "Khóa chính của bảng",
            "Khóa ngoài liên kết giữa các bảng",
            "Một chỉ mục của bảng",
            "Một ràng buộc trên cột"
          ],
          "correctAnswer": "Khóa ngoài liên kết giữa các bảng",
          "reason": "Khóa ngoại (foreign key) thiết lập mối quan hệ giữa các bảng, đảm bảo tính toàn vẹn tham chiếu."
        },
        {
          "id": 26,
          "question": "Trong kiểm thử phần mềm, kiểm thử hộp đen (black box testing) là gì?",
          "options": [
            "Kiểm thử dựa vào cấu trúc bên trong của mã",
            "Kiểm thử dựa vào đặc tả yêu cầu",
            "Kiểm thử tất cả các trường hợp",
            "Kiểm thử bởi người dùng cuối"
          ],
          "correctAnswer": "Kiểm thử dựa vào đặc tả yêu cầu",
          "reason": "Kiểm thử hộp đen chỉ tập trung vào chức năng của phần mềm, không cần biết đến cấu trúc bên trong."
        },
        {
          "id": 27,
          "question": "'Scope creep' trong quản lý dự án là gì?",
          "options": [
            "Sự chậm trễ của dự án",
            "Chi phí dự án tăng cao",
            "Sự thay đổi không kiểm soát của phạm vi dự án",
            "Rủi ro của dự án tăng lên"
          ],
          "correctAnswer": "Sự thay đổi không kiểm soát của phạm vi dự án",
          "reason": "'Scope creep' là tình trạng phạm vi dự án liên tục thay đổi, phát sinh thêm yêu cầu mới ngoài kế hoạch ban đầu."
        },
        {
          "id": 28,
          "question": "Giao thức nào được sử dụng để gửi email?",
          "options": ["HTTP", "FTP", "SMTP", "DNS"],
          "correctAnswer": "SMTP",
          "reason": "SMTP (Simple Mail Transfer Protocol) được sử dụng để gửi email."
        },
        {
          "id": 29,
          "question": "Thuật toán sắp xếp nào thường được sử dụng trong thực tế vì hiệu quả và tính ổn định của nó?",
          "options": [
            "Bubble sort",
            "Insertion Sort",
            "Merge Sort",
            "Selection Sort"
          ],
          "correctAnswer": "Merge Sort",
          "reason": "Merge Sort là một thuật toán sắp xếp hiệu quả và ổn định, thường được sử dụng trong thực tế."
        },
        {
          "id": 30,
          "question": "Trong Java, từ khóa `static` có nghĩa là gì?",
          "options": [
            "Một biến thuộc về đối tượng",
            "Một biến thuộc về lớp",
            "Một phương thức thuộc về đối tượng",
            "Một phương thức thuộc về một interface"
          ],
          "correctAnswer": "Một biến thuộc về lớp",
          "reason": "Trong Java, khi một biến hoặc phương thức được khai báo `static`, nó thuộc về lớp chứ không phải đối tượng."
        }
      ]
    },
    {
      "id": 9,
      "title": "Tổng hợp Kiến thức Khoa học Máy tính - Đề 3",
      "timeLimit": 3600,
      "questions": [
        {
          "id": 1,
          "question": "Giao thức nào sau đây hoạt động ở tầng Vận tải (Transport Layer) của mô hình OSI?",
          "options": ["IP", "TCP", "HTTP", "DNS"],
          "correctAnswer": "TCP",
          "reason": "TCP (Transmission Control Protocol) hoạt động ở tầng Vận tải, đảm bảo truyền dữ liệu tin cậy."
        },
        {
          "id": 2,
          "question": "Cấu trúc dữ liệu nào sau đây hoạt động theo nguyên tắc FIFO (First In, First Out)?",
          "options": ["Stack", "Queue", "Linked List", "Tree"],
          "correctAnswer": "Queue",
          "reason": "Queue hoạt động theo nguyên tắc FIFO, phần tử được thêm vào trước sẽ là phần tử được lấy ra trước."
        },
        {
          "id": 3,
          "question": "Bộ nhớ RAM là loại bộ nhớ gì?",
          "options": [
            "Bộ nhớ chỉ đọc (ROM)",
            "Bộ nhớ truy cập ngẫu nhiên (RAM)",
            "Bộ nhớ thứ cấp",
            "Bộ nhớ cache"
          ],
          "correctAnswer": "Bộ nhớ truy cập ngẫu nhiên (RAM)",
          "reason": "RAM (Random Access Memory) là bộ nhớ chính, có thể truy cập ngẫu nhiên và có tính chất tạm thời."
        },
        {
          "id": 4,
          "question": "Thuật toán lập lịch 'Round Robin' hoạt động như thế nào?",
          "options": [
            "Ưu tiên tiến trình đến trước",
            "Ưu tiên tiến trình có thời gian thực thi ngắn nhất",
            "Chia đều thời gian CPU cho các tiến trình",
            "Ưu tiên tiến trình có độ ưu tiên cao nhất"
          ],
          "correctAnswer": "Chia đều thời gian CPU cho các tiến trình",
          "reason": "Round Robin chia đều thời gian CPU cho các tiến trình trong một khoảng thời gian cố định."
        },
        {
          "id": 5,
          "question": "Khái niệm 'encapsulation' (đóng gói) trong lập trình hướng đối tượng là gì?",
          "options": [
            "Che giấu dữ liệu và phương thức của đối tượng",
            "Cho phép đối tượng được sử dụng lại",
            "Tạo ra nhiều đối tượng",
            "Phân chia chương trình thành các phần nhỏ"
          ],
          "correctAnswer": "Che giấu dữ liệu và phương thức của đối tượng",
          "reason": "Encapsulation là việc đóng gói dữ liệu và phương thức vào trong một đối tượng, đồng thời giới hạn truy cập từ bên ngoài."
        },
        {
          "id": 6,
          "question": "Đâu là lỗi cú pháp trong đoạn mã Java sau:\n`String message = 123;`",
          "options": [
            "Sử dụng sai kiểu dữ liệu",
            "Thiếu dấu chấm phẩy",
            "Sử dụng sai tên biến",
            "Không có lỗi cú pháp"
          ],
          "correctAnswer": "Sử dụng sai kiểu dữ liệu",
          "reason": "Biến `message` được khai báo là kiểu `String`, nhưng lại được gán giá trị kiểu `int`."
        },
        {
          "id": 7,
          "question": "Câu lệnh SQL nào dùng để xóa dữ liệu từ bảng?",
          "options": ["INSERT", "UPDATE", "SELECT", "DELETE"],
          "correctAnswer": "DELETE",
          "reason": "Câu lệnh DELETE dùng để xóa dữ liệu từ bảng."
        },
        {
          "id": 8,
          "question": "Mô hình phát triển phần mềm nào tập trung vào việc phân tích và thiết kế chi tiết trước khi bắt đầu viết code?",
          "options": [
            "Mô hình Agile",
            "Mô hình xoắn ốc",
            "Mô hình thác nước",
            "Mô hình V"
          ],
          "correctAnswer": "Mô hình thác nước",
          "reason": "Mô hình thác nước (Waterfall) là mô hình tuần tự, đi từ phân tích, thiết kế đến triển khai và kiểm thử."
        },
        {
          "id": 9,
          "question": "Công cụ nào được sử dụng để theo dõi và quản lý các lỗi (bug) trong quá trình phát triển phần mềm?",
          "options": ["Git", "Jira", "MS Project", "Trello"],
          "correctAnswer": "Jira",
          "reason": "Jira là một công cụ quản lý dự án và theo dõi lỗi phổ biến."
        },
        {
          "id": 10,
          "question": "Địa chỉ nào là địa chỉ Broadcast trong IPv4?",
          "options": [
            "192.168.1.0",
            "192.168.1.255",
            "192.168.1.1",
            "255.255.255.0"
          ],
          "correctAnswer": "192.168.1.255",
          "reason": "Địa chỉ broadcast thường có tất cả các bit host là 1."
        },
        {
          "id": 11,
          "question": "Thuật toán nào được dùng để duyệt cây theo chiều sâu?",
          "options": [
            "Breadth-First Search",
            "Depth-First Search",
            "Binary Search",
            "Linear Search"
          ],
          "correctAnswer": "Depth-First Search",
          "reason": "Depth-First Search (DFS) duyệt theo chiều sâu bằng cách đi đến con của một nút trước khi duyệt các nút cùng cấp."
        },
        {
          "id": 12,
          "question": "Trong kiến trúc máy tính, TLB là viết tắt của từ nào?",
          "options": [
            "Translation Lookaside Buffer",
            "Temporary Local Bus",
            "Time Local Buffer",
            "Transfer Logic Block"
          ],
          "correctAnswer": "Translation Lookaside Buffer",
          "reason": "TLB (Translation Lookaside Buffer) là một bộ nhớ cache đặc biệt dùng để tăng tốc độ chuyển đổi giữa địa chỉ ảo và địa chỉ vật lý."
        },
        {
          "id": 13,
          "question": "Thuật ngữ 'context switching' trong hệ điều hành nghĩa là gì?",
          "options": [
            "Chuyển đổi giữa các tiến trình",
            "Chuyển đổi giữa các luồng",
            "Chuyển đổi giữa các ổ đĩa",
            "Chuyển đổi giữa các bộ nhớ"
          ],
          "correctAnswer": "Chuyển đổi giữa các tiến trình",
          "reason": "Context switching là quá trình lưu trữ và khôi phục trạng thái của một tiến trình để chuyển sang tiến trình khác."
        },
        {
          "id": 14,
          "question": "Trong OOP, tính 'kế thừa' (Inheritance) cho phép làm gì?",
          "options": [
            "Tạo ra các đối tượng mới",
            "Truy cập vào các biến của lớp khác",
            "Một lớp kế thừa các thuộc tính và phương thức của một lớp khác",
            "Đóng gói dữ liệu"
          ],
          "correctAnswer": "Một lớp kế thừa các thuộc tính và phương thức của một lớp khác",
          "reason": "Inheritance cho phép một lớp (lớp con) kế thừa các thuộc tính và phương thức từ lớp khác (lớp cha), tái sử dụng code và thiết lập quan hệ phân cấp."
        },
        {
          "id": 15,
          "question": "Đâu là lỗi cú pháp trong đoạn mã Java sau:\n`int x = 10.5;`",
          "options": [
            "Sử dụng sai kiểu dữ liệu",
            "Thiếu dấu chấm phẩy",
            "Sử dụng sai tên biến",
            "Không có lỗi cú pháp"
          ],
          "correctAnswer": "Sử dụng sai kiểu dữ liệu",
          "reason": "Biến `x` được khai báo là kiểu `int`, nhưng lại được gán giá trị kiểu `double`."
        },
        {
          "id": 16,
          "question": "Lệnh SQL nào dùng để tạo một bảng mới?",
          "options": [
            "INSERT TABLE",
            "CREATE TABLE",
            "ALTER TABLE",
            "DROP TABLE"
          ],
          "correctAnswer": "CREATE TABLE",
          "reason": "Câu lệnh CREATE TABLE được sử dụng để tạo một bảng mới trong cơ sở dữ liệu."
        },
        {
          "id": 17,
          "question": "Trong kiểm thử phần mềm, kiểm thử tích hợp là gì?",
          "options": [
            "Kiểm thử từng đơn vị mã",
            "Kiểm thử các thành phần kết hợp với nhau",
            "Kiểm thử toàn bộ hệ thống",
            "Kiểm thử bởi người dùng"
          ],
          "correctAnswer": "Kiểm thử các thành phần kết hợp với nhau",
          "reason": "Kiểm thử tích hợp (Integration testing) kiểm tra sự tương tác giữa các thành phần của phần mềm."
        },
        {
          "id": 18,
          "question": "'Critical path' trong quản lý dự án là gì?",
          "options": [
            "Đường đi ngắn nhất của dự án",
            "Đường đi quan trọng nhất của dự án",
            "Đường đi có nhiều rủi ro",
            "Đường đi dự phòng của dự án"
          ],
          "correctAnswer": "Đường đi quan trọng nhất của dự án",
          "reason": "Đường găng (Critical path) là đường đi dài nhất qua các công việc của dự án, quyết định thời gian hoàn thành dự án."
        },
        {
          "id": 19,
          "question": "DNS là gì?",
          "options": [
            "Giao thức truyền file",
            "Giao thức định tuyến",
            "Hệ thống phân giải tên miền",
            "Giao thức gửi email"
          ],
          "correctAnswer": "Hệ thống phân giải tên miền",
          "reason": "DNS (Domain Name System) là hệ thống phân giải tên miền thành địa chỉ IP."
        },
        {
          "id": 20,
          "question": "Cấu trúc dữ liệu nào phù hợp để biểu diễn mối quan hệ đa-đa?",
          "options": ["Cây", "Đồ thị", "Stack", "Queue"],
          "correctAnswer": "Đồ thị",
          "reason": "Đồ thị (Graph) cho phép biểu diễn các mối quan hệ phức tạp giữa các đối tượng, bao gồm mối quan hệ đa-đa."
        },
        {
          "id": 21,
          "question": "Trong kiến trúc máy tính, 'cache coherence' nghĩa là gì?",
          "options": [
            "Sự đồng bộ dữ liệu giữa các bộ nhớ cache",
            "Sự không đồng bộ dữ liệu giữa các bộ nhớ cache",
            "Tốc độ của bộ nhớ cache",
            "Dung lượng của bộ nhớ cache"
          ],
          "correctAnswer": "Sự đồng bộ dữ liệu giữa các bộ nhớ cache",
          "reason": "Cache coherence đảm bảo rằng tất cả các bản sao của một khối dữ liệu trong các bộ nhớ cache khác nhau đều được đồng bộ."
        },
        {
          "id": 22,
          "question": "'Page fault' trong hệ điều hành là gì?",
          "options": [
            "Lỗi truy cập bộ nhớ cache",
            "Lỗi trang khi truy cập bộ nhớ ảo",
            "Lỗi truy cập vào một file",
            "Lỗi do thiếu bộ nhớ"
          ],
          "correctAnswer": "Lỗi trang khi truy cập bộ nhớ ảo",
          "reason": "Page fault xảy ra khi hệ điều hành không tìm thấy trang trong bộ nhớ chính mà phải nạp từ bộ nhớ phụ."
        },
        {
          "id": 23,
          "question": "Trong Java, từ khóa `final` có nghĩa là gì?",
          "options": [
            "Một biến không thể thay đổi giá trị",
            "Một phương thức không thể kế thừa",
            "Một lớp không thể kế thừa",
            "Một biến thuộc về lớp"
          ],
          "correctAnswer": "Một biến không thể thay đổi giá trị",
          "reason": "Khi biến được khai báo là `final`, nó là một hằng số và không thể thay đổi giá trị sau khi được gán."
        },
        {
          "id": 24,
          "question": "Đâu là lỗi cú pháp trong đoạn mã SQL sau:\n`INSERT INTO users (name, age) VALUE (\"John\", 30)`",
          "options": [
            "Thiếu dấu chấm phẩy",
            "Sai từ khóa VALUE",
            "Thiếu dấu ngoặc tròn",
            "Không có lỗi cú pháp"
          ],
          "correctAnswer": "Sai từ khóa VALUE",
          "reason": "Từ khóa phải là `VALUES` (số nhiều)."
        },
        {
          "id": 25,
          "question": "Trong cơ sở dữ liệu, 'index' (chỉ mục) có tác dụng gì?",
          "options": [
            "Tăng tốc độ truy vấn",
            "Giảm dung lượng lưu trữ",
            "Tăng độ phức tạp của truy vấn",
            "Giảm tính toàn vẹn dữ liệu"
          ],
          "correctAnswer": "Tăng tốc độ truy vấn",
          "reason": "Index giúp tăng tốc độ truy vấn bằng cách tạo ra một cấu trúc dữ liệu để tìm kiếm nhanh chóng."
        },
        {
          "id": 26,
          "question": "Trong kiểm thử phần mềm, kiểm thử hồi quy (regression testing) dùng để làm gì?",
          "options": [
            "Kiểm thử chức năng mới",
            "Kiểm thử các lỗi đã sửa",
            "Kiểm thử toàn bộ hệ thống",
            "Đảm bảo các thay đổi không gây ra lỗi mới"
          ],
          "correctAnswer": "Đảm bảo các thay đổi không gây ra lỗi mới",
          "reason": "Kiểm thử hồi quy (Regression testing) kiểm tra xem các thay đổi mới không làm ảnh hưởng đến các chức năng cũ."
        },
        {
          "id": 27,
          "question": "'Risk management' (quản lý rủi ro) trong quản lý dự án có vai trò gì?",
          "options": [
            "Xác định và phân tích rủi ro",
            "Phân công công việc",
            "Lên kế hoạch chi phí",
            "Đảm bảo dự án thành công"
          ],
          "correctAnswer": "Xác định và phân tích rủi ro",
          "reason": "Quản lý rủi ro là quá trình xác định, phân tích, và đưa ra các biện pháp đối phó với các rủi ro tiềm ẩn."
        },
        {
          "id": 28,
          "question": "Giao thức nào dùng để truy cập website?",
          "options": ["FTP", "SMTP", "HTTP", "DNS"],
          "correctAnswer": "HTTP",
          "reason": "HTTP (Hypertext Transfer Protocol) là giao thức dùng để truyền tải dữ liệu giữa client và server trên web."
        },
        {
          "id": 29,
          "question": "Độ phức tạp thời gian tốt nhất của thuật toán sắp xếp 'Insertion Sort' là bao nhiêu?",
          "options": ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"],
          "correctAnswer": "O(n)",
          "reason": "Trường hợp tốt nhất của Insertion Sort (khi mảng đã sắp xếp) là O(n)."
        },
        {
          "id": 30,
          "question": "Trong Java, từ khóa `this` được dùng để làm gì?",
          "options": [
            "Tham chiếu đến đối tượng hiện tại",
            "Tham chiếu đến lớp cha",
            "Tham chiếu đến biến toàn cục",
            "Tham chiếu đến biến địa phương"
          ],
          "correctAnswer": "Tham chiếu đến đối tượng hiện tại",
          "reason": "Từ khóa `this` trong Java tham chiếu đến đối tượng hiện tại mà phương thức đang được gọi."
        }
      ]
    },
    {
      "id": 10,
      "title": "Tổng hợp Kiến thức Khoa học Máy tính - Đề 4",
      "timeLimit": 3600,
      "questions": [
        {
          "id": 1,
          "question": "Giao thức nào được sử dụng để truyền file?",
          "options": ["HTTP", "FTP", "SMTP", "DNS"],
          "correctAnswer": "FTP",
          "reason": "FTP (File Transfer Protocol) được sử dụng để truyền tải các tập tin giữa máy tính."
        },
        {
          "id": 2,
          "question": "Độ phức tạp thời gian của thuật toán tìm kiếm tuyến tính (Linear Search) là bao nhiêu?",
          "options": ["O(1)", "O(log n)", "O(n)", "O(n^2)"],
          "correctAnswer": "O(n)",
          "reason": "Tìm kiếm tuyến tính duyệt qua từng phần tử, nên độ phức tạp là tuyến tính."
        },
        {
          "id": 3,
          "question": "Trong kiến trúc máy tính, bộ nhớ ROM dùng để làm gì?",
          "options": [
            "Lưu trữ dữ liệu tạm thời",
            "Lưu trữ chương trình khởi động",
            "Lưu trữ dữ liệu của người dùng",
            "Tăng tốc độ CPU"
          ],
          "correctAnswer": "Lưu trữ chương trình khởi động",
          "reason": "ROM (Read-Only Memory) được sử dụng để lưu trữ chương trình khởi động (BIOS) và các thông tin cơ bản khác."
        },
        {
          "id": 4,
          "question": "Trong hệ điều hành, 'paging' là gì?",
          "options": [
            "Một kỹ thuật quản lý bộ nhớ",
            "Một kỹ thuật lập lịch tiến trình",
            "Một kỹ thuật ảo hóa bộ nhớ",
            "Một kỹ thuật đồng bộ hóa"
          ],
          "correctAnswer": "Một kỹ thuật quản lý bộ nhớ",
          "reason": "Paging là kỹ thuật chia bộ nhớ thành các trang có kích thước bằng nhau để quản lý bộ nhớ."
        },
        {
          "id": 5,
          "question": "Trong OOP, 'abstraction' (trừu tượng) là gì?",
          "options": [
            "Ẩn chi tiết triển khai",
            "Tạo ra các đối tượng mới",
            "Đóng gói dữ liệu",
            "Kế thừa các thuộc tính"
          ],
          "correctAnswer": "Ẩn chi tiết triển khai",
          "reason": "Abstraction là việc ẩn chi tiết triển khai phức tạp, chỉ cho phép người dùng tương tác với giao diện đơn giản."
        },
        {
          "id": 6,
          "question": "Đâu là lỗi cú pháp trong đoạn mã Java sau:\n`if x = 10 {`",
          "options": [
            "Thiếu dấu ngoặc đơn",
            "Sử dụng sai dấu so sánh",
            "Thiếu dấu chấm phẩy",
            "Không có lỗi cú pháp"
          ],
          "correctAnswer": "Sử dụng sai dấu so sánh",
          "reason": "Trong Java, dấu so sánh bằng là `==`, không phải `=`."
        },
        {
          "id": 7,
          "question": "Câu lệnh SQL nào được sử dụng để cập nhật dữ liệu trong bảng?",
          "options": ["INSERT", "UPDATE", "SELECT", "DELETE"],
          "correctAnswer": "UPDATE",
          "reason": "Câu lệnh UPDATE được sử dụng để thay đổi dữ liệu đã có trong bảng."
        },
        {
          "id": 8,
          "question": "Trong mô hình phát triển phần mềm, 'Sprint' thường được sử dụng trong mô hình nào?",
          "options": [
            "Mô hình thác nước",
            "Mô hình xoắn ốc",
            "Mô hình Agile",
            "Mô hình V"
          ],
          "correctAnswer": "Mô hình Agile",
          "reason": "Sprint là một vòng lặp phát triển ngắn hạn trong mô hình Agile."
        },
        {
          "id": 9,
          "question": "Trong quản lý dự án, 'WBS' là gì?",
          "options": [
            "Work Breakdown Structure",
            "Workflow Building System",
            "Web Based System",
            "Wide Band System"
          ],
          "correctAnswer": "Work Breakdown Structure",
          "reason": "WBS (Work Breakdown Structure) là phương pháp phân chia dự án thành các phần nhỏ hơn, dễ quản lý hơn."
        },
        {
          "id": 10,
          "question": "Địa chỉ nào là địa chỉ lớp B trong IPv4?",
          "options": ["10.0.0.1", "172.16.0.1", "192.168.1.1", "224.0.0.1"],
          "correctAnswer": "172.16.0.1",
          "reason": "Địa chỉ lớp B có octet đầu tiên từ 128 đến 191."
        },
        {
          "id": 11,
          "question": "Cây nào sau đây có thể bị lệch (skewed tree) trong trường hợp xấu nhất?",
          "options": [
            "Cây AVL",
            "Cây nhị phân tìm kiếm (Binary Search Tree)",
            "Cây B",
            "Cây đỏ đen (Red-Black Tree)"
          ],
          "correctAnswer": "Cây nhị phân tìm kiếm (Binary Search Tree)",
          "reason": "Cây nhị phân tìm kiếm có thể trở thành cây lệch trong trường hợp các nút được chèn vào theo thứ tự tăng hoặc giảm dần."
        },
        {
          "id": 12,
          "question": "Trong kiến trúc máy tính, DMA là gì?",
          "options": [
            "Direct Memory Access",
            "Dynamic Memory Allocation",
            "Data Management Array",
            "Dual Mode Access"
          ],
          "correctAnswer": "Direct Memory Access",
          "reason": "DMA (Direct Memory Access) cho phép các thiết bị ngoại vi truy cập trực tiếp vào bộ nhớ mà không cần sự can thiệp của CPU."
        },
        {
          "id": 13,
          "question": "Thuật ngữ 'starvation' trong hệ điều hành có nghĩa là gì?",
          "options": [
            "Một tiến trình chiếm quá nhiều CPU",
            "Một tiến trình không được cấp tài nguyên",
            "Một tiến trình bị lỗi",
            "Một tiến trình bị treo"
          ],
          "correctAnswer": "Một tiến trình không được cấp tài nguyên",
          "reason": "Starvation xảy ra khi một tiến trình liên tục bị từ chối tài nguyên cần thiết để thực thi."
        },
        {
          "id": 14,
          "question": "Trong OOP, 'polymorphism' (đa hình) nghĩa là gì?",
          "options": [
            "Khả năng đóng gói dữ liệu",
            "Khả năng kế thừa thuộc tính",
            "Khả năng một đối tượng có nhiều hình thức",
            "Khả năng trừu tượng hóa dữ liệu"
          ],
          "correctAnswer": "Khả năng một đối tượng có nhiều hình thức",
          "reason": "Polymorphism cho phép một đối tượng có thể có nhiều hình thức, tùy thuộc vào lớp con kế thừa."
        },
        {
          "id": 15,
          "question": "Đâu là lỗi cú pháp trong đoạn mã Java sau:\n`for (int i = 0; i < 10;) {`",
          "options": [
            "Thiếu phần tăng biến",
            "Thiếu dấu chấm phẩy ở vòng lặp",
            "Sai cú pháp vòng lặp",
            "Không có lỗi cú pháp"
          ],
          "correctAnswer": "Thiếu phần tăng biến",
          "reason": "Vòng lặp `for` cần có đầy đủ 3 phần: khởi tạo, điều kiện, và tăng biến."
        },
        {
          "id": 16,
          "question": "Câu lệnh SQL nào dùng để xóa một bảng?",
          "options": [
            "DELETE TABLE",
            "DROP TABLE",
            "REMOVE TABLE",
            "ALTER TABLE"
          ],
          "correctAnswer": "DROP TABLE",
          "reason": "Câu lệnh DROP TABLE dùng để xóa toàn bộ bảng, bao gồm cả cấu trúc và dữ liệu."
        },
        {
          "id": 17,
          "question": "Trong kiểm thử phần mềm, kiểm thử hiệu năng (performance testing) dùng để làm gì?",
          "options": [
            "Kiểm tra chức năng",
            "Kiểm tra tốc độ và độ ổn định",
            "Kiểm tra giao diện",
            "Kiểm tra tính bảo mật"
          ],
          "correctAnswer": "Kiểm tra tốc độ và độ ổn định",
          "reason": "Kiểm thử hiệu năng (Performance testing) đo lường tốc độ và độ ổn định của hệ thống dưới các tải khác nhau."
        },
        {
          "id": 18,
          "question": "'Risk mitigation' (giảm thiểu rủi ro) trong quản lý dự án có nghĩa là gì?",
          "options": [
            "Tránh hoàn toàn rủi ro",
            "Chấp nhận rủi ro",
            "Giảm thiểu tác động của rủi ro",
            "Chuyển giao rủi ro"
          ],
          "correctAnswer": "Giảm thiểu tác động của rủi ro",
          "reason": "Giảm thiểu rủi ro (Risk mitigation) là việc thực hiện các biện pháp để giảm khả năng xảy ra hoặc tác động của rủi ro."
        },
        {
          "id": 19,
          "question": "NAT (Network Address Translation) là gì?",
          "options": [
            "Một giao thức định tuyến",
            "Một giao thức bảo mật",
            "Một phương pháp ánh xạ địa chỉ",
            "Một giao thức truyền tải dữ liệu"
          ],
          "correctAnswer": "Một phương pháp ánh xạ địa chỉ",
          "reason": "NAT (Network Address Translation) là phương pháp ánh xạ địa chỉ IP riêng sang địa chỉ IP công cộng."
        },
        {
          "id": 20,
          "question": "Cấu trúc dữ liệu nào được sử dụng để cài đặt bảng băm (hash table)?",
          "options": ["Linked List", "Tree", "Array", "Queue"],
          "correctAnswer": "Array",
          "reason": "Bảng băm (hash table) thường sử dụng mảng (array) để lưu trữ dữ liệu và sử dụng hàm băm để ánh xạ khóa đến vị trí trong mảng."
        },
        {
          "id": 21,
          "question": "Trong kiến trúc máy tính, 'locality of reference' nghĩa là gì?",
          "options": [
            "Dữ liệu được truy cập theo thứ tự",
            "Dữ liệu được truy cập ngẫu nhiên",
            "Dữ liệu có xu hướng tập trung",
            "Dữ liệu được lưu trữ gần CPU"
          ],
          "correctAnswer": "Dữ liệu có xu hướng tập trung",
          "reason": "Locality of reference là nguyên tắc mà chương trình có xu hướng truy cập các vùng dữ liệu gần nhau trong một khoảng thời gian ngắn."
        },
        {
          "id": 22,
          "question": "'Swapping' trong hệ điều hành là gì?",
          "options": [
            "Chuyển dữ liệu giữa bộ nhớ chính và bộ nhớ cache",
            "Chuyển dữ liệu giữa bộ nhớ chính và bộ nhớ ảo",
            "Chuyển dữ liệu giữa các tiến trình",
            "Chuyển dữ liệu giữa CPU và bộ nhớ"
          ],
          "correctAnswer": "Chuyển dữ liệu giữa bộ nhớ chính và bộ nhớ ảo",
          "reason": "Swapping là việc chuyển một tiến trình đang không hoạt động từ bộ nhớ chính sang bộ nhớ ảo."
        },
        {
          "id": 23,
          "question": "Trong Java, từ khóa `super` được dùng để làm gì?",
          "options": [
            "Tham chiếu đến đối tượng hiện tại",
            "Tham chiếu đến lớp cha",
            "Tham chiếu đến một biến static",
            "Tạo ra một đối tượng mới"
          ],
          "correctAnswer": "Tham chiếu đến lớp cha",
          "reason": "Từ khóa `super` trong Java được dùng để tham chiếu đến các thuộc tính và phương thức của lớp cha."
        },
        {
          "id": 24,
          "question": "Đâu là lỗi cú pháp trong đoạn mã SQL sau:\n`SELECT name, age FORM users;`",
          "options": [
            "Thiếu từ khóa WHERE",
            "Sai từ khóa FORM",
            "Thiếu dấu chấm phẩy",
            "Không có lỗi cú pháp"
          ],
          "correctAnswer": "Sai từ khóa FORM",
          "reason": "Từ khóa phải là `FROM`."
        },
        {
          "id": 25,
          "question": "Trong cơ sở dữ liệu, 'normalization' (chuẩn hóa) có mục đích gì?",
          "options": [
            "Tăng tốc độ truy vấn",
            "Giảm sự dư thừa dữ liệu",
            "Tăng độ phức tạp của truy vấn",
            "Giảm tính bảo mật"
          ],
          "correctAnswer": "Giảm sự dư thừa dữ liệu",
          "reason": "Normalization là quá trình tổ chức dữ liệu trong cơ sở dữ liệu để giảm sự dư thừa và đảm bảo tính toàn vẹn."
        },
        {
          "id": 26,
          "question": "Trong kiểm thử phần mềm, 'alpha testing' là gì?",
          "options": [
            "Kiểm thử bởi người dùng cuối",
            "Kiểm thử bởi nhà phát triển",
            "Kiểm thử tại môi trường của khách hàng",
            "Kiểm thử các chức năng mới"
          ],
          "correctAnswer": "Kiểm thử bởi nhà phát triển",
          "reason": "Alpha testing thường được thực hiện bởi đội ngũ phát triển để phát hiện các lỗi trước khi release cho khách hàng."
        },
        {
          "id": 27,
          "question": "'Project charter' (điều lệ dự án) có vai trò gì trong quản lý dự án?",
          "options": [
            "Xác định phạm vi dự án",
            "Lên kế hoạch chi tiết",
            "Phân công công việc",
            "Cung cấp thông tin cơ bản về dự án"
          ],
          "correctAnswer": "Cung cấp thông tin cơ bản về dự án",
          "reason": "Project charter cung cấp thông tin tổng quan về mục tiêu, phạm vi, các bên liên quan, và các thông tin quan trọng khác của dự án."
        },
        {
          "id": 28,
          "question": "Giao thức nào dùng để phân giải tên miền thành địa chỉ IP?",
          "options": ["HTTP", "SMTP", "DNS", "FTP"],
          "correctAnswer": "DNS",
          "reason": "DNS (Domain Name System) phân giải tên miền thành địa chỉ IP."
        },
        {
          "id": 29,
          "question": "Thuật toán sắp xếp nào có độ phức tạp thời gian trung bình là O(n^2)?",
          "options": ["Merge Sort", "Quick Sort", "Bubble Sort", "Heap Sort"],
          "correctAnswer": "Bubble Sort",
          "reason": "Bubble Sort có độ phức tạp thời gian trung bình là O(n^2)."
        },
        {
          "id": 30,
          "question": "Trong Java, từ khóa `abstract` được dùng để làm gì?",
          "options": [
            "Tạo ra một đối tượng mới",
            "Định nghĩa một phương thức không có nội dung",
            "Khai báo một biến không thể thay đổi",
            "Định nghĩa một lớp có thể được kế thừa"
          ],
          "correctAnswer": "Định nghĩa một phương thức không có nội dung",
          "reason": "Từ khóa `abstract` được sử dụng để khai báo một lớp hoặc phương thức trừu tượng (không có nội dung)."
        }
      ]
    },
    {
      "id": 11,
      "title": "Bài Kiểm Tra Cú Pháp Java Chuyên Sâu",
      "timeLimit": 3600,
      "questions": [
        {
          "id": 1,
          "question": "Những cách nào sau đây khai báo đúng một biến kiểu `long` và gán giá trị?",
          "options": [
            "long num = 10;",
            "long num = 10L;",
            "Long num = 10;",
            "Long num = 10l;"
          ],
          "correctAnswer": ["long num = 10L;", "Long num = 10l;"],
          "reason": "Để khai báo biến long, cần thêm 'L' hoặc 'l' ở cuối giá trị để chỉ định kiểu long. 'long num = 10' sẽ gây lỗi vì mặc định là kiểu int, trong khi `Long num = 10;` bị lỗi compile vì gán primitive int cho Wrapper object"
        },
        {
          "id": 2,
          "question": "Đâu là lỗi trong đoạn code sau? `char c = 'ab';`",
          "options": [
            "Lỗi ép kiểu",
            "Lỗi cú pháp",
            "Lỗi logic",
            "Không có lỗi"
          ],
          "correctAnswer": ["Lỗi cú pháp"],
          "reason": "Kiểu `char` chỉ chứa một ký tự. Để chứa một chuỗi, phải dùng kiểu `String`. Đây là lỗi cú pháp."
        },
        {
          "id": 3,
          "question": "Trong Java, cách nào khai báo đúng một biến boolean?",
          "options": [
            "boolean flag = 0;",
            "boolean flag = 'true';",
            "boolean flag = true;",
            "Boolean flag = true;"
          ],
          "correctAnswer": ["boolean flag = true;", "Boolean flag = true;"],
          "reason": "Kiểu `boolean` chỉ nhận giá trị `true` hoặc `false`. 'Boolean flag = true;' là khai báo một object Boolean, không phải primitive boolean"
        },
        {
          "id": 4,
          "question": "Đâu là lỗi cú pháp trong đoạn code sau? \n`public static void main(String[] args) {\n  int x = 10;\n  if (x = 5) {\n     System.out.println(\"x is 5\");\n  }\n}`",
          "options": [
            "Lỗi gán giá trị trong if",
            "Thiếu dấu ngoặc nhọn",
            "Sai vị trí khai báo biến",
            "Không có lỗi"
          ],
          "correctAnswer": ["Lỗi gán giá trị trong if"],
          "reason": "Lệnh `if` sử dụng `=` để gán giá trị thay vì `==` để so sánh. Đây là một lỗi cú pháp phổ biến."
        },
        {
          "id": 5,
          "question": "Những cách nào sau đây là hợp lệ để khai báo và khởi tạo một mảng các số nguyên?",
          "options": [
            "int[] arr = {1, 2, 3};",
            "int arr[] = new int[3]{1, 2, 3};",
            "int[] arr = new int[]{1, 2, 3};",
            "int arr[3] = {1, 2, 3};"
          ],
          "correctAnswer": [
            "int[] arr = {1, 2, 3};",
            "int[] arr = new int[]{1, 2, 3};"
          ],
          "reason": "Hai cách này là đúng để khai báo và khởi tạo mảng trong Java. Các cách khác có cú pháp không hợp lệ."
        },
        {
          "id": 6,
          "question": "Đâu là lỗi cú pháp trong đoạn code sau? `for (int i = 0, j = 10; i < j; i++; j--) { }`",
          "options": [
            "Lỗi khai báo nhiều biến trong for",
            "Lỗi tăng biến",
            "Lỗi điều kiện vòng lặp",
            "Không có lỗi"
          ],
          "correctAnswer": ["Lỗi khai báo nhiều biến trong for"],
          "reason": "Trong vòng lặp for, các biến phải được khai báo và khởi tạo riêng biệt, không được khai báo cùng lúc bằng dấu phẩy."
        },
        {
          "id": 7,
          "question": "Cách nào sau đây là đúng để gọi constructor của lớp cha trong constructor của lớp con?",
          "options": [
            "super.constructor()",
            "super()",
            "this.constructor()",
            "this()"
          ],
          "correctAnswer": ["super()"],
          "reason": "Từ khóa `super()` được sử dụng để gọi constructor của lớp cha."
        },
        {
          "id": 8,
          "question": "Những cách nào sau đây khai báo đúng một phương thức trừu tượng (abstract)?",
          "options": [
            "abstract void myMethod();",
            "void abstract myMethod();",
            "abstract public void myMethod(){}",
            "public abstract void myMethod();"
          ],
          "correctAnswer": [
            "abstract void myMethod();",
            "public abstract void myMethod();"
          ],
          "reason": "Từ khóa `abstract` phải được đặt trước kiểu trả về của phương thức và không được có phần thân."
        },
        {
          "id": 9,
          "question": "Đâu là lỗi trong đoạn code sau? \n`class MyClass {\n  private int x;\n  public void setX(Integer x) {\n     this.x = x;\n  }\n}`",
          "options": [
            "Lỗi ép kiểu",
            "Không có lỗi",
            "Lỗi tham số",
            "Lỗi modifier"
          ],
          "correctAnswer": ["Không có lỗi"],
          "reason": "Không có lỗi trong code trên, vì Integer là lớp Wrapper, Java tự động unboxing giá trị."
        },
        {
          "id": 10,
          "question": "Những cách nào sau đây là đúng để tạo một interface?",
          "options": [
            "class MyInterface{}",
            "interface MyInterface{}",
            "abstract class MyInterface{}",
            "public MyInterface{}"
          ],
          "correctAnswer": ["interface MyInterface{}"],
          "reason": "Từ khóa `interface` được dùng để khai báo một interface."
        },
        {
          "id": 11,
          "question": "Cách nào sau đây là đúng khi sử dụng từ khóa `this` trong Java?",
          "options": [
            "this.variable",
            "this()",
            "this.method()",
            "this= new MyClass()"
          ],
          "correctAnswer": ["this.variable", "this()", "this.method()"],
          "reason": "`this.variable` tham chiếu đến biến của đối tượng hiện tại, `this()` gọi constructor của lớp hiện tại, và `this.method()` gọi method của lớp hiện tại."
        },
        {
          "id": 12,
          "question": "Đâu là lỗi cú pháp trong đoạn code sau: \n`switch (day) {\n case 1:\n System.out.println(\"Monday\");\n case 2:\n System.out.println(\"Tuesday\");\n}`",
          "options": [
            "Thiếu dấu ngoặc nhọn",
            "Thiếu break",
            "Lỗi case",
            "Không có lỗi"
          ],
          "correctAnswer": ["Thiếu break"],
          "reason": "Thiếu từ khóa `break` sẽ làm cho các case tiếp theo cũng được thực thi (fall through)."
        },
        {
          "id": 13,
          "question": "Những từ khóa nào sau đây có thể dùng để bắt exception trong Java?",
          "options": ["try", "catch", "finally", "throw"],
          "correctAnswer": ["try", "catch", "finally"],
          "reason": "`try` bắt đầu khối code có thể ném ra exception, `catch` bắt exception, và `finally` thực thi sau khối try-catch."
        },
        {
          "id": 14,
          "question": "Đâu là lỗi trong đoạn code sau? \n`int x = 10;\nInteger y = x;\nString z = y;`",
          "options": [
            "Lỗi ép kiểu",
            "Lỗi khai báo",
            "Không có lỗi",
            "Lỗi modifier"
          ],
          "correctAnswer": ["Lỗi ép kiểu"],
          "reason": "Không thể gán trực tiếp kiểu `Integer` cho kiểu `String`."
        },
        {
          "id": 15,
          "question": "Những cách nào sau đây là hợp lệ để gọi một phương thức không static trong một lớp khác?",
          "options": [
            "ClassName.method()",
            "objectName.method()",
            "this.method()",
            "super.method()"
          ],
          "correctAnswer": ["objectName.method()"],
          "reason": "Phương thức không static cần phải được gọi thông qua một đối tượng của lớp đó."
        },
        {
          "id": 16,
          "question": "Đâu là lỗi trong khai báo enum sau: `enum Color { RED, BLUE, GREEN; }`",
          "options": [
            "Thiếu từ khóa public",
            "Không có lỗi",
            "Thiếu dấu phẩy",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": ["Không có lỗi"],
          "reason": "Khai báo enum trên hoàn toàn hợp lệ."
        },
        {
          "id": 17,
          "question": "Những cách nào sau đây đúng để khai báo một biến kiểu `float`?",
          "options": [
            "float num = 3.14;",
            "float num = 3.14f;",
            "Float num = 3.14;",
            "Float num = 3.14f;"
          ],
          "correctAnswer": ["float num = 3.14f;", "Float num = 3.14f;"],
          "reason": "Để khai báo biến float, cần thêm `f` hoặc `F` ở cuối số thực."
        },
        {
          "id": 18,
          "question": "Những cách nào sau đây có thể dùng để khai báo một lớp con kế thừa từ một lớp cha?",
          "options": [
            "class Child extends Parent {}",
            "class Child implements Parent {}",
            "class Parent extends Child {}",
            "class Child inherit Parent {}"
          ],
          "correctAnswer": ["class Child extends Parent {}"],
          "reason": "Từ khóa `extends` được dùng để kế thừa từ lớp cha."
        },
        {
          "id": 19,
          "question": "Đâu là lỗi cú pháp trong đoạn code sau:\n`int[] numbers = new int[5];\nfor (int i = 1; i <= numbers.length; i++) {\n  numbers[i] = i;\n}`",
          "options": [
            "Lỗi chỉ số mảng",
            "Lỗi vòng lặp for",
            "Lỗi ép kiểu",
            "Không có lỗi"
          ],
          "correctAnswer": ["Lỗi chỉ số mảng", "Lỗi vòng lặp for"],
          "reason": "Vòng lặp chạy từ `1` đến `numbers.length` nên sẽ gây lỗi `ArrayIndexOutOfBoundsException`, và gán vào mảng cũng không đúng, nên `i` không thể là chỉ số mà gán trực tiếp vào mảng."
        },
        {
          "id": 20,
          "question": "Những từ khóa nào sau đây được dùng để điều khiển truy cập trong Java?",
          "options": ["public", "private", "protected", "static", "final"],
          "correctAnswer": ["public", "private", "protected"],
          "reason": "Các access modifiers bao gồm: `public`, `private`, `protected`, và `default` (không khai báo)."
        },
        {
          "id": 21,
          "question": "Những cách nào sau đây là đúng để khởi tạo một đối tượng String với một giá trị ban đầu?",
          "options": [
            "String s = \"Hello\";",
            "String s = new String(\"Hello\");",
            "String s = new String('Hello');",
            "String s = 'Hello'"
          ],
          "correctAnswer": [
            "String s = \"Hello\";",
            "String s = new String(\"Hello\");"
          ],
          "reason": "Chuỗi trong Java dùng dấu nháy đôi hoặc new String()"
        },
        {
          "id": 22,
          "question": "Đâu là lỗi sai trong đoạn code sau? \n`int x = 10;\nx = null;`",
          "options": [
            "Lỗi gán null cho primitive",
            "Lỗi khai báo",
            "Lỗi ép kiểu",
            "Không có lỗi"
          ],
          "correctAnswer": ["Lỗi gán null cho primitive"],
          "reason": "Biến kiểu nguyên thủy `int` không thể gán giá trị `null`."
        },
        {
          "id": 23,
          "question": "Đâu là lỗi cú pháp khi khai báo một phương thức static trong Java?",
          "options": [
            "static public void myMethod(){}",
            "public static void myMethod(){}",
            "void public static myMethod()",
            "public void static myMethod()"
          ],
          "correctAnswer": [
            "static public void myMethod(){}",
            "public static void myMethod(){}"
          ],
          "reason": "Từ khóa `static` nên đặt trước kiểu trả về."
        },
        {
          "id": 24,
          "question": "Điều gì xảy ra nếu một phương thức không có giá trị trả về?",
          "options": [
            "Nó phải khai báo từ khóa `null`",
            "Nó phải khai báo từ khóa `void`",
            "Nó phải khai báo từ khóa `return`",
            "Nó không cần khai báo gì"
          ],
          "correctAnswer": ["Nó phải khai báo từ khóa `void`"],
          "reason": "Phương thức không trả về giá trị phải được khai báo với từ khóa `void`."
        },
        {
          "id": 25,
          "question": "Những cách nào sau đây thể hiện đúng cách ép kiểu dữ liệu trong Java?",
          "options": [
            "int x = (int) 3.14;",
            "Integer x = (Integer) 3.14;",
            "double y = (double) 10;",
            "String z = (String) 10;"
          ],
          "correctAnswer": ["int x = (int) 3.14;", "double y = (double) 10;"],
          "reason": "Đây là cú pháp ép kiểu cơ bản."
        },
        {
          "id": 26,
          "question": "Đâu là lỗi trong khai báo enum sau: `enum Status { ACTIVE = 1, INACTIVE = 0;}`",
          "options": [
            "Lỗi gán giá trị cho enum",
            "Không có lỗi",
            "Lỗi cú pháp",
            "Lỗi modifier"
          ],
          "correctAnswer": ["Lỗi gán giá trị cho enum"],
          "reason": "Enum không gán trực tiếp giá trị, mà gán giá trị ngầm định theo thứ tự."
        },
        {
          "id": 27,
          "question": "Trong Java, cách nào sau đây tạo ra một đối tượng từ lớp cha trong lớp con",
          "options": [
            "parent p = new parent()",
            "super = new parent()",
            "this = new parent()",
            "super()"
          ],
          "correctAnswer": ["super()"],
          "reason": "Từ khóa `super()` gọi constructor của lớp cha từ constructor của lớp con."
        },
        {
          "id": 28,
          "question": "Đâu là lỗi cú pháp trong đoạn code sau? \n `class MyClass {\n  public MyClass(int x) { }\n  public MyClass() { }\n}`",
          "options": [
            "Lỗi constructor trùng tên",
            "Không có lỗi",
            "Lỗi khai báo",
            "Lỗi modifier"
          ],
          "correctAnswer": ["Không có lỗi"],
          "reason": "Nạp chồng constructor là hoàn toàn hợp lệ."
        },
        {
          "id": 29,
          "question": "Đâu là lỗi cú pháp trong khai báo mảng sau: `int arr = new int[5];`",
          "options": [
            "Lỗi khai báo",
            "Không có lỗi",
            "Lỗi ép kiểu",
            "Lỗi truy cập"
          ],
          "correctAnswer": ["Lỗi khai báo"],
          "reason": "Khai báo mảng phải có dấu [] như `int[] arr`. "
        },
        {
          "id": 30,
          "question": "Điều gì xảy ra nếu bạn khai báo một biến cục bộ trùng tên với một biến thành viên (instance variable) trong Java?",
          "options": [
            "Lỗi compile",
            "Biến cục bộ sẽ che biến thành viên",
            "Biến thành viên bị thay đổi",
            "Chương trình sẽ treo"
          ],
          "correctAnswer": ["Biến cục bộ sẽ che biến thành viên"],
          "reason": "Biến cục bộ sẽ được ưu tiên sử dụng hơn và che đi biến thành viên trong phạm vi của phương thức đó."
        }
      ]
    },
    {
      "id": 12,
      "title": "Bài Kiểm Tra Toàn Diện Java - 50 Câu Hỏi",
      "timeLimit": 5400,
      "questions": [
        {
          "id": 1,
          "question": "Những phát biểu nào sau đây là đúng về biến instance trong Java?",
          "options": [
            "Được khai báo bên trong một phương thức",
            "Được khai báo bên ngoài bất kỳ phương thức nào",
            "Thuộc về một đối tượng cụ thể",
            "Thuộc về lớp",
            "Có thể được truy cập trực tiếp từ một phương thức static"
          ],
          "correctAnswer": [
            "Được khai báo bên ngoài bất kỳ phương thức nào",
            "Thuộc về một đối tượng cụ thể"
          ],
          "reason": "Biến instance (biến thành viên) được khai báo bên ngoài bất kỳ phương thức nào và thuộc về một đối tượng cụ thể của lớp. Chúng không thể được truy cập trực tiếp từ phương thức static."
        },
        {
          "id": 2,
          "question": "Kết quả của đoạn code sau là gì? `int x = 5; int y = x++; System.out.println(x + \" \" + y);`",
          "options": ["5 5", "6 6", "6 5", "5 6"],
          "correctAnswer": ["6 5"],
          "reason": "Toán tử `++` hậu tố (postfix) sẽ trả về giá trị của `x` trước, sau đó mới tăng `x` lên 1. Do đó, `y` sẽ nhận giá trị 5, và sau đó `x` tăng lên 6."
        },
        {
          "id": 3,
          "question": "Những từ khóa nào sau đây liên quan đến xử lý ngoại lệ (exception handling) trong Java?",
          "options": [
            "try",
            "catch",
            "throw",
            "throws",
            "final",
            "finally",
            "exception"
          ],
          "correctAnswer": ["try", "catch", "throw", "throws", "finally"],
          "reason": "`try` chứa mã có thể gây ra ngoại lệ, `catch` xử lý ngoại lệ, `throw` ném ra ngoại lệ, `throws` khai báo phương thức có thể ném ra ngoại lệ, và `finally` chứa mã luôn được thực thi."
        },
        {
          "id": 4,
          "question": "Đâu là cách khai báo và khởi tạo một hằng số trong Java?",
          "options": [
            "const int MAX_VALUE = 100;",
            "final int MAX_VALUE = 100;",
            "static final int MAX_VALUE = 100;",
            "int MAX_VALUE = 100;"
          ],
          "correctAnswer": [
            "final int MAX_VALUE = 100;",
            "static final int MAX_VALUE = 100;"
          ],
          "reason": "Từ khóa `final` được sử dụng để khai báo hằng số. `static final` thường được dùng cho các hằng số chung của lớp."
        },
        {
          "id": 5,
          "question": "Lớp Object trong Java là gì?",
          "options": [
            "Là lớp cơ sở của tất cả các lớp",
            "Là một lớp trừu tượng",
            "Là một interface",
            "Là một lớp final"
          ],
          "correctAnswer": ["Là lớp cơ sở của tất cả các lớp"],
          "reason": "Trong Java, tất cả các lớp đều trực tiếp hoặc gián tiếp kế thừa từ lớp `Object`."
        },
        {
          "id": 6,
          "question": "Interface trong Java là gì?",
          "options": [
            "Là một bản thiết kế cho các lớp",
            "Chứa các phương thức trừu tượng",
            "Có thể chứa các phương thức cụ thể",
            "Có thể chứa các biến instance",
            "Một lớp có thể implement nhiều interface"
          ],
          "correctAnswer": [
            "Là một bản thiết kế cho các lớp",
            "Chứa các phương thức trừu tượng",
            "Có thể chứa các phương thức cụ thể",
            "Một lớp có thể implement nhiều interface"
          ],
          "reason": "Interface định nghĩa các phương thức mà các lớp implement nó phải cung cấp. Từ Java 8, interface có thể chứa các phương thức default (cụ thể). Một lớp có thể implement nhiều interface."
        },
        {
          "id": 7,
          "question": "Từ khóa `static` trong Java có ý nghĩa gì?",
          "options": [
            "Biến/phương thức thuộc về lớp",
            "Biến/phương thức thuộc về đối tượng",
            "Biến/phương thức không thể thay đổi",
            "Biến/phương thức chỉ có thể được truy cập trong cùng một package"
          ],
          "correctAnswer": ["Biến/phương thức thuộc về lớp"],
          "reason": "Khi một thành viên (biến hoặc phương thức) được khai báo là `static`, nó thuộc về lớp chứ không phải đối tượng cụ thể."
        },
        {
          "id": 8,
          "question": "Những phát biểu nào sau đây là đúng về constructor trong Java?",
          "options": [
            "Constructor có cùng tên với lớp",
            "Constructor không có kiểu trả về",
            "Constructor có thể được gọi trực tiếp",
            "Một lớp có thể có nhiều constructor",
            "Constructor được gọi khi một đối tượng được tạo"
          ],
          "correctAnswer": [
            "Constructor có cùng tên với lớp",
            "Constructor không có kiểu trả về",
            "Một lớp có thể có nhiều constructor",
            "Constructor được gọi khi một đối tượng được tạo"
          ],
          "reason": "Constructor là một phương thức đặc biệt dùng để khởi tạo đối tượng, có cùng tên với lớp, không có kiểu trả về và được gọi tự động khi đối tượng được tạo. Một lớp có thể có nhiều constructor (nạp chồng constructor)."
        },
        {
          "id": 9,
          "question": "Đâu là cách đúng để so sánh hai chuỗi trong Java?",
          "options": [
            "s1 == s2",
            "s1.equals(s2)",
            "s1.compareTo(s2)",
            "s1.equalsIgnoreCase(s2)",
            "s1.compare(s2)"
          ],
          "correctAnswer": [
            "s1.equals(s2)",
            "s1.compareTo(s2)",
            "s1.equalsIgnoreCase(s2)"
          ],
          "reason": "`equals()` so sánh nội dung của hai chuỗi, `compareTo()` so sánh thứ tự từ điển, và `equalsIgnoreCase()` so sánh không phân biệt hoa thường. `==` so sánh tham chiếu của hai đối tượng."
        },
        {
          "id": 10,
          "question": "Những phát biểu nào sau đây là đúng về `ArrayList` trong Java?",
          "options": [
            "Là một mảng động",
            "Có thể chứa các phần tử có kiểu dữ liệu khác nhau",
            "Kích thước cố định",
            "Truy cập phần tử bằng chỉ số",
            "Là một lớp implement interface `List`"
          ],
          "correctAnswer": [
            "Là một mảng động",
            "Truy cập phần tử bằng chỉ số",
            "Là một lớp implement interface `List`"
          ],
          "reason": "`ArrayList` là một mảng động, có thể thay đổi kích thước. Nó là một generic class, chỉ cho phép chứa các phần tử cùng kiểu dữ liệu và truy cập các phần tử bằng chỉ số. `ArrayList` implement interface `List`."
        },
        {
          "id": 11,
          "question": "Phạm vi truy cập `protected` cho phép truy cập từ đâu?",
          "options": [
            "Trong cùng một lớp",
            "Trong cùng package",
            "Từ các lớp con (subclass) trong các package khác",
            "Từ bất kỳ đâu"
          ],
          "correctAnswer": [
            "Trong cùng một lớp",
            "Trong cùng package",
            "Từ các lớp con (subclass) trong các package khác"
          ],
          "reason": "Thành viên `protected` có thể được truy cập từ cùng một lớp, cùng package, và từ các lớp con của nó, kể cả khi các lớp con đó nằm ở package khác."
        },
        {
          "id": 12,
          "question": "Đâu là các cách đúng để khởi tạo một mảng trong Java?",
          "options": [
            "int[] arr = new int[5];",
            "int arr[] = new int[5];",
            "int[] arr = {1, 2, 3, 4, 5};",
            "int arr[5] = {1, 2, 3, 4, 5};",
            "int[] arr = new int[]{1,2,3};"
          ],
          "correctAnswer": [
            "int[] arr = new int[5];",
            "int arr[] = new int[5];",
            "int[] arr = {1, 2, 3, 4, 5};",
            "int[] arr = new int[]{1,2,3};"
          ],
          "reason": "Tất cả các phương án trên đều đúng cú pháp để khai báo và khởi tạo mảng, trừ `int arr[5] = {1, 2, 3, 4, 5};`. Phương án cuối cùng là khai báo theo kiểu C/C++, không hợp lệ trong Java."
        },
        {
          "id": 13,
          "question": "Từ khóa `final` trong Java có ý nghĩa gì?",
          "options": [
            "Một biến không thể thay đổi giá trị",
            "Một phương thức không thể bị override",
            "Một lớp không thể kế thừa",
            "Một đối tượng không thể bị xóa"
          ],
          "correctAnswer": [
            "Một biến không thể thay đổi giá trị",
            "Một phương thức không thể bị override",
            "Một lớp không thể kế thừa"
          ],
          "reason": "`final` có thể được áp dụng cho biến (để tạo hằng số), phương thức (để ngăn chặn overriding), và lớp (để ngăn chặn kế thừa)."
        },
        {
          "id": 14,
          "question": "Kiểu dữ liệu nào sau đây không phải là kiểu nguyên thủy (primitive) trong Java?",
          "options": ["int", "float", "boolean", "String", "char"],
          "correctAnswer": ["String"],
          "reason": "`String` là một lớp trong Java, không phải là kiểu dữ liệu nguyên thủy."
        },
        {
          "id": 15,
          "question": "Đâu là cú pháp đúng của vòng lặp `for-each` trong Java?",
          "options": [
            "for (int i : arr) {}",
            "for (arr : int i) {}",
            "foreach (int i in arr) {}",
            "for (int i = 0; i < arr.length; i++) {}"
          ],
          "correctAnswer": ["for (int i : arr) {}"],
          "reason": "Vòng lặp `for-each` có cú pháp `for (ElementType element : collection)`."
        },
        {
          "id": 16,
          "question": "Đoạn code sau sẽ in ra kết quả gì? `String s = \"Hello\"; s.concat(\" World\"); System.out.println(s);`",
          "options": ["Hello", "Hello World", "World", "Lỗi biên dịch"],
          "correctAnswer": ["Hello"],
          "reason": "Phương thức `concat()` tạo ra một chuỗi mới, nhưng không thay đổi chuỗi ban đầu. Do đó, `s` vẫn giữ nguyên giá trị \"Hello\"."
        },
        {
          "id": 17,
          "question": "Những phát biểu nào sau đây là đúng về `HashMap` trong Java?",
          "options": [
            "Lưu trữ các cặp key-value",
            "Các key phải là duy nhất",
            "Thứ tự các phần tử được bảo toàn",
            "Cho phép key có giá trị null",
            "Cho phép value có giá trị null"
          ],
          "correctAnswer": [
            "Lưu trữ các cặp key-value",
            "Các key phải là duy nhất",
            "Cho phép key có giá trị null",
            "Cho phép value có giá trị null"
          ],
          "reason": "`HashMap` lưu trữ dữ liệu dưới dạng các cặp key-value, trong đó các key phải là duy nhất. `HashMap` không đảm bảo thứ tự các phần tử và cho phép một key null và nhiều value null."
        },
        {
          "id": 18,
          "question": "Đâu là đầu ra của đoạn code sau? `int x = 10; System.out.println(x > 5 ? \"x > 5\" : \"x <= 5\");`",
          "options": ["x > 5", "x <= 5", "10", "Lỗi biên dịch"],
          "correctAnswer": ["x > 5"],
          "reason": "Đây là toán tử điều kiện (ternary operator). Vì `x > 5` là đúng, nên biểu thức trả về \"x > 5\"."
        },
        {
          "id": 19,
          "question": "Những phát biểu nào sau đây là đúng về kế thừa (inheritance) trong Java?",
          "options": [
            "Một lớp con kế thừa tất cả các thành viên của lớp cha",
            "Một lớp con có thể ghi đè (override) các phương thức của lớp cha",
            "Một lớp con có thể truy cập trực tiếp các thành viên private của lớp cha",
            "Một lớp chỉ có thể kế thừa từ một lớp duy nhất",
            "Từ khóa `extends` được sử dụng để chỉ định lớp cha"
          ],
          "correctAnswer": [
            "Một lớp con có thể ghi đè (override) các phương thức của lớp cha",
            "Một lớp chỉ có thể kế thừa từ một lớp duy nhất",
            "Từ khóa `extends` được sử dụng để chỉ định lớp cha"
          ],
          "reason": "Một lớp con kế thừa các thành viên public và protected của lớp cha, nhưng không kế thừa các thành viên private. Lớp con có thể ghi đè các phương thức của lớp cha. Java không hỗ trợ đa kế thừa, một lớp chỉ có thể kế thừa từ một lớp duy nhất. Từ khóa `extends` được sử dụng để chỉ định lớp cha."
        },
        {
          "id": 20,
          "question": "Làm thế nào để tạo một luồng (thread) mới trong Java?",
          "options": [
            "Kế thừa từ lớp `Thread` và override phương thức `run()`",
            "Implement interface `Runnable` và override phương thức `run()`",
            "Sử dụng lớp `ThreadFactory`",
            "Gọi phương thức `start()` của lớp `Thread`"
          ],
          "correctAnswer": [
            "Kế thừa từ lớp `Thread` và override phương thức `run()`",
            "Implement interface `Runnable` và override phương thức `run()`"
          ],
          "reason": "Có hai cách chính để tạo luồng: kế thừa từ lớp `Thread` hoặc implement interface `Runnable`. Sau đó, cần override phương thức `run()` để chứa mã thực thi của luồng. Để bắt đầu luồng, gọi phương thức `start()`."
        },
        {
          "id": 21,
          "question": "Những từ khóa nào sau đây có thể được sử dụng với biến trong Java?",
          "options": [
            "public",
            "private",
            "protected",
            "static",
            "final",
            "abstract",
            "transient",
            "volatile"
          ],
          "correctAnswer": [
            "public",
            "private",
            "protected",
            "static",
            "final",
            "transient",
            "volatile"
          ],
          "reason": "Đây là các access modifiers và non-access modifiers có thể được sử dụng với biến trong Java."
        },
        {
          "id": 22,
          "question": "Đâu là các cách đúng để khai báo một mảng hai chiều trong Java?",
          "options": [
            "int[][] arr = new int[3][4];",
            "int arr[][] = new int[3][4];",
            "int[] arr[] = new int[3][4];",
            "int[][] arr = new int[3][];",
            "int[][] arr = new int[][4];"
          ],
          "correctAnswer": [
            "int[][] arr = new int[3][4];",
            "int arr[][] = new int[3][4];",
            "int[] arr[] = new int[3][4];",
            "int[][] arr = new int[3][];"
          ],
          "reason": "Tất cả các phương án trên đều đúng cú pháp để khai báo mảng hai chiều, trừ `int[][] arr = new int[][4];`. Phương án cuối cùng thiếu chỉ định số hàng."
        },
        {
          "id": 23,
          "question": "Những phát biểu nào sau đây là đúng về `StringBuilder` trong Java?",
          "options": [
            "Là một lớp immutable",
            "Là một lớp mutable",
            "Hiệu quả hơn `String` khi thực hiện nhiều thao tác nối chuỗi",
            "Không an toàn cho luồng (not thread-safe)"
          ],
          "correctAnswer": [
            "Là một lớp mutable",
            "Hiệu quả hơn `String` khi thực hiện nhiều thao tác nối chuỗi",
            "Không an toàn cho luồng (not thread-safe)"
          ],
          "reason": "`StringBuilder` là một lớp mutable, cho phép thay đổi nội dung của chuỗi. Nó hiệu quả hơn `String` khi cần thực hiện nhiều thao tác nối chuỗi. `StringBuilder` không an toàn cho luồng, trong khi `StringBuffer` là phiên bản thread-safe."
        },
        {
          "id": 24,
          "question": "Đâu là đầu ra của đoạn code sau? `int x = 5; int y = x-- * 2; System.out.println(x + \" \" + y);`",
          "options": ["4 10", "4 8", "5 10", "5 8"],
          "correctAnswer": ["4 10"],
          "reason": "Toán tử `--` hậu tố (postfix) sẽ trả về giá trị của `x` trước (5), sau đó mới giảm `x` xuống 1. Do đó, `y` sẽ nhận giá trị 5 * 2 = 10, và sau đó `x` giảm xuống 4."
        },
        {
          "id": 25,
          "question": "Làm thế nào để đọc dữ liệu từ file trong Java?",
          "options": [
            "Sử dụng lớp `FileReader`",
            "Sử dụng lớp `BufferedReader`",
            "Sử dụng lớp `Scanner`",
            "Sử dụng lớp `FileInputStream`",
            "Sử dụng lớp `File`"
          ],
          "correctAnswer": [
            "Sử dụng lớp `FileReader`",
            "Sử dụng lớp `BufferedReader`",
            "Sử dụng lớp `Scanner`",
            "Sử dụng lớp `FileInputStream`"
          ],
          "reason": "Có nhiều cách để đọc dữ liệu từ file trong Java. `FileReader` và `BufferedReader` thường được sử dụng để đọc file text, `Scanner` có thể đọc nhiều kiểu dữ liệu khác nhau từ file, và `FileInputStream` được sử dụng để đọc file dạng byte."
        },
        {
          "id": 26,
          "question": "Những phát biểu nào sau đây là đúng về `HashSet` trong Java?",
          "options": [
            "Lưu trữ các phần tử theo thứ tự",
            "Cho phép các phần tử trùng lặp",
            "Không cho phép các phần tử trùng lặp",
            "Truy cập phần tử bằng chỉ số",
            "Là một lớp implement interface `Set`"
          ],
          "correctAnswer": [
            "Không cho phép các phần tử trùng lặp",
            "Là một lớp implement interface `Set`"
          ],
          "reason": "`HashSet` không đảm bảo thứ tự các phần tử và không cho phép các phần tử trùng lặp. Nó implement interface `Set`."
        },
        {
          "id": 27,
          "question": "Đâu là các cách đúng để khai báo và khởi tạo một `ArrayList` chứa các số nguyên trong Java?",
          "options": [
            "ArrayList<int> list = new ArrayList<>();",
            "ArrayList<Integer> list = new ArrayList<>();",
            "List<Integer> list = new ArrayList<>();",
            "ArrayList list = new ArrayList();"
          ],
          "correctAnswer": [
            "ArrayList<Integer> list = new ArrayList<>();",
            "List<Integer> list = new ArrayList<>();"
          ],
          "reason": "`ArrayList` là generic class, nên cần chỉ định kiểu dữ liệu của các phần tử. `ArrayList<int>` là sai vì `int` là kiểu nguyên thủy, cần sử dụng lớp wrapper `Integer`. Nên khai báo kiểu interface `List` thay vì `ArrayList`."
        },
        {
          "id": 28,
          "question": "Làm thế nào để ghi dữ liệu vào file trong Java?",
          "options": [
            "Sử dụng lớp `FileWriter`",
            "Sử dụng lớp `BufferedWriter`",
            "Sử dụng lớp `PrintWriter`",
            "Sử dụng lớp `FileOutputStream`",
            "Sử dụng lớp `File`"
          ],
          "correctAnswer": [
            "Sử dụng lớp `FileWriter`",
            "Sử dụng lớp `BufferedWriter`",
            "Sử dụng lớp `PrintWriter`",
            "Sử dụng lớp `FileOutputStream`"
          ],
          "reason": "Có nhiều cách để ghi dữ liệu vào file trong Java. `FileWriter` và `BufferedWriter` thường được sử dụng để ghi file text, `PrintWriter` cung cấp các phương thức tiện lợi để ghi nhiều kiểu dữ liệu, và `FileOutputStream` được sử dụng để ghi file dạng byte."
        },
        {
          "id": 29,
          "question": "Đâu là đầu ra của đoạn code sau? `int x = 1; int y = 2; int z = x++ + ++y; System.out.println(x + \" \" + y + \" \" + z);`",
          "options": ["2 3 4", "1 3 3", "2 2 3", "1 2 4"],
          "correctAnswer": ["2 3 4"],
          "reason": "`x++` trả về giá trị của `x` trước (1), sau đó mới tăng `x` lên 2. `++y` tăng `y` lên 3 trước, sau đó trả về giá trị 3. Do đó, `z` sẽ nhận giá trị 1 + 3 = 4."
        },
        {
          "id": 30,
          "question": "Những phát biểu nào sau đây là đúng về `LinkedList` trong Java?",
          "options": [
            "Lưu trữ các phần tử trong các ô nhớ liên tiếp",
            "Truy cập phần tử bằng chỉ số chậm hơn `ArrayList`",
            "Chèn và xóa phần tử nhanh hơn `ArrayList`",
            "Là một lớp implement interface `List`",
            "Là một lớp implement interface `Queue`"
          ],
          "correctAnswer": [
            "Truy cập phần tử bằng chỉ số chậm hơn `ArrayList`",
            "Chèn và xóa phần tử nhanh hơn `ArrayList`",
            "Là một lớp implement interface `List`",
            "Là một lớp implement interface `Queue`"
          ],
          "reason": "`LinkedList` lưu trữ các phần tử trong các nút (node) được liên kết với nhau, không liên tiếp trong bộ nhớ. Do đó, việc truy cập phần tử bằng chỉ số chậm hơn `ArrayList`, nhưng việc chèn và xóa phần tử nhanh hơn. `LinkedList` implement cả interface `List` và `Queue`."
        },
        {
          "id": 31,
          "question": "Làm thế nào để chuyển đổi một chuỗi sang số nguyên trong Java?",
          "options": [
            "Sử dụng phương thức `parseInt()` của lớp `Integer`",
            "Sử dụng phương thức `valueOf()` của lớp `Integer`",
            "Sử dụng phương thức `parseInt()` của lớp `String`",
            "Ép kiểu trực tiếp"
          ],
          "correctAnswer": [
            "Sử dụng phương thức `parseInt()` của lớp `Integer`",
            "Sử dụng phương thức `valueOf()` của lớp `Integer`"
          ],
          "reason": "Phương thức `parseInt()` của lớp `Integer` trả về kiểu `int`, trong khi phương thức `valueOf()` trả về đối tượng `Integer`. Không thể ép kiểu trực tiếp một chuỗi sang số nguyên."
        },
        {
          "id": 32,
          "question": "Đâu là kết quả của đoạn code sau? `int x = 5; if (x > 3) { System.out.print(\"A\"); } else if (x > 4) { System.out.print(\"B\"); } else { System.out.print(\"C\"); }`",
          "options": ["A", "AB", "AC", "ABC"],
          "correctAnswer": ["A"],
          "reason": "Vì điều kiện `x > 3` là đúng, nên chỉ có khối lệnh đầu tiên được thực thi và in ra \"A\". Các khối lệnh `else if` và `else` không được thực thi."
        },
        {
          "id": 33,
          "question": "Những phát biểu nào sau đây là đúng về `abstract class` (lớp trừu tượng) trong Java?",
          "options": [
            "Có thể chứa các phương thức trừu tượng",
            "Có thể chứa các phương thức cụ thể",
            "Có thể được khởi tạo trực tiếp",
            "Một lớp có thể kế thừa từ nhiều abstract class",
            "Phải có từ khóa `abstract` trong khai báo"
          ],
          "correctAnswer": [
            "Có thể chứa các phương thức trừu tượng",
            "Có thể chứa các phương thức cụ thể",
            "Phải có từ khóa `abstract` trong khai báo"
          ],
          "reason": "Abstract class có thể chứa cả phương thức trừu tượng và phương thức cụ thể. Nó không thể được khởi tạo trực tiếp, mà phải thông qua lớp con. Một lớp chỉ có thể kế thừa từ một abstract class duy nhất. Abstract class phải có từ khóa `abstract` trong khai báo."
        },
        {
          "id": 34,
          "question": "Đâu là cách đúng để khai báo một phương thức có thể ném ra ngoại lệ `IOException`?",
          "options": [
            "public void myMethod() throws IOException {}",
            "public void myMethod() throw IOException {}",
            "public void myMethod() catch IOException {}",
            "public void myMethod() try IOException {}"
          ],
          "correctAnswer": ["public void myMethod() throws IOException {}"],
          "reason": "Từ khóa `throws` được sử dụng trong khai báo phương thức để chỉ định các loại ngoại lệ mà phương thức đó có thể ném ra."
        },
        {
          "id": 35,
          "question": "Những phát biểu nào sau đây là đúng về `interface` trong Java?",
          "options": [
            "Tất cả các phương thức trong interface đều là public abstract",
            "Interface có thể chứa các biến static final",
            "Một lớp có thể implement nhiều interface",
            "Interface có thể kế thừa từ một interface khác",
            "Interface có thể chứa constructor"
          ],
          "correctAnswer": [
            "Tất cả các phương thức trong interface đều là public abstract",
            "Interface có thể chứa các biến static final",
            "Một lớp có thể implement nhiều interface",
            "Interface có thể kế thừa từ một interface khác"
          ],
          "reason": "Trong interface, các phương thức mặc định là `public abstract` (trước Java 8). Interface có thể chứa các biến `static final` (hằng số). Một lớp có thể implement nhiều interface. Interface có thể kế thừa từ một hoặc nhiều interface khác bằng từ khóa `extends`. Interface không thể chứa constructor."
        },
        {
          "id": 36,
          "question": "Đâu là đầu ra của đoạn code sau? `int x = 0; while (x < 5) { System.out.print(x + \" \"); x++; }`",
          "options": [
            "0 1 2 3 4",
            "1 2 3 4 5",
            "0 1 2 3 4 5",
            "Không in ra gì cả"
          ],
          "correctAnswer": ["0 1 2 3 4"],
          "reason": "Vòng lặp `while` sẽ in ra các giá trị của `x` từ 0 đến 4, mỗi giá trị cách nhau bởi một khoảng trắng."
        },
        {
          "id": 37,
          "question": "Những phát biểu nào sau đây là đúng về `enum` trong Java?",
          "options": [
            "Là một tập hợp các hằng số",
            "Có thể chứa các phương thức",
            "Có thể implement interface",
            "Không thể kế thừa từ class khác",
            "Có thể so sánh bằng toán tử `==`"
          ],
          "correctAnswer": [
            "Là một tập hợp các hằng số",
            "Có thể chứa các phương thức",
            "Có thể implement interface",
            "Có thể so sánh bằng toán tử `==`"
          ],
          "reason": "`enum` là một kiểu dữ liệu đặc biệt, đại diện cho một tập hợp các hằng số. `enum` có thể chứa các phương thức, implement interface, và không thể kế thừa từ class khác (nhưng mặc định kế thừa từ `java.lang.Enum`). Các hằng số `enum` có thể so sánh trực tiếp bằng toán tử `==`."
        },
        {
          "id": 38,
          "question": "Làm thế nào để tạo một bản sao (copy) của một mảng trong Java?",
          "options": [
            "Sử dụng phương thức `clone()`",
            "Sử dụng vòng lặp `for` để sao chép từng phần tử",
            "Sử dụng phương thức `arraycopy()` của lớp `System`",
            "Sử dụng phương thức `copyOf()` của lớp `Arrays`"
          ],
          "correctAnswer": [
            "Sử dụng phương thức `clone()`",
            "Sử dụng vòng lặp `for` để sao chép từng phần tử",
            "Sử dụng phương thức `arraycopy()` của lớp `System`",
            "Sử dụng phương thức `copyOf()` của lớp `Arrays`"
          ],
          "reason": "Có nhiều cách để tạo bản sao của mảng. Phương thức `clone()` tạo một bản sao nông (shallow copy). Vòng lặp `for` có thể sao chép từng phần tử. Phương thức `arraycopy()` của lớp `System` và `copyOf()` của lớp `Arrays` cung cấp các cách hiệu quả để sao chép mảng."
        },
        {
          "id": 39,
          "question": "Đâu là đầu ra của đoạn code sau? `String s1 = \"Hello\"; String s2 = new String(\"Hello\"); System.out.println(s1 == s2);`",
          "options": ["true", "false", "Lỗi biên dịch", "Không có đầu ra"],
          "correctAnswer": ["false"],
          "reason": "Toán tử `==` so sánh tham chiếu của hai đối tượng. Trong trường hợp này, `s1` tham chiếu đến chuỗi trong String pool, còn `s2` tham chiếu đến một đối tượng String mới được tạo ra trên heap. Do đó, kết quả là `false`."
        },
        {
          "id": 40,
          "question": "Những phát biểu nào sau đây là đúng về `static` method (phương thức tĩnh) trong Java?",
          "options": [
            "Có thể truy cập trực tiếp các biến instance",
            "Không thể truy cập trực tiếp các biến instance",
            "Có thể được gọi thông qua tên lớp",
            "Có thể được gọi thông qua đối tượng",
            "Có thể override phương thức non-static của lớp cha"
          ],
          "correctAnswer": [
            "Không thể truy cập trực tiếp các biến instance",
            "Có thể được gọi thông qua tên lớp",
            "Có thể được gọi thông qua đối tượng"
          ],
          "reason": "Phương thức static thuộc về lớp, không thuộc về đối tượng cụ thể. Do đó, nó không thể truy cập trực tiếp các biến instance (non-static). Phương thức static có thể được gọi thông qua tên lớp hoặc đối tượng. Một phương thức static không thể override (ghi đè) phương thức non-static của lớp cha, nhưng có thể hiding (ẩn)."
        },
        {
          "id": 41,
          "question": "Đâu là các cách đúng để khai báo một biến `char` trong java?",
          "options": [
            "char c = 'a';",
            "char c = \"a\";",
            "char c = 97;",
            "char c = (char)97;"
          ],
          "correctAnswer": [
            "char c = 'a';",
            "char c = 97;",
            "char c = (char)97;"
          ],
          "reason": "Khai báo char sử dụng dấu nháy đơn. Ngoài ra char còn có thể được gán bằng mã ASCII hoặc ép kiểu số nguyên"
        },
        {
          "id": 42,
          "question": "Những cách nào sau đây là đúng để khai báo và khởi tạo một `ArrayList` chứa các chuỗi trong Java?",
          "options": [
            "ArrayList<String> list = new ArrayList<String>();",
            "ArrayList<String> list = new ArrayList<>();",
            "List<String> list = new ArrayList<String>();",
            "List<String> list = new ArrayList<>();",
            "ArrayList list = new ArrayList();"
          ],
          "correctAnswer": [
            "ArrayList<String> list = new ArrayList<String>();",
            "ArrayList<String> list = new ArrayList<>();",
            "List<String> list = new ArrayList<String>();",
            "List<String> list = new ArrayList<>();"
          ],
          "reason": "Cả bốn cách trên đều đúng cú pháp để khai báo và khởi tạo `ArrayList` chứa chuỗi. Nên sử dụng `List` thay vì `ArrayList` để khai báo kiểu. Dùng dấu `<>` (diamond operator) để suy luận kiểu từ Java 7 trở đi."
        },
        {
          "id": 43,
          "question": "Đâu là đầu ra của đoạn code sau? `int x = 10; int y = 5; System.out.println(x++ > 10 && --y < 5); System.out.println(x + \" \" + y);`",
          "options": ["false\n11 4", "true\n11 4", "false\n10 5", "true\n10 5"],
          "correctAnswer": ["false\n11 4"],
          "reason": "Toán tử `&&` (AND) là short-circuit. `x++` trả về 10, sau đó `x` mới tăng lên 11. Vì `10 > 10` là `false`, biểu thức bên phải của `&&` không được đánh giá, do đó `--y` không được thực thi. `y` vẫn giữ nguyên giá trị 5. Do đó, kết quả đầu tiên là `false` và giá trị của `x` và `y` lần lượt là 11 và 4."
        },
        {
          "id": 44,
          "question": "Những phát biểu nào sau đây là đúng về `try-catch-finally` trong Java?",
          "options": [
            "Khối `finally` luôn được thực thi",
            "Khối `finally` chỉ được thực thi nếu có ngoại lệ xảy ra",
            "Một khối `try` có thể có nhiều khối `catch`",
            "Một khối `try` phải có ít nhất một khối `catch` hoặc `finally`",
            "Thứ tự của các khối `catch` không quan trọng"
          ],
          "correctAnswer": [
            "Khối `finally` luôn được thực thi",
            "Một khối `try` có thể có nhiều khối `catch`",
            "Một khối `try` phải có ít nhất một khối `catch` hoặc `finally`"
          ],
          "reason": "Khối `finally` luôn được thực thi, bất kể có ngoại lệ xảy ra hay không. Một khối `try` có thể có nhiều khối `catch` để xử lý các loại ngoại lệ khác nhau. Một khối `try` phải đi kèm với ít nhất một khối `catch` hoặc `finally`. Thứ tự của các khối `catch` là quan trọng, các exception cụ thể hơn phải được đặt trước các exception tổng quát hơn."
        },
        {
          "id": 45,
          "question": "Đâu là cách đúng để tạo một luồng (thread) mới bằng cách implement interface `Runnable` trong Java?",
          "options": [
            "Tạo một lớp implement `Runnable`, override phương thức `run()`, tạo một đối tượng `Thread` và truyền đối tượng `Runnable` vào constructor, sau đó gọi phương thức `start()`",
            "Tạo một lớp implement `Runnable`, override phương thức `start()`, tạo một đối tượng `Thread` và truyền đối tượng `Runnable` vào constructor, sau đó gọi phương thức `run()`",
            "Tạo một lớp kế thừa từ `Thread`, override phương thức `run()`, tạo một đối tượng của lớp đó và gọi phương thức `start()`",
            "Tạo một đối tượng `Thread` và gọi phương thức `run()`"
          ],
          "correctAnswer": [
            "Tạo một lớp implement `Runnable`, override phương thức `run()`, tạo một đối tượng `Thread` và truyền đối tượng `Runnable` vào constructor, sau đó gọi phương thức `start()`"
          ],
          "reason": "Để tạo luồng bằng cách implement `Runnable`, cần tạo một lớp implement interface này, override phương thức `run()`, tạo một đối tượng `Thread` và truyền đối tượng `Runnable` vào constructor của `Thread`, sau đó gọi phương thức `start()` của đối tượng `Thread` để bắt đầu luồng."
        },
        {
          "id": 46,
          "question": "Những phát biểu nào sau đây là đúng về `abstract` method (phương thức trừu tượng) trong Java?",
          "options": [
            "Phải được khai báo trong `abstract class`",
            "Không có phần thân (body)",
            "Phải được override bởi lớp con",
            "Có thể được khai báo là `final`",
            "Có thể được khai báo là `static`"
          ],
          "correctAnswer": [
            "Phải được khai báo trong `abstract class`",
            "Không có phần thân (body)",
            "Phải được override bởi lớp con"
          ],
          "reason": "Phương thức trừu tượng phải được khai báo trong `abstract class` hoặc `interface`, không có phần thân, và phải được override (ghi đè) bởi lớp con (trừ khi lớp con cũng là `abstract`). Phương thức trừu tượng không thể là `final` (vì phải được override) và không thể là `static`."
        },
        {
          "id": 47,
          "question": "Đâu là kết quả của đoạn code sau? `List<String> list = new ArrayList<>(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); list.remove(1); System.out.println(list);`",
          "options": ["[A, C]", "[A, B]", "[B, C]", "[A, B, C]"],
          "correctAnswer": ["[A, C]"],
          "reason": "Phương thức `remove(1)` sẽ xóa phần tử ở vị trí index 1 (phần tử \"B\") khỏi `ArrayList`. Do đó, danh sách còn lại là [\"A\", \"C\"]."
        },
        {
          "id": 48,
          "question": "Những phát biểu nào sau đây là đúng về `interface` trong Java?",
          "options": [
            "Có thể chứa các phương thức `default` từ Java 8 trở đi",
            "Có thể chứa các phương thức `static` từ Java 8 trở đi",
            "Có thể chứa các biến `public static final`",
            "Có thể chứa các phương thức `private` từ Java 9 trở đi",
            "Không thể chứa các phương thức `protected`"
          ],
          "correctAnswer": [
            "Có thể chứa các phương thức `default` từ Java 8 trở đi",
            "Có thể chứa các phương thức `static` từ Java 8 trở đi",
            "Có thể chứa các biến `public static final`",
            "Có thể chứa các phương thức `private` từ Java 9 trở đi",
            "Không thể chứa các phương thức `protected`"
          ],
          "reason": "Từ Java 8, interface có thể chứa các phương thức `default` và `static`. Interface có thể chứa các biến `public static final` (hằng số). Từ Java 9, interface có thể chứa các phương thức `private`. Interface không thể chứa các phương thức `protected`."
        },
        {
          "id": 49,
          "question": "Đâu là đầu ra của đoạn code sau? `int x = 5; int y = 2; System.out.println(x / y);`",
          "options": ["2.5", "2", "3", "Lỗi biên dịch"],
          "correctAnswer": ["2"],
          "reason": "Phép chia hai số nguyên trong Java sẽ trả về phần nguyên của kết quả. Do đó, 5 / 2 = 2."
        },
        {
          "id": 50,
          "question": "Những phát biểu nào sau đây là đúng về `String` pool trong Java?",
          "options": [
            "Là một vùng nhớ trong heap",
            "Lưu trữ các đối tượng `String`",
            "Giúp tiết kiệm bộ nhớ",
            "Khi hai biến `String` có cùng giá trị, chúng sẽ tham chiếu đến cùng một đối tượng trong String pool",
            "String pool là garbage collected"
          ],
          "correctAnswer": [
            "Là một vùng nhớ trong heap",
            "Lưu trữ các đối tượng `String`",
            "Giúp tiết kiệm bộ nhớ",
            "Khi hai biến `String` có cùng giá trị, chúng sẽ tham chiếu đến cùng một đối tượng trong String pool",
            "String pool là garbage collected"
          ],
          "reason": "String pool là một vùng nhớ đặc biệt trong heap, lưu trữ các đối tượng `String` literal. Khi hai biến `String` có cùng giá trị và được tạo bằng string literal, chúng sẽ tham chiếu đến cùng một đối tượng trong String pool, giúp tiết kiệm bộ nhớ. String pool cũng là garbage collected."
        }
      ]
    }
  ]
}
