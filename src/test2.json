{
  "tests": [
    {
      "id": 1,
      "title": "Science Quiz",
      "timeLimit": 300,
      "questions": [
        {
          "id": 1,
          "question": "What is the chemical symbol for water?",
          "options": ["H2O", "CO2", "NaCl", "O2"],
          "correctAnswer": ["H2O"],
          "reason": "zxcaxc"
        },
        {
          "id": 2,
          "question": "What is the speed of light?",
          "options": [
            "300,000 km/s",
            "150,000 km/s",
            "450,000 km/s",
            "600,000 km/s"
          ],
          "correctAnswer": "300,000 km/s"
        }
      ]
    },
    {
      "id": 2,
      "title": "Đề thi số 1",
      "timeLimit": 60000,
      "questions": [
        {
          "id": 1,
          "question": "Trong mô hình TCP/IP, giao thức nào chịu trách nhiệm phân mảnh và đóng gói dữ liệu?",
          "options": ["TCP", "IP", "UDP", "HTTP"],
          "correctAnswer": ["IP"],
          "reason": "Giao thức IP chịu trách nhiệm phân mảnh (fragmentation) và đóng gói (encapsulation) dữ liệu thành các gói tin (packets)."
        },
        {
          "id": 2,
          "question": "Địa chỉ MAC là gì?",
          "options": [
            "Địa chỉ logic được gán bởi quản trị viên mạng",
            "Địa chỉ vật lý duy nhất được gán cho card mạng",
            "Địa chỉ IP động",
            "Địa chỉ dùng để định tuyến trong mạng LAN"
          ],
          "correctAnswer": ["Địa chỉ vật lý duy nhất được gán cho card mạng"],
          "reason": "Địa chỉ MAC (Media Access Control) là địa chỉ vật lý duy nhất, được nhà sản xuất gán cho mỗi card mạng."
        },
        {
          "id": 3,
          "question": "Giao thức nào sau đây hoạt động ở tầng Application của mô hình OSI?",
          "options": ["TCP", "UDP", "FTP", "IP"],
          "correctAnswer": ["FTP"],
          "reason": "FTP (File Transfer Protocol) là giao thức truyền file, hoạt động ở tầng Application."
        },
        {
          "id": 4,
          "question": "Độ phức tạp thời gian của thuật toán Quick Sort trong trường hợp trung bình là bao nhiêu?",
          "options": ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"],
          "correctAnswer": ["O(n log n)"],
          "reason": "Quick Sort có độ phức tạp thời gian trung bình là O(n log n)."
        },
        {
          "id": 5,
          "question": "Cây nhị phân tìm kiếm (BST) có đặc điểm gì?",
          "options": [
            "Các nút con bên trái luôn lớn hơn nút cha",
            "Các nút con bên phải luôn nhỏ hơn nút cha",
            "Các nút con bên trái nhỏ hơn nút cha, các nút con bên phải lớn hơn hoặc bằng nút cha",
            "Thứ tự các nút không quan trọng"
          ],
          "correctAnswer": [
            "Các nút con bên trái nhỏ hơn nút cha, các nút con bên phải lớn hơn hoặc bằng nút cha"
          ],
          "reason": "Trong BST, các nút con bên trái luôn nhỏ hơn nút cha, và các nút con bên phải luôn lớn hơn hoặc bằng nút cha."
        },
        {
          "id": 6,
          "question": "Phương pháp nào sau đây được sử dụng để cấp phát bộ nhớ động trong C++?",
          "options": ["malloc", "calloc", "new", "alloc"],
          "correctAnswer": ["new"],
          "reason": "Trong C++, `new` được sử dụng để cấp phát bộ nhớ động, `malloc` và `calloc` là của C."
        },
        {
          "id": 7,
          "question": "Khi phân tích độ phức tạp của thuật toán, ký hiệu 'Ω' (Omega) biểu thị điều gì?",
          "options": [
            "Trường hợp tốt nhất",
            "Trường hợp trung bình",
            "Trường hợp xấu nhất",
            "Giới hạn dưới của thời gian thực thi"
          ],
          "correctAnswer": ["Giới hạn dưới của thời gian thực thi"],
          "reason": "Ký hiệu Ω (Omega) được sử dụng để biểu thị giới hạn dưới (lower bound) của thời gian thực thi thuật toán, tức là thời gian thực thi tối thiểu."
        },
        {
          "id": 8,
          "question": "Bộ nhớ cache hoạt động dựa trên nguyên lý nào?",
          "options": [
            "Tính cục bộ không gian và thời gian",
            "Tính ngẫu nhiên",
            "Tính toàn vẹn dữ liệu",
            "Tính bảo mật"
          ],
          "correctAnswer": ["Tính cục bộ không gian và thời gian"],
          "reason": "Bộ nhớ cache hoạt động dựa trên nguyên lý locality of reference (tính cục bộ tham chiếu), bao gồm tính cục bộ không gian (spatial locality) và tính cục bộ thời gian (temporal locality)."
        },
        {
          "id": 9,
          "question": "Tiến trình (process) ở trạng thái 'Waiting' (hoặc 'Blocked') có nghĩa là gì?",
          "options": [
            "Tiến trình đang chạy",
            "Tiến trình đã kết thúc",
            "Tiến trình đang chờ một sự kiện (ví dụ: I/O)",
            "Tiến trình đang sẵn sàng để chạy"
          ],
          "correctAnswer": ["Tiến trình đang chờ một sự kiện (ví dụ: I/O)"],
          "reason": "Trạng thái 'Waiting' cho biết tiến trình đang chờ đợi một sự kiện xảy ra, ví dụ như hoàn thành thao tác I/O, trước khi có thể tiếp tục thực thi."
        },
        {
          "id": 10,
          "question": "Deadlock trong hệ điều hành xảy ra khi nào?",
          "options": [
            "Hai hoặc nhiều tiến trình cùng truy cập vào một tài nguyên",
            "Một tiến trình bị lỗi",
            "Hệ thống bị quá tải",
            "Hai hoặc nhiều tiến trình chờ đợi lẫn nhau để giải phóng tài nguyên"
          ],
          "correctAnswer": [
            "Hai hoặc nhiều tiến trình chờ đợi lẫn nhau để giải phóng tài nguyên"
          ],
          "reason": "Deadlock xảy ra khi hai hoặc nhiều tiến trình rơi vào trạng thái chờ đợi vô hạn, mỗi tiến trình giữ một tài nguyên và chờ đợi một tài nguyên khác đang bị giữ bởi tiến trình khác trong cùng một nhóm."
        },
        {
          "id": 11,
          "question": "Khái niệm 'Encapsulation' (Đóng gói) trong lập trình hướng đối tượng có ý nghĩa gì?",
          "options": [
            "Che giấu thông tin và hành vi bên trong của đối tượng",
            "Cho phép các đối tượng giao tiếp với nhau",
            "Tạo ra các lớp mới từ các lớp đã có",
            "Xử lý các ngoại lệ"
          ],
          "correctAnswer": [
            "Che giấu thông tin và hành vi bên trong của đối tượng"
          ],
          "reason": "Đóng gói (Encapsulation) là kỹ thuật che giấu thông tin và các phương thức nội bộ của đối tượng, chỉ cho phép truy cập thông qua các phương thức public."
        },
        {
          "id": 12,
          "question": "Lớp trừu tượng (abstract class) trong Java là gì?",
          "options": [
            "Lớp không thể có đối tượng",
            "Lớp có thể có đối tượng",
            "Lớp chỉ chứa các phương thức trừu tượng",
            "Lớp được sử dụng để kế thừa"
          ],
          "correctAnswer": ["Lớp không thể có đối tượng"],
          "reason": "Lớp trừu tượng (abstract class) là lớp không thể được khởi tạo thành đối tượng (instance). Nó được sử dụng như một bản thiết kế cho các lớp con."
        },
        {
          "id": 13,
          "question": "Ngôn ngữ lập trình nào sau đây không phải là ngôn ngữ lập trình hướng đối tượng?",
          "options": ["Java", "C++", "Python", "C"],
          "correctAnswer": ["C"],
          "reason": "C là ngôn ngữ lập trình hướng cấu trúc, không phải hướng đối tượng."
        },
        {
          "id": 14,
          "question": "ACID là viết tắt của các thuộc tính nào trong hệ quản trị cơ sở dữ liệu?",
          "options": [
            "Atomicity, Consistency, Isolation, Durability",
            "Availability, Concurrency, Integrity, Dependability",
            "Accuracy, Completeness, Isolation, Durability",
            "Atomicity, Concurrency, Integrity, Dependability"
          ],
          "correctAnswer": ["Atomicity, Consistency, Isolation, Durability"],
          "reason": "ACID là viết tắt của: Atomicity (tính nguyên tử), Consistency (tính nhất quán), Isolation (tính cô lập), Durability (tính bền vững)."
        },
        {
          "id": 15,
          "question": "Khóa ngoại (foreign key) trong cơ sở dữ liệu quan hệ dùng để làm gì?",
          "options": [
            "Định danh duy nhất một bản ghi trong bảng",
            "Tham chiếu đến khóa chính của bảng khác",
            "Lưu trữ dữ liệu nhạy cảm",
            "Tăng tốc độ truy vấn"
          ],
          "correctAnswer": ["Tham chiếu đến khóa chính của bảng khác"],
          "reason": "Khóa ngoại dùng để thiết lập mối quan hệ giữa các bảng, tham chiếu đến khóa chính của bảng khác."
        },
        {
          "id": 16,
          "question": "Trong mô hình Waterfall của quy trình phát triển phần mềm, giai đoạn nào được thực hiện sau giai đoạn 'Requirement Gathering and Analysis'?",
          "options": ["Design", "Implementation", "Testing", "Maintenance"],
          "correctAnswer": ["Design"],
          "reason": "Trong mô hình Waterfall, giai đoạn 'Design' (Thiết kế) được thực hiện ngay sau giai đoạn 'Requirement Gathering and Analysis' (Thu thập và phân tích yêu cầu)."
        },
        {
          "id": 17,
          "question": "Phương pháp kiểm thử hộp đen (black-box testing) tập trung vào điều gì?",
          "options": [
            "Kiểm tra cấu trúc bên trong của code",
            "Kiểm tra chức năng của phần mềm dựa trên yêu cầu",
            "Kiểm tra hiệu năng của hệ thống",
            "Kiểm tra tính bảo mật của phần mềm"
          ],
          "correctAnswer": ["Kiểm tra chức năng của phần mềm dựa trên yêu cầu"],
          "reason": "Kiểm thử hộp đen (black-box testing) tập trung vào việc kiểm tra các chức năng của phần mềm dựa trên các yêu cầu đặc tả mà không cần biết đến cấu trúc code bên trong."
        },
        {
          "id": 18,
          "question": "Biểu đồ use case trong UML dùng để làm gì?",
          "options": [
            "Mô tả các chức năng của hệ thống và các tác nhân tương tác",
            "Mô tả cấu trúc của cơ sở dữ liệu",
            "Mô tả luồng xử lý của thuật toán",
            "Mô tả kiến trúc của hệ thống"
          ],
          "correctAnswer": [
            "Mô tả các chức năng của hệ thống và các tác nhân tương tác"
          ],
          "reason": "Biểu đồ use case (use case diagram) trong UML được sử dụng để mô tả các chức năng của hệ thống và các tác nhân (actors) tương tác với hệ thống đó."
        },
        {
          "id": 19,
          "question": "Scrum là một framework thuộc phương pháp phát triển phần mềm nào?",
          "options": ["Waterfall", "Agile", "Spiral", "V-Model"],
          "correctAnswer": ["Agile"],
          "reason": "Scrum là một framework phổ biến trong phương pháp phát triển phần mềm linh hoạt (Agile)."
        },
        {
          "id": 20,
          "question": "Trong quản lý dự án, 'Critical Path' (Đường găng) là gì?",
          "options": [
            "Chuỗi các công việc không quan trọng",
            "Chuỗi các công việc có thời gian dự trữ bằng 0",
            "Chuỗi các công việc có thời gian dự trữ lớn nhất",
            "Chuỗi các công việc có thể thực hiện song song"
          ],
          "correctAnswer": ["Chuỗi các công việc có thời gian dự trữ bằng 0"],
          "reason": "Critical Path (Đường găng) là chuỗi các công việc trong sơ đồ mạng (network diagram) có thời gian dự trữ bằng 0. Việc chậm trễ bất kỳ công việc nào trên đường găng sẽ dẫn đến chậm trễ toàn bộ dự án."
        },
        {
          "id": 21,
          "question": "Biểu thức chính quy `[a-zA-Z0-9]+` khớp với chuỗi nào sau đây?",
          "options": ["123", "abc", "ABC", "_", "aB9", " "],
          "correctAnswer": ["123", "abc", "ABC", "aB9"],
          "reason": "`[a-zA-Z0-9]+` khớp với chuỗi có ít nhất một ký tự là chữ cái (hoa hoặc thường) hoặc chữ số."
        },
        {
          "id": 22,
          "question": "Ký tự `.` trong biểu thức chính quy có ý nghĩa gì?",
          "options": [
            "Khớp với bất kỳ ký tự nào",
            "Khớp với ký tự xuống dòng",
            "Khớp với ký tự trắng",
            "Khớp với chính ký tự '.'"
          ],
          "correctAnswer": ["Khớp với bất kỳ ký tự nào"],
          "reason": "Ký tự `.` trong biểu thức chính quy khớp với bất kỳ ký tự nào ngoại trừ ký tự xuống dòng."
        },
        {
          "id": 23,
          "question": "Kỹ thuật 'RAID' trong lưu trữ dữ liệu là viết tắt của cụm từ nào?",
          "options": [
            "Redundant Array of Independent Disks",
            "Random Access to Internal Data",
            "Rapid Application of Integrated Devices",
            "Reliable Access to Important Data"
          ],
          "correctAnswer": ["Redundant Array of Independent Disks"],
          "reason": "RAID là viết tắt của Redundant Array of Independent Disks (Mảng đĩa độc lập dự phòng)."
        },
        {
          "id": 24,
          "question": "Giao thức HTTPS sử dụng cổng mặc định nào?",
          "options": ["80", "443", "21", "22"],
          "correctAnswer": ["443"],
          "reason": "HTTPS (HTTP Secure) sử dụng cổng mặc định 443 cho kết nối an toàn."
        },
        {
          "id": 25,
          "question": "Thuật toán sắp xếp nào sau đây không phải là thuật toán so sánh?",
          "options": ["Quick Sort", "Merge Sort", "Heap Sort", "Counting Sort"],
          "correctAnswer": ["Counting Sort"],
          "reason": "Counting Sort (Sắp xếp đếm) là thuật toán sắp xếp dựa trên tần suất xuất hiện của các phần tử, không phải dựa trên so sánh trực tiếp giữa các phần tử."
        },
        {
          "id": 26,
          "question": "Virtual Memory (Bộ nhớ ảo) cho phép thực thi các tiến trình có kích thước như thế nào?",
          "options": [
            "Nhỏ hơn bộ nhớ vật lý",
            "Bằng bộ nhớ vật lý",
            "Lớn hơn bộ nhớ vật lý",
            "Không liên quan đến bộ nhớ vật lý"
          ],
          "correctAnswer": ["Lớn hơn bộ nhớ vật lý"],
          "reason": "Bộ nhớ ảo cho phép thực thi các tiến trình có kích thước lớn hơn bộ nhớ vật lý (RAM) bằng cách sử dụng không gian lưu trữ phụ (ví dụ: ổ cứng) để lưu trữ tạm thời các phần của tiến trình không được sử dụng thường xuyên."
        },
        {
          "id": 27,
          "question": "Tính kế thừa (Inheritance) trong lập trình hướng đối tượng cho phép điều gì?",
          "options": [
            "Định nghĩa các phương thức mới",
            "Tạo ra các đối tượng mới",
            "Tái sử dụng code từ lớp cha",
            "Thay đổi hành vi của lớp cha"
          ],
          "correctAnswer": ["Tái sử dụng code từ lớp cha"],
          "reason": "Tính kế thừa (Inheritance) cho phép lớp con (subclass) kế thừa các thuộc tính và phương thức của lớp cha (superclass), giúp tái sử dụng code và giảm thiểu sự trùng lặp."
        },
        {
          "id": 28,
          "question": "Cho đoạn code Java sau, tìm lỗi sai (nếu có) và giải thích:\n```java\npublic class MyClass {\n    private int x;\n    public MyClass(int x) {\n        this.x = x;\n    }\n    public static void main(String[] args) {\n        MyClass obj = new MyClass();\n        System.out.println(obj.x);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi biên dịch vì thiếu tham số cho constructor",
            "Lỗi runtime vì x chưa được khởi tạo",
            "Lỗi vì x là private"
          ],
          "correctAnswer": ["Lỗi biên dịch vì thiếu tham số cho constructor"],
          "reason": "Constructor của MyClass cần một tham số int, nhưng khi tạo đối tượng `obj` lại không truyền tham số nào."
        },
        {
          "id": 29,
          "question": "Cho đoạn code Java sau, nó thực hiện công việc gì?\n```java\npublic class Mystery {\n    public static int function(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        return function(n - 1) + function(n - 2);\n    }\n    public static void main(String[] args) {\n        System.out.println(function(5));\n    }\n}\n```",
          "options": [
            "Tính giai thừa của 5",
            "Tính tổng các số từ 1 đến 5",
            "Tính số Fibonacci thứ 5",
            "Không xác định được"
          ],
          "correctAnswer": ["Tính số Fibonacci thứ 5"],
          "reason": "Hàm `function` sử dụng đệ quy để tính số Fibonacci. `function(5)` sẽ trả về số Fibonacci thứ 5 (bắt đầu từ 0), kết quả là 5."
        },
        {
          "id": 30,
          "question": "Cho bảng `Orders` với các cột `OrderID` (INT, PRIMARY KEY), `CustomerID` (INT, FOREIGN KEY), `OrderDate` (DATE), `TotalAmount` (FLOAT). Viết truy vấn SQL để lấy ra tổng doanh thu (TotalAmount) của mỗi khách hàng (CustomerID) trong tháng 1 năm 2023.",
          "options": [
            "SELECT CustomerID, SUM(TotalAmount) FROM Orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY CustomerID;",
            "SELECT CustomerID, TotalAmount FROM Orders WHERE OrderDate LIKE '2023-01%' GROUP BY CustomerID;",
            "SELECT CustomerID, SUM(TotalAmount) FROM Orders WHERE MONTH(OrderDate) = 1 AND YEAR(OrderDate) = 2023 GROUP BY CustomerID;",
            "SELECT CustomerID, SUM(TotalAmount) FROM Orders WHERE OrderDate >= '2023-01-01' AND OrderDate < '2023-02-01' GROUP BY CustomerID;"
          ],
          "correctAnswer": [
            "SELECT CustomerID, SUM(TotalAmount) FROM Orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY CustomerID;",
            "SELECT CustomerID, SUM(TotalAmount) FROM Orders WHERE MONTH(OrderDate) = 1 AND YEAR(OrderDate) = 2023 GROUP BY CustomerID;",
            "SELECT CustomerID, SUM(TotalAmount) FROM Orders WHERE OrderDate >= '2023-01-01' AND OrderDate < '2023-02-01' GROUP BY CustomerID;"
          ],
          "reason": "Cả ba đáp án đều đúng, cách A,C,D dùng BETWEEN, hàm MONTH và YEAR hoặc so sánh trực tiếp để lọc ra các đơn hàng trong tháng 1 năm 2023, sau đó dùng SUM và GROUP BY để tính tổng doanh thu theo từng khách hàng."
        }
      ]
    },
    {
      "id": 3,
      "title": "Đề thi số 2",
      "timeLimit": 6000,
      "questions": [
        {
          "id": 1,
          "question": "Giao thức ARP (Address Resolution Protocol) dùng để làm gì?",
          "options": [
            "Phân giải địa chỉ IP thành địa chỉ MAC",
            "Phân giải tên miền thành địa chỉ IP",
            "Định tuyến gói tin trong mạng",
            "Truyền file giữa các máy tính"
          ],
          "correctAnswer": ["Phân giải địa chỉ IP thành địa chỉ MAC"],
          "reason": "ARP được sử dụng để phân giải địa chỉ IP thành địa chỉ MAC tương ứng trong mạng cục bộ."
        },
        {
          "id": 2,
          "question": "Subnet Mask 255.255.255.0 tương ứng với lớp mạng nào?",
          "options": ["Lớp A", "Lớp B", "Lớp C", "Lớp D"],
          "correctAnswer": ["Lớp C"],
          "reason": "Subnet Mask 255.255.255.0 có 24 bit đầu tiên là 1, tương ứng với mạng lớp C."
        },
        {
          "id": 3,
          "question": "Giao thức nào sau đây không đảm bảo độ tin cậy trong truyền dữ liệu?",
          "options": ["TCP", "UDP", "FTP", "HTTP"],
          "correctAnswer": ["UDP"],
          "reason": "UDP (User Datagram Protocol) là giao thức truyền dữ liệu không kết nối (connectionless) và không đảm bảo độ tin cậy, không có cơ chế kiểm tra lỗi và phục hồi."
        },
        {
          "id": 4,
          "question": "Thuật toán tìm kiếm nhị phân (Binary Search) yêu cầu dữ liệu đầu vào phải như thế nào?",
          "options": [
            "Đã được sắp xếp",
            "Chưa được sắp xếp",
            "Là số nguyên",
            "Là số thực"
          ],
          "correctAnswer": ["Đã được sắp xếp"],
          "reason": "Thuật toán tìm kiếm nhị phân chỉ hoạt động hiệu quả trên dữ liệu đã được sắp xếp."
        },
        {
          "id": 5,
          "question": "Cấu trúc dữ liệu nào cho phép truy cập trực tiếp đến phần tử bất kỳ thông qua chỉ số?",
          "options": ["Linked List", "Stack", "Queue", "Array"],
          "correctAnswer": ["Array"],
          "reason": "Mảng (Array) cho phép truy cập trực tiếp đến phần tử bất kỳ thông qua chỉ số (index) của nó."
        },
        {
          "id": 6,
          "question": "Khi sử dụng phương thức đệ quy, điều kiện dừng (base case) dùng để làm gì?",
          "options": [
            "Để gọi lại chính hàm đó",
            "Để bắt đầu đệ quy",
            "Để kết thúc đệ quy",
            "Để tăng tốc độ thực thi"
          ],
          "correctAnswer": ["Để kết thúc đệ quy"],
          "reason": "Điều kiện dừng (base case) trong đệ quy là trường hợp đặc biệt mà tại đó hàm sẽ trả về giá trị cụ thể mà không gọi lại chính nó nữa, giúp kết thúc quá trình đệ quy."
        },
        {
          "id": 7,
          "question": "Page fault xảy ra khi nào trong quản lý bộ nhớ ảo?",
          "options": [
            "Khi CPU truy cập vào một trang (page) hiện không có trong RAM",
            "Khi CPU truy cập vào một trang (page) có trong RAM",
            "Khi hệ thống bị lỗi",
            "Khi ổ cứng bị đầy"
          ],
          "correctAnswer": [
            "Khi CPU truy cập vào một trang (page) hiện không có trong RAM"
          ],
          "reason": "Page fault xảy ra khi CPU cố gắng truy cập vào một trang (page) mà hiện không có trong bộ nhớ vật lý (RAM), dẫn đến việc hệ điều hành phải nạp trang đó từ đĩa cứng vào RAM."
        },
        {
          "id": 8,
          "question": "Tiến trình ở trạng thái 'Ready' có nghĩa là gì?",
          "options": [
            "Tiến trình đang chạy",
            "Tiến trình đã kết thúc",
            "Tiến trình đang chờ tài nguyên",
            "Tiến trình đã sẵn sàng để được cấp CPU"
          ],
          "correctAnswer": ["Tiến trình đã sẵn sàng để được cấp CPU"],
          "reason": "Trạng thái 'Ready' cho biết tiến trình đã sẵn sàng để được cấp CPU và thực thi, chỉ chờ bộ lập lịch chọn."
        },
        {
          "id": 9,
          "question": "Giải pháp nào sau đây có thể được sử dụng để ngăn chặn deadlock?",
          "options": [
            "Sử dụng mutex",
            "Định nghĩa timeout cho việc giữ tài nguyên",
            "Cho phép preemption",
            "Tất cả các phương án trên"
          ],
          "correctAnswer": ["Tất cả các phương án trên"],
          "reason": "Mutex, timeout và preemption đều là các kỹ thuật có thể được sử dụng để ngăn chặn hoặc giải quyết deadlock."
        },
        {
          "id": 10,
          "question": "Mutex (Mutual Exclusion) được sử dụng để làm gì trong lập trình đa luồng?",
          "options": [
            "Để chia sẻ tài nguyên giữa các luồng",
            "Để ngăn chặn truy cập đồng thời vào tài nguyên dùng chung",
            "Để đồng bộ hóa các luồng",
            "Để tạo ra các luồng mới"
          ],
          "correctAnswer": [
            "Để ngăn chặn truy cập đồng thời vào tài nguyên dùng chung"
          ],
          "reason": "Mutex được sử dụng để bảo vệ các tài nguyên dùng chung khỏi bị truy cập đồng thời bởi nhiều luồng, đảm bảo tính nhất quán của dữ liệu."
        },
        {
          "id": 11,
          "question": "Phương thức khởi tạo (constructor) trong lập trình hướng đối tượng có đặc điểm gì?",
          "options": [
            "Có thể có hoặc không có tham số",
            "Luôn luôn phải có tham số",
            "Không thể có tham số",
            "Có kiểu trả về"
          ],
          "correctAnswer": ["Có thể có hoặc không có tham số"],
          "reason": "Constructor có thể có hoặc không có tham số, tùy thuộc vào nhu cầu khởi tạo đối tượng."
        },
        {
          "id": 12,
          "question": "Interface trong Java là gì?",
          "options": [
            "Là một lớp hoàn chỉnh",
            "Là một bản thiết kế cho các đối tượng",
            "Là một tập các phương thức abstract",
            "Là một kiểu dữ liệu"
          ],
          "correctAnswer": ["Là một tập các phương thức abstract"],
          "reason": "Interface trong Java là một tập hợp các phương thức abstract (không có phần thân) và các hằng số (constant). Nó định nghĩa một bộ các hành vi mà các lớp cài đặt (implement) interface đó phải tuân theo."
        },
        {
          "id": 13,
          "question": "Overloading (nạp chồng) trong Java là gì?",
          "options": [
            "Định nghĩa nhiều phương thức cùng tên nhưng khác tham số",
            "Ghi đè phương thức của lớp cha",
            "Che giấu phương thức của lớp cha",
            "Kế thừa phương thức của lớp cha"
          ],
          "correctAnswer": [
            "Định nghĩa nhiều phương thức cùng tên nhưng khác tham số"
          ],
          "reason": "Overloading (nạp chồng) cho phép định nghĩa nhiều phương thức có cùng tên nhưng khác nhau về số lượng hoặc kiểu dữ liệu của tham số."
        },
        {
          "id": 14,
          "question": "Trong cơ sở dữ liệu quan hệ, thuộc tính (attribute) là gì?",
          "options": [
            "Một bảng trong cơ sở dữ liệu",
            "Một hàng trong bảng",
            "Một cột trong bảng",
            "Một liên kết giữa hai bảng"
          ],
          "correctAnswer": ["Một cột trong bảng"],
          "reason": "Thuộc tính (attribute) trong cơ sở dữ liệu quan hệ đại diện cho một cột (column) trong bảng, mô tả một đặc điểm của thực thể."
        },
        {
          "id": 15,
          "question": "Phép chiếu (projection) trong đại số quan hệ tương đương với câu lệnh SQL nào?",
          "options": ["SELECT", "INSERT", "UPDATE", "DELETE"],
          "correctAnswer": ["SELECT"],
          "reason": "Phép chiếu (projection) trong đại số quan hệ tương đương với việc sử dụng câu lệnh SELECT trong SQL để chọn ra các cột cụ thể từ một bảng."
        },
        {
          "id": 16,
          "question": "Trong mô hình Agile, 'Sprint' là gì?",
          "options": [
            "Một cuộc họp hàng ngày",
            "Một khoảng thời gian phát triển ngắn",
            "Một tài liệu yêu cầu",
            "Một bản phát hành phần mềm"
          ],
          "correctAnswer": ["Một khoảng thời gian phát triển ngắn"],
          "reason": "Trong Agile, Sprint là một khoảng thời gian cố định (thường từ 1-4 tuần) để nhóm phát triển hoàn thành một tập hợp các công việc đã định trước."
        },
        {
          "id": 17,
          "question": "Unit test (Kiểm thử đơn vị) là gì?",
          "options": [
            "Kiểm tra toàn bộ hệ thống",
            "Kiểm tra sự tương tác giữa các module",
            "Kiểm tra từng đơn vị code nhỏ nhất (ví dụ: hàm, phương thức)",
            "Kiểm tra giao diện người dùng"
          ],
          "correctAnswer": [
            "Kiểm tra từng đơn vị code nhỏ nhất (ví dụ: hàm, phương thức)"
          ],
          "reason": "Unit test tập trung vào việc kiểm tra từng đơn vị code nhỏ nhất (thường là hàm hoặc phương thức) để đảm bảo chúng hoạt động đúng đắn."
        },
        {
          "id": 18,
          "question": "Biểu đồ lớp (Class Diagram) trong UML dùng để làm gì?",
          "options": [
            "Mô tả các chức năng của hệ thống",
            "Mô tả cấu trúc tĩnh của hệ thống",
            "Mô tả luồng xử lý của thuật toán",
            "Mô tả kiến trúc của hệ thống"
          ],
          "correctAnswer": ["Mô tả cấu trúc tĩnh của hệ thống"],
          "reason": "Biểu đồ lớp (Class Diagram) trong UML được sử dụng để mô tả cấu trúc tĩnh của hệ thống, bao gồm các lớp, thuộc tính, phương thức và mối quan hệ giữa các lớp."
        },
        {
          "id": 19,
          "question": "Trong quản lý dự án, 'stakeholder' (các bên liên quan) là gì?",
          "options": [
            "Nhóm phát triển dự án",
            "Khách hàng của dự án",
            "Bất kỳ ai bị ảnh hưởng hoặc có ảnh hưởng đến dự án",
            "Người quản lý dự án"
          ],
          "correctAnswer": [
            "Bất kỳ ai bị ảnh hưởng hoặc có ảnh hưởng đến dự án"
          ],
          "reason": "Stakeholder bao gồm tất cả những người hoặc tổ chức có liên quan, bị ảnh hưởng hoặc có thể ảnh hưởng đến dự án."
        },
        {
          "id": 20,
          "question": "Biểu thức chính quy `\\d{3}-\\d{3}-\\d{4}` khớp với chuỗi nào sau đây?",
          "options": [
            "1234567890",
            "abc-def-ghij",
            "123-456-7890",
            "(123)456-7890"
          ],
          "correctAnswer": ["123-456-7890"],
          "reason": "`\\d{3}-\\d{3}-\\d{4}` khớp với chuỗi có định dạng 3 chữ số, gạch ngang, 3 chữ số, gạch ngang, 4 chữ số."
        },
        {
          "id": 21,
          "question": "Ký tự `^` trong biểu thức chính quy có ý nghĩa gì khi đứng đầu một pattern?",
          "options": [
            "Khớp với bất kỳ ký tự nào",
            "Khớp với ký tự xuống dòng",
            "Khớp với sự bắt đầu của chuỗi",
            "Khớp với chính ký tự '^'"
          ],
          "correctAnswer": ["Khớp với sự bắt đầu của chuỗi"],
          "reason": "Ký tự `^` khi đứng đầu một pattern (không nằm trong `[]`) sẽ khớp với vị trí bắt đầu của chuỗi."
        },
        {
          "id": 22,
          "question": "Trong Database, Index (Chỉ mục) thường được sử dụng cho bảng có kích thước như thế nào?",
          "options": [
            "Nhỏ",
            "Trung bình",
            "Lớn",
            "Không quan trọng kích thước"
          ],
          "correctAnswer": ["Lớn"],
          "reason": "Index (Chỉ mục) đặc biệt hữu ích cho các bảng có kích thước lớn, giúp tăng tốc độ truy vấn dữ liệu."
        },
        {
          "id": 23,
          "question": "iao thức SMTP (Simple Mail Transfer Protocol) thường được sử dụng cho việc gì?",
          "options": [
            "Truyền file",
            "Gửi email",
            "Duyệt web",
            "Truy cập từ xa"
          ],
          "correctAnswer": ["Gửi email"],
          "reason": "SMTP là giao thức chuẩn để gửi email trên Internet."
        },
        {
          "id": 24,
          "question": "Tiến trình có thể tự mình chuyển từ trạng thái 'Running' sang trạng thái 'Ready' không?",
          "options": [
            "Có",
            "Không",
            "Tùy thuộc vào hệ điều hành",
            "Chỉ khi bị ngắt bởi một tiến trình khác"
          ],
          "correctAnswer": ["Không"],
          "reason": "Tiến trình không thể tự chuyển từ trạng thái 'Running' sang 'Ready'. Việc chuyển đổi này được thực hiện bởi bộ lập lịch (scheduler) của hệ điều hành, ví dụ khi hết thời gian sử dụng CPU (time slice) hoặc khi có tiến trình khác có độ ưu tiên cao hơn."
        },
        {
          "id": 25,
          "question": "Trong lập trình hướng đối tượng, 'overriding' (ghi đè) phương thức là gì?",
          "options": [
            "Định nghĩa lại phương thức của lớp cha trong lớp con",
            "Định nghĩa nhiều phương thức cùng tên nhưng khác tham số",
            "Che giấu phương thức của lớp cha",
            "Kế thừa phương thức của lớp cha"
          ],
          "correctAnswer": [
            "Định nghĩa lại phương thức của lớp cha trong lớp con"
          ],
          "reason": "Overriding (ghi đè) cho phép lớp con cung cấp một phương thức cụ thể đã được định nghĩa ở lớp cha, với cùng tên, kiểu trả về và tham số."
        },
        {
          "id": 26,
          "question": "Phân tích đoạn code Java sau và cho biết kết quả:\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int x = 5;\n        int y = 10;\n        if (x++ > 5 && ++y > 10) {\n            System.out.println(\"A\");\n        } else {\n            System.out.println(\"B\");\n        }\n        System.out.println(x + \" \" + y);\n    }\n}\n```",
          "options": ["A\n6 11", "B\n6 10", "A\n6 10", "B\n6 11"],
          "correctAnswer": ["B\n6 10"],
          "reason": "Biểu thức `x++ > 5` trả về `false` (vì `x++` trả về 5, sau đó `x` mới tăng lên 6), do đó phần `++y > 10` không được thực thi. Vì vậy, `y` vẫn giữ nguyên giá trị 10. Kết quả in ra là \"B\" và giá trị của `x` và `y` lần lượt là 6 và 10."
        },
        {
          "id": 27,
          "question": "Tìm lỗi sai trong đoạn code Java sau:\n```java\npublic class Error {\n    public static void main(String[] args) {\n        try {\n            int[] arr = {1, 2, 3};\n            System.out.println(arr[3]);\n        } catch (Exception e) {\n            System.out.println(\"Exception caught\");\n        } finally {\n            System.out.println(\"Finally block\");\n        }\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi ArrayIndexOutOfBoundsException",
            "Lỗi cú pháp trong khối catch",
            "Lỗi cú pháp trong khối finally"
          ],
          "correctAnswer": ["Không có lỗi"],
          "reason": "Mặc dù `arr[3]` sẽ gây ra lỗi `ArrayIndexOutOfBoundsException`, nhưng lỗi này đã được bắt bởi khối `catch (Exception e)`. Do đó, chương trình sẽ in ra \"Exception caught\" và sau đó là \"Finally block\" mà không bị crash."
        },
        {
          "id": 28,
          "question": "Phân tích đoạn code Java sau và cho biết kết quả:\n```java\npublic class Loop {\n    public static void main(String[] args) {\n        int i = 0;\n        while (i < 5) {\n            if (i == 2) {\n                continue;\n            }\n            System.out.print(i + \" \");\n            i++;\n        }\n    }\n}\n```",
          "options": ["0 1 2 3 4 ", "0 1 3 4 ", "0 1 2 3 4 5 ", "0 1 3 4 5 "],
          "correctAnswer": ["0 1 3 4 "],
          "reason": "Khi `i` bằng 2, lệnh `continue` sẽ bỏ qua phần còn lại của thân vòng lặp và nhảy đến lần lặp tiếp theo. Do đó, số 2 không được in ra."
        },
        {
          "id": 29,
          "question": "Cho bảng `Products` với các cột `ProductID` (INT, PRIMARY KEY), `ProductName` (VARCHAR), `CategoryID` (INT, FOREIGN KEY), `Price` (FLOAT). Viết truy vấn SQL để lấy ra tên sản phẩm (ProductName) có giá cao nhất trong mỗi danh mục (CategoryID).",
          "options": [
            "SELECT ProductName FROM Products WHERE Price = (SELECT MAX(Price) FROM Products);",
            "SELECT ProductName, MAX(Price) FROM Products GROUP BY CategoryID;",
            "SELECT p1.ProductName FROM Products p1 WHERE p1.Price = (SELECT MAX(p2.Price) FROM Products p2 WHERE p2.CategoryID = p1.CategoryID);",
            "SELECT ProductName FROM Products ORDER BY Price DESC LIMIT 1;"
          ],
          "correctAnswer": [
            "SELECT p1.ProductName FROM Products p1 WHERE p1.Price = (SELECT MAX(p2.Price) FROM Products p2 WHERE p2.CategoryID = p1.CategoryID);"
          ],
          "reason": "Đáp án C sử dụng subquery để tìm giá lớn nhất cho từng CategoryID, sau đó so sánh với giá của từng sản phẩm để lấy ra ProductName tương ứng."
        },
        {
          "id": 30,
          "question": "Cho bảng `Employees` với các cột `EmployeeID` (INT, PRIMARY KEY), `Name` (VARCHAR), `DepartmentID` (INT, FOREIGN KEY), `Salary` (FLOAT). Viết truy vấn SQL để tìm ra bộ phận (DepartmentID) nào có tổng lương (Salary) lớn hơn 100000.",
          "options": [
            "SELECT DepartmentID FROM Employees WHERE SUM(Salary) > 100000;",
            "SELECT DepartmentID, SUM(Salary) FROM Employees HAVING SUM(Salary) > 100000;",
            "SELECT DepartmentID FROM Employees GROUP BY DepartmentID HAVING SUM(Salary) > 100000;",
            "SELECT DepartmentID, SUM(Salary) AS TotalSalary FROM Employees GROUP BY DepartmentID WHERE TotalSalary > 100000;"
          ],
          "correctAnswer": [
            "SELECT DepartmentID FROM Employees GROUP BY DepartmentID HAVING SUM(Salary) > 100000;"
          ],
          "reason": "Đáp án C sử dụng `GROUP BY` để nhóm theo `DepartmentID`, sau đó dùng `HAVING` để lọc ra các nhóm có tổng lương lớn hơn 100000."
        }
      ]
    },
    {
      "id": 4,
      "title": "Mạng Máy Tính - Ôn Tập",
      "timeLimit": 6000,
      "questions": [
        {
          "id": 1,
          "question": "Giao thức nào sau đây hoạt động ở tầng Giao vận (Transport) và cung cấp dịch vụ truyền thông tin cậy, có kiểm soát luồng và kiểm soát lỗi?",
          "options": ["IP", "TCP", "UDP", "ICMP"],
          "correctAnswer": "TCP",
          "reason": "TCP là giao thức hướng kết nối, cung cấp cơ chế kiểm soát lỗi, kiểm soát luồng, đảm bảo truyền tin cậy."
        },
        {
          "id": 2,
          "question": "Địa chỉ IP nào sau đây là địa chỉ broadcast của mạng 192.168.1.0/24?",
          "options": [
            "192.168.1.0",
            "192.168.1.1",
            "192.168.1.254",
            "192.168.1.255"
          ],
          "correctAnswer": "192.168.1.255",
          "reason": "Địa chỉ broadcast của mạng /24 là địa chỉ có phần host toàn bit 1 (255)."
        },
        {
          "id": 3,
          "question": "Subnet mask nào sau đây được sử dụng cho mạng con /26?",
          "options": [
            "255.255.255.0",
            "255.255.255.128",
            "255.255.255.192",
            "255.255.255.224"
          ],
          "correctAnswer": "255.255.255.192",
          "reason": "/26 tương ứng với 26 bit 1 ở phần network, suy ra subnet mask là 255.255.255.192"
        },
        {
          "id": 4,
          "question": "Quá trình thiết lập kết nối TCP sử dụng cơ chế bắt tay mấy bước?",
          "options": ["2 bước", "3 bước", "4 bước", "5 bước"],
          "correctAnswer": "3 bước",
          "reason": "TCP sử dụng cơ chế bắt tay 3 bước (SYN, SYN-ACK, ACK) để thiết lập kết nối."
        },
        {
          "id": 5,
          "question": "Giao thức nào sau đây được sử dụng để phân giải tên miền thành địa chỉ IP?",
          "options": ["DHCP", "DNS", "ARP", "SMTP"],
          "correctAnswer": "DNS",
          "reason": "DNS (Domain Name System) là hệ thống phân giải tên miền thành địa chỉ IP và ngược lại."
        },
        {
          "id": 6,
          "question": "Thiết bị mạng nào hoạt động ở tầng Mạng (Network) và có chức năng định tuyến các gói tin?",
          "options": ["Hub", "Switch", "Router", "Repeater"],
          "correctAnswer": "Router",
          "reason": "Router hoạt động ở tầng Mạng, định tuyến gói tin dựa trên địa chỉ IP."
        },
        {
          "id": 7,
          "question": "Trong mô hình OSI, tầng nào chịu trách nhiệm mã hóa và giải mã dữ liệu?",
          "options": [
            "Tầng Ứng dụng (Application)",
            "Tầng Trình bày (Presentation)",
            "Tầng Phiên (Session)",
            "Tầng Giao vận (Transport)"
          ],
          "correctAnswer": "Tầng Trình bày (Presentation)",
          "reason": "Tầng Trình bày thực hiện các chức năng như mã hóa, giải mã, nén dữ liệu."
        },
        {
          "id": 8,
          "question": "Giao thức nào sau đây sử dụng cổng 80 mặc định?",
          "options": ["FTP", "SMTP", "HTTP", "Telnet"],
          "correctAnswer": "HTTP",
          "reason": "HTTP (Hypertext Transfer Protocol) là giao thức truyền tải siêu văn bản, sử dụng cổng 80 mặc định."
        },
        {
          "id": 9,
          "question": "Địa chỉ MAC là một địa chỉ vật lý có độ dài bao nhiêu bit?",
          "options": ["32 bit", "48 bit", "64 bit", "128 bit"],
          "correctAnswer": "48 bit",
          "reason": "Địa chỉ MAC có độ dài 48 bit, thường được biểu diễn dưới dạng 6 cặp số hexa."
        },
        {
          "id": 10,
          "question": "Kỹ thuật nào cho phép chia một mạng lớn thành nhiều mạng con nhỏ hơn?",
          "options": ["NAT", "Subnetting", "Supernetting", "VLAN"],
          "correctAnswer": "Subnetting",
          "reason": "Subnetting là kỹ thuật chia nhỏ một mạng thành nhiều mạng con (subnet) để quản lý và sử dụng hiệu quả hơn."
        },
        {
          "id": 11,
          "question": "Giao thức nào sau đây cung cấp dịch vụ cấp phát địa chỉ IP động?",
          "options": ["DNS", "DHCP", "ARP", "RARP"],
          "correctAnswer": "DHCP",
          "reason": "DHCP (Dynamic Host Configuration Protocol) cung cấp dịch vụ cấp phát địa chỉ IP động, cấu hình mạng tự động cho các thiết bị."
        },
        {
          "id": 12,
          "question": "Mô hình mạng nào mà tất cả các máy tính đều có vai trò ngang hàng nhau?",
          "options": ["Client-Server", "Peer-to-Peer", "Hybrid", "Bus"],
          "correctAnswer": "Peer-to-Peer",
          "reason": "Trong mô hình Peer-to-Peer (P2P), các máy tính có vai trò vừa là client, vừa là server."
        },
        {
          "id": 13,
          "question": "Loại cáp mạng nào sau đây có khả năng chống nhiễu tốt nhất?",
          "options": ["Cáp UTP", "Cáp STP", "Cáp đồng trục", "Cáp quang"],
          "correctAnswer": "Cáp quang",
          "reason": "Cáp quang truyền tín hiệu bằng ánh sáng, ít bị nhiễu điện từ, cho tốc độ truyền cao và khoảng cách xa hơn."
        },
        {
          "id": 14,
          "question": "Trong mô hình TCP/IP, tầng nào tương đương với tầng Mạng (Network) trong mô hình OSI?",
          "options": [
            "Tầng Ứng dụng (Application)",
            "Tầng Giao vận (Transport)",
            "Tầng Liên mạng (Internet)",
            "Tầng Truy cập mạng (Network Access)"
          ],
          "correctAnswer": "Tầng Liên mạng (Internet)",
          "reason": "Tầng Liên mạng (Internet) trong TCP/IP đảm nhiệm chức năng định tuyến và đánh địa chỉ logic, tương tự tầng Mạng trong OSI."
        },
        {
          "id": 15,
          "question": "Tấn công DoS là viết tắt của cụm từ nào?",
          "options": [
            "Denial of Service",
            "Distributed of Service",
            "Data over Service",
            "Domain over System"
          ],
          "correctAnswer": "Denial of Service",
          "reason": "DoS (Denial of Service) là tấn công từ chối dịch vụ, làm quá tải hệ thống, khiến người dùng không thể truy cập dịch vụ."
        },
        {
          "id": 16,
          "question": "Giao thức nào sau đây được sử dụng để gửi email?",
          "options": ["POP3", "IMAP", "SMTP", "HTTP"],
          "correctAnswer": "SMTP",
          "reason": "SMTP (Simple Mail Transfer Protocol) là giao thức dùng để gửi email giữa các mail server."
        },
        {
          "id": 17,
          "question": "Thiết bị nào hoạt động ở tầng Liên kết dữ liệu (Data Link) và có khả năng học địa chỉ MAC?",
          "options": ["Hub", "Switch", "Router", "Repeater"],
          "correctAnswer": "Switch",
          "reason": "Switch hoạt động ở tầng Liên kết dữ liệu, học địa chỉ MAC của các thiết bị kết nối để chuyển khung tin đến đúng cổng."
        },
        {
          "id": 18,
          "question": "Giao thức HTTPS sử dụng cổng mặc định nào?",
          "options": ["80", "443", "25", "21"],
          "correctAnswer": "443",
          "reason": "HTTPS (HTTP Secure) sử dụng cổng 443 để mã hóa dữ liệu truyền tải, đảm bảo an toàn."
        },
        {
          "id": 19,
          "question": "Phương pháp mã hóa nào được sử dụng trong WPA2 để bảo mật mạng không dây?",
          "options": ["WEP", "TKIP", "AES", "RC4"],
          "correctAnswer": "AES",
          "reason": "WPA2 sử dụng phương pháp mã hóa AES (Advanced Encryption Standard) mạnh mẽ, an toàn hơn so với WEP và TKIP."
        },
        {
          "id": 20,
          "question": "Địa chỉ IP 172.16.0.1 thuộc lớp địa chỉ nào?",
          "options": ["Lớp A", "Lớp B", "Lớp C", "Lớp D"],
          "correctAnswer": "Lớp B",
          "reason": "Địa chỉ IP lớp B có 2 octet đầu tiên từ 128 đến 191 (172 nằm trong khoảng này)."
        },
        {
          "id": 21,
          "question": "Giao thức nào sau đây hoạt động ở tầng Ứng dụng (Application) và cung cấp dịch vụ truyền tải tập tin?",
          "options": ["HTTP", "FTP", "SMTP", "Telnet"],
          "correctAnswer": "FTP",
          "reason": "FTP (File Transfer Protocol) là giao thức truyền tải tập tin giữa các máy tính."
        },
        {
          "id": 22,
          "question": "Khái niệm \"Firewall\" trong an ninh mạng dùng để chỉ:",
          "options": [
            "Phần mềm diệt virus",
            "Hệ thống phát hiện xâm nhập",
            "Tường lửa kiểm soát truy cập mạng",
            "Thiết bị chống sét"
          ],
          "correctAnswer": "Tường lửa kiểm soát truy cập mạng",
          "reason": "Firewall (tường lửa) là hệ thống kiểm soát lưu lượng vào/ra mạng, ngăn chặn truy cập trái phép."
        },
        {
          "id": 23,
          "question": "Chuẩn Wifi mới nhất hiện nay là chuẩn nào? (cập nhật tới 2023)",
          "options": ["802.11n", "802.11ac", "802.11ax (Wifi 6/6E)", "802.11g"],
          "correctAnswer": "802.11ax (Wifi 6/6E)",
          "reason": "802.11ax (Wi-Fi 6/6E) là chuẩn Wi-Fi mới nhất, cung cấp tốc độ cao hơn, hiệu suất tốt hơn và hỗ trợ nhiều thiết bị đồng thời."
        },
        {
          "id": 24,
          "question": "Khi sử dụng CIDR, một mạng có địa chỉ 10.0.0.0/22 có thể chứa tối đa bao nhiêu host?",
          "options": ["510", "512", "1022", "1024"],
          "correctAnswer": "1022",
          "reason": "/22 có 10 bit cho phần host (32-22=10), số host = 2^10 - 2 = 1022 (trừ địa chỉ mạng và broadcast)."
        },
        {
          "id": 25,
          "question": "Giao thức nào dưới đây sử dụng cho kết nối VPN?",
          "options": ["Telnet", "IPSec", "ARP", "ICMP"],
          "correctAnswer": "IPSec",
          "reason": "IPSec (Internet Protocol Security) là một giao thức bảo mật cung cấp xác thực và mã hóa cho kết nối VPN."
        },
        {
          "id": 26,
          "question": "Trong kiến trúc mạng Client-Server, máy cung cấp dịch vụ được gọi là gì?",
          "options": ["Client", "Server", "Peer", "Host"],
          "correctAnswer": "Server",
          "reason": "Trong mô hình Client-Server, máy chủ (Server) cung cấp dịch vụ, máy khách (Client) yêu cầu dịch vụ."
        },
        {
          "id": 27,
          "question": "Mô hình OSI có bao nhiêu tầng?",
          "options": ["4", "5", "6", "7"],
          "correctAnswer": "7",
          "reason": "Mô hình OSI (Open Systems Interconnection) có 7 tầng: Vật lý, Liên kết dữ liệu, Mạng, Giao vận, Phiên, Trình bày, Ứng dụng."
        },
        {
          "id": 28,
          "question": "Dịch vụ NAT (Network Address Translation) thường được sử dụng để:",
          "options": [
            "Tăng tốc độ truy cập Internet",
            "Bảo mật mạng nội bộ",
            "Chia sẻ một địa chỉ IP public cho nhiều máy trong mạng LAN",
            "Mã hóa dữ liệu truyền trên mạng"
          ],
          "correctAnswer": "Chia sẻ một địa chỉ IP public cho nhiều máy trong mạng LAN",
          "reason": "NAT cho phép nhiều thiết bị trong mạng LAN sử dụng chung một địa chỉ IP public để truy cập Internet."
        },
        {
          "id": 29,
          "question": "Giao thức ICMP thường được sử dụng cho mục đích gì?",
          "options": [
            "Truyền tải tập tin",
            "Gửi email",
            "Kiểm tra kết nối và thông báo lỗi",
            "Phân giải tên miền"
          ],
          "correctAnswer": "Kiểm tra kết nối và thông báo lỗi",
          "reason": "ICMP (Internet Control Message Protocol) được sử dụng để gửi thông báo lỗi, kiểm tra kết nối (ping, traceroute)."
        },
        {
          "id": 30,
          "question": "Giao thức ARP dùng để làm gì?",
          "options": [
            "Phân giải địa chỉ IP thành MAC",
            "Phân giải tên miền thành IP",
            "Định tuyến gói tin",
            "Cấp phát IP động"
          ],
          "correctAnswer": ["Phân giải địa chỉ IP thành MAC"],
          "reason": "ARP dùng để phân giải địac chỉ IP thành MAC"
        }
      ]
    },
    {
      "id": 5,
      "title": "Đề thi số 3",
      "timeLimit": 900,
      "questions": [
        {
          "id": 1,
          "question": "Giao thức nào sau đây hoạt động ở tầng Transport?",
          "options": ["IP", "TCP", "HTTP", "FTP"],
          "correctAnswer": ["TCP"],
          "reason": "TCP (Transmission Control Protocol) là giao thức hướng kết nối, đảm bảo độ tin cậy, hoạt động ở tầng Transport. IP (Internet Protocol) hoạt động ở tầng Network. HTTP (Hypertext Transfer Protocol) và FTP (File Transfer Protocol) hoạt động ở tầng Application."
        },
        {
          "id": 2,
          "question": "Đâu là đặc điểm của kiến trúc bộ nhớ phân cấp (Hierarchical Memory)?",
          "options": [
            "Tất cả các cấp bộ nhớ có tốc độ truy cập như nhau",
            "Càng gần CPU, dung lượng càng lớn và tốc độ càng chậm",
            "Càng gần CPU, dung lượng càng nhỏ và tốc độ càng nhanh",
            "Bộ nhớ chính luôn có dung lượng lớn hơn bộ nhớ đệm"
          ],
          "correctAnswer": [
            "Càng gần CPU, dung lượng càng nhỏ và tốc độ càng nhanh"
          ],
          "reason": "Kiến trúc bộ nhớ phân cấp tổ chức bộ nhớ thành nhiều cấp, với các cấp gần CPU hơn (như cache) có dung lượng nhỏ hơn nhưng tốc độ truy cập nhanh hơn, và các cấp xa hơn (như bộ nhớ chính, ổ đĩa) có dung lượng lớn hơn nhưng tốc độ chậm hơn."
        },
        {
          "id": 3,
          "question": "Độ phức tạp thời gian của thuật toán tìm kiếm nhị phân (Binary Search) trên mảng đã sắp xếp là bao nhiêu?",
          "options": ["O(n)", "O(log n)", "O(n log n)", "O(n^2)"],
          "correctAnswer": ["O(log n)"],
          "reason": "Tìm kiếm nhị phân chia đôi phạm vi tìm kiếm sau mỗi bước, do đó độ phức tạp thời gian là O(log n)."
        },
        {
          "id": 4,
          "question": "Tiến trình (Process) là gì?",
          "options": [
            "Một chương trình đang được thực thi",
            "Một đơn vị cấp phát tài nguyên trong hệ điều hành",
            "Một luồng thực thi trong chương trình",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": ["Tất cả các đáp án trên"],
          "reason": "Tiến trình là một chương trình đang được thực thi, bao gồm mã chương trình, dữ liệu, con trỏ lệnh, tập các thanh ghi, và là đơn vị cấp phát tài nguyên (CPU, bộ nhớ,...) trong hệ điều hành. Một tiến trình có thể có nhiều luồng."
        },
        {
          "id": 5,
          "question": "Tính đóng gói (Encapsulation) trong lập trình hướng đối tượng có nghĩa là gì?",
          "options": [
            "Che giấu thông tin và hành vi bên trong của đối tượng",
            "Cho phép các đối tượng kế thừa các thuộc tính và phương thức của nhau",
            "Cho phép một đối tượng có nhiều hình thái khác nhau",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": [
            "Che giấu thông tin và hành vi bên trong của đối tượng"
          ],
          "reason": "Tính đóng gói giúp che giấu thông tin và hành vi bên trong của đối tượng, chỉ cho phép truy cập thông qua các phương thức public, tăng tính bảo mật và dễ bảo trì."
        },
        {
          "id": 6,
          "question": "Ngôn ngữ lập trình nào sau đây là ngôn ngữ lập trình thông dịch?",
          "options": ["C", "C++", "Java", "Python"],
          "correctAnswer": ["Python"],
          "reason": "Python là ngôn ngữ lập trình thông dịch, mã nguồn được thực thi từng dòng một bởi trình thông dịch. C, C++ là ngôn ngữ biên dịch, mã nguồn cần được biên dịch thành mã máy trước khi thực thi. Java là ngôn ngữ vừa biên dịch vừa thông dịch."
        },
        {
          "id": 7,
          "question": "Mô hình Waterfall trong kỹ nghệ phần mềm phù hợp với loại dự án nào?",
          "options": [
            "Dự án có yêu cầu thay đổi thường xuyên",
            "Dự án có yêu cầu rõ ràng và ít thay đổi",
            "Dự án phát triển nhanh",
            "Tất cả các loại dự án"
          ],
          "correctAnswer": ["Dự án có yêu cầu rõ ràng và ít thay đổi"],
          "reason": "Mô hình Waterfall là mô hình tuần tự, các giai đoạn được thực hiện nối tiếp nhau. Mô hình này phù hợp với các dự án có yêu cầu rõ ràng, ít thay đổi."
        },
        {
          "id": 8,
          "question": "Ai là người chịu trách nhiệm chính trong việc quản lý rủi ro của dự án?",
          "options": [
            "Lập trình viên",
            "Kiểm thử viên",
            "Quản lý dự án",
            "Khách hàng"
          ],
          "correctAnswer": ["Quản lý dự án"],
          "reason": "Quản lý dự án là người chịu trách nhiệm chính trong việc lập kế hoạch, điều phối, giám sát và quản lý rủi ro của dự án."
        },
        {
          "id": 9,
          "question": "Trong cơ sở dữ liệu quan hệ, khóa ngoại (Foreign Key) là gì?",
          "options": [
            "Một thuộc tính dùng để định danh duy nhất một bản ghi trong bảng",
            "Một thuộc tính tham chiếu đến khóa chính của bảng khác",
            "Một thuộc tính không được phép null",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": [
            "Một thuộc tính tham chiếu đến khóa chính của bảng khác"
          ],
          "reason": "Khóa ngoại dùng để thiết lập mối quan hệ giữa các bảng, tham chiếu đến khóa chính của bảng khác, đảm bảo tính toàn vẹn tham chiếu."
        },
        {
          "id": 10,
          "question": "Địa chỉ IP nào sau đây là địa chỉ private?",
          "options": ["172.32.0.1", "192.168.1.1", "8.8.8.8", "203.0.113.1"],
          "correctAnswer": ["192.168.1.1"],
          "reason": "Địa chỉ private là địa chỉ được sử dụng trong mạng nội bộ, không được định tuyến trên Internet. 192.168.0.0/16 là dải địa chỉ private, ngoài ra còn có 10.0.0.0/8 và 172.16.0.0/12 đến 172.31.0.0/12."
        },
        {
          "id": 11,
          "question": "Stack (ngăn xếp) là cấu trúc dữ liệu hoạt động theo nguyên tắc nào?",
          "options": [
            "FIFO (First In, First Out)",
            "LIFO (Last In, First Out)",
            "Cả hai đáp án trên",
            "Không theo nguyên tắc nào cả"
          ],
          "correctAnswer": ["LIFO (Last In, First Out)"],
          "reason": "Stack là cấu trúc dữ liệu hoạt động theo nguyên tắc LIFO, phần tử được thêm vào cuối cùng sẽ được lấy ra đầu tiên."
        },
        {
          "id": 12,
          "question": "Tiến trình ở trạng thái 'Blocked' có nghĩa là gì?",
          "options": [
            "Tiến trình đang được thực thi",
            "Tiến trình đã kết thúc",
            "Tiến trình đang chờ một sự kiện nào đó xảy ra",
            "Tiến trình sẵn sàng để được thực thi"
          ],
          "correctAnswer": ["Tiến trình đang chờ một sự kiện nào đó xảy ra"],
          "reason": "Tiến trình ở trạng thái 'Blocked' (hay 'Waiting') khi nó đang chờ đợi một sự kiện nào đó, ví dụ như hoàn thành I/O, nhận tín hiệu,... "
        },
        {
          "id": 13,
          "question": "Kế thừa (Inheritance) trong lập trình hướng đối tượng giúp:",
          "options": [
            "Tái sử dụng code",
            "Tăng tính đóng gói",
            "Tăng tính đa hình",
            "Giảm sự phụ thuộc giữa các class"
          ],
          "correctAnswer": ["Tái sử dụng code"],
          "reason": "Kế thừa cho phép lớp con (subclass) kế thừa các thuộc tính và phương thức của lớp cha (superclass), giúp tái sử dụng code, giảm thiểu việc viết lại code trùng lặp."
        },
        {
          "id": 14,
          "question": "Đâu là đặc điểm của ngôn ngữ lập trình bậc cao?",
          "options": [
            "Gần với ngôn ngữ máy",
            "Khó đọc, khó hiểu",
            "Dễ đọc, dễ hiểu, gần với ngôn ngữ tự nhiên",
            "Chỉ có thể chạy trên một loại máy tính nhất định"
          ],
          "correctAnswer": ["Dễ đọc, dễ hiểu, gần với ngôn ngữ tự nhiên"],
          "reason": "Ngôn ngữ lập trình bậc cao có cú pháp gần với ngôn ngữ tự nhiên, dễ đọc, dễ hiểu và dễ viết hơn so với ngôn ngữ lập trình bậc thấp (như hợp ngữ)."
        },
        {
          "id": 15,
          "question": "Ràng buộc toàn vẹn (Integrity Constraint) trong cơ sở dữ liệu là gì?",
          "options": [
            "Các quy tắc đảm bảo tính chính xác và hợp lệ của dữ liệu",
            "Các quy tắc bảo mật dữ liệu",
            "Các quy tắc tối ưu hóa truy vấn",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": [
            "Các quy tắc đảm bảo tính chính xác và hợp lệ của dữ liệu"
          ],
          "reason": "Ràng buộc toàn vẹn là các quy tắc được định nghĩa để đảm bảo tính chính xác, nhất quán và hợp lệ của dữ liệu trong cơ sở dữ liệu, ví dụ như ràng buộc not null, unique, check, foreign key,..."
        },
        {
          "id": 16,
          "question": "Phương pháp kiểm thử hộp đen (Black-box Testing) tập trung vào:",
          "options": [
            "Kiểm tra cấu trúc bên trong của code",
            "Kiểm tra các chức năng của phần mềm dựa trên đặc tả yêu cầu",
            "Kiểm tra hiệu năng của phần mềm",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": [
            "Kiểm tra các chức năng của phần mềm dựa trên đặc tả yêu cầu"
          ],
          "reason": "Kiểm thử hộp đen tập trung vào kiểm tra các chức năng của phần mềm dựa trên đặc tả yêu cầu mà không quan tâm đến cấu trúc bên trong của code."
        },
        {
          "id": 17,
          "question": "Scrum là một framework thuộc phương pháp phát triển phần mềm nào?",
          "options": ["Waterfall", "Agile", "Spiral", "V-Model"],
          "correctAnswer": ["Agile"],
          "reason": "Scrum là một framework phổ biến trong phát triển phần mềm theo phương pháp Agile, tập trung vào việc phát triển lặp và tăng dần."
        },
        {
          "id": 18,
          "question": "Chức năng chính của bộ nhớ cache là gì?",
          "options": [
            "Lưu trữ dữ liệu lâu dài",
            "Tăng tốc độ truy cập dữ liệu cho CPU",
            "Lưu trữ hệ điều hành",
            "Thực hiện các phép tính toán"
          ],
          "correctAnswer": ["Tăng tốc độ truy cập dữ liệu cho CPU"],
          "reason": "Cache là bộ nhớ nhỏ, tốc độ cao, nằm giữa CPU và RAM, lưu trữ các dữ liệu và lệnh thường xuyên được sử dụng để tăng tốc độ truy cập dữ liệu cho CPU, giảm thời gian chờ đợi RAM."
        },
        {
          "id": 19,
          "question": "Khái niệm 'coupling' trong thiết kế phần mềm đề cập đến:",
          "options": [
            "Mức độ phụ thuộc giữa các module",
            "Mức độ gắn kết bên trong một module",
            "Số lượng module trong hệ thống",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": ["Mức độ phụ thuộc giữa các module"],
          "reason": "Coupling đề cập đến mức độ phụ thuộc lẫn nhau giữa các module. Coupling thấp (loose coupling) là mong muốn, vì nó giúp các module ít phụ thuộc vào nhau hơn, dễ dàng thay đổi và bảo trì."
        },
        {
          "id": 20,
          "question": "Tiến trình có thể chuyển từ trạng thái 'Running' sang trạng thái nào sau đây?",
          "options": [
            "Ready",
            "Blocked",
            "Terminated",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": ["Tất cả các đáp án trên"],
          "reason": "Một tiến trình đang ở trạng thái 'Running' (đang được CPU thực thi) có thể chuyển sang trạng thái 'Ready' (sẵn sàng để thực thi, khi bị preempt bởi tiến trình khác), 'Blocked' (chờ đợi sự kiện), hoặc 'Terminated' (khi kết thúc)."
        },
        {
          "id": 21,
          "question": "Trong Java, từ khóa 'final' dùng để làm gì?",
          "options": [
            "Khai báo hằng số",
            "Ngăn không cho lớp khác kế thừa",
            "Ngăn không cho phương thức bị override",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": ["Tất cả các đáp án trên"],
          "reason": "Từ khóa 'final' trong Java có thể được sử dụng để khai báo hằng số (biến không thể thay đổi giá trị), ngăn không cho lớp khác kế thừa (final class), và ngăn không cho phương thức bị override (final method)."
        },
        {
          "id": 22,
          "question": "Lệnh SQL nào sau đây dùng để thêm dữ liệu vào bảng?",
          "options": ["SELECT", "INSERT", "UPDATE", "DELETE"],
          "correctAnswer": ["INSERT"],
          "reason": "Lệnh INSERT INTO được sử dụng để thêm dữ liệu (bản ghi) mới vào bảng trong cơ sở dữ liệu."
        },
        {
          "id": 23,
          "question": "Đoạn code Java sau đây in ra kết quả gì?\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int x = 5;\n        if (x > 3) {\n            System.out.println(\"A\");\n        } else if (x < 5) {\n            System.out.println(\"B\");\n        } else {\n            System.out.println(\"C\");\n        }\n    }\n}\n```",
          "options": ["A", "B", "C", "Không in ra gì cả"],
          "correctAnswer": ["A"],
          "reason": "Vì x = 5 > 3 nên điều kiện đầu tiên `x > 3` là đúng, do đó chương trình in ra \"A\" và các khối else if và else phía sau sẽ không được thực thi."
        },
        {
          "id": 24,
          "question": "Đoạn code Java sau đây bị lỗi gì?\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        System.out.println(s.length);\n    }\n}\n```",
          "options": [
            "Thiếu dấu ngoặc nhọn",
            "Thiếu dấu chấm phẩy",
            "Sai tên phương thức",
            "Không có lỗi"
          ],
          "correctAnswer": ["Thiếu dấu chấm phẩy"],
          "reason": "Câu lệnh `System.out.println(s.length)` thiếu dấu chấm phẩy kết thúc câu lệnh. Đúng phải là `System.out.println(s.length());` và phương thức `length()` phải có ngoặc đơn."
        },
        {
          "id": 25,
          "question": "Chọn câu lệnh SQL đúng để lấy tất cả dữ liệu từ bảng 'Customers' có 'Country' là 'Germany'?",
          "options": [
            "SELECT * FROM Customers WHERE Country = 'Germany'",
            "SELECT Customers WHERE Country = 'Germany'",
            "SELECT * FROM Customers WHEN Country = 'Germany'",
            "SELECT * FROM Customers GROUP BY Country = 'Germany'"
          ],
          "correctAnswer": [
            "SELECT * FROM Customers WHERE Country = 'Germany'"
          ],
          "reason": "Câu lệnh `SELECT * FROM Customers WHERE Country = 'Germany'` sẽ lấy tất cả các cột từ bảng 'Customers' với điều kiện 'Country' bằng 'Germany'."
        },
        {
          "id": 26,
          "question": "Đâu không phải là một loại deadlock?",
          "options": [
            "Circular wait",
            "Hold and wait",
            "No preemption",
            "Mutual exclusion",
            "Starvation"
          ],
          "correctAnswer": ["Starvation"],
          "reason": "Starvation (đói tài nguyên) là tình trạng một tiến trình bị từ chối cấp phát tài nguyên liên tục trong một thời gian dài, không dẫn tới deadlock. Bốn điều kiện dẫn đến deadlock bao gồm: Mutual exclusion (Loại trừ lẫn nhau), Hold and wait (Giữ và chờ đợi), No preemption (Không trưng dụng), Circular wait (Chờ đợi vòng tròn)."
        },
        {
          "id": 27,
          "question": "Đâu là giao thức định tuyến động?",
          "options": ["RIP", "OSPF", "BGP", "Tất cả các đáp án trên"],
          "correctAnswer": ["Tất cả các đáp án trên"],
          "reason": "RIP (Routing Information Protocol), OSPF (Open Shortest Path First), và BGP (Border Gateway Protocol) đều là các giao thức định tuyến động, tự động cập nhật bảng định tuyến dựa trên thông tin trao đổi với các router lân cận."
        },
        {
          "id": 28,
          "question": "Phân trang (Paging) là kỹ thuật quản lý bộ nhớ cho phép:",
          "options": [
            "Không gian địa chỉ vật lý của tiến trình có thể không liên tục",
            "Chia bộ nhớ vật lý thành các frame có kích thước cố định",
            "Chia không gian địa chỉ logic thành các page có kích thước bằng frame",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": ["Tất cả các đáp án trên"],
          "reason": "Phân trang là kỹ thuật quản lý bộ nhớ chia bộ nhớ vật lý thành các frame có kích thước cố định, chia không gian địa chỉ logic thành các page có kích thước bằng frame, cho phép không gian địa chỉ vật lý của tiến trình có thể không liên tục, linh hoạt trong cấp phát bộ nhớ."
        },
        {
          "id": 29,
          "question": "ACID là viết tắt của các thuộc tính nào trong các giao dịch cơ sở dữ liệu?",
          "options": [
            "Atomicity, Consistency, Isolation, Durability",
            "Availability, Concurrency, Integrity, Dependability",
            "Accuracy, Completeness, Isolation, Durability",
            "Atomicity, Concurrency, Integrity, Dependability"
          ],
          "correctAnswer": ["Atomicity, Consistency, Isolation, Durability"],
          "reason": "ACID là viết tắt của Atomicity (Tính nguyên tố), Consistency (Tính nhất quán), Isolation (Tính độc lập), Durability (Tính bền vững) - các thuộc tính quan trọng đảm bảo tính tin cậy của các giao dịch cơ sở dữ liệu."
        },
        {
          "id": 30,
          "question": "Đâu là phases chính của SDLC",
          "options": [
            "planning, analysis, design, implementation, testing, maintenance",
            "requirements gathering, coding, debugging, deployment",
            "initiation, execution, monitoring, closing",
            "None of above"
          ],
          "correctAnswer": [
            "planning, analysis, design, implementation, testing, maintenance"
          ],
          "reason": "SDLC (Software Development Life Cycle) là một quá trình phát triển phần mềm bao gồm các giai đoạn: planning (lập kế hoạch), analysis (phân tích), design (thiết kế), implementation (triển khai), testing (kiểm thử), maintenance (bảo trì)."
        }
      ]
    },
    {
      "id": 6,
      "title": "Đề thi số 4",
      "timeLimit": 9000,
      "questions": [
        {
          "id": 1,
          "question": "Mô hình OSI có bao nhiêu tầng?",
          "options": ["5", "6", "7", "8"],
          "correctAnswer": ["7"],
          "reason": "Mô hình tham chiếu OSI (Open Systems Interconnection) bao gồm 7 tầng: Physical, Data Link, Network, Transport, Session, Presentation, Application."
        },
        {
          "id": 2,
          "question": "Cache L1, L2, L3 khác nhau như thế nào?",
          "options": [
            "L1 lớn nhất, L3 nhỏ nhất",
            "L1 nhanh nhất, L3 chậm nhất",
            "L3 gần CPU nhất",
            "Tất cả đều sai"
          ],
          "correctAnswer": ["L1 nhanh nhất, L3 chậm nhất"],
          "reason": "Cache L1 có dung lượng nhỏ nhất, nhanh nhất và gần CPU nhất. Cache L2 lớn hơn, chậm hơn L1 nhưng nhanh hơn L3. Cache L3 có dung lượng lớn nhất, chậm nhất trong các loại cache nhưng vẫn nhanh hơn RAM."
        },
        {
          "id": 3,
          "question": "Thuật toán sắp xếp nào sau đây có độ phức tạp thời gian trung bình là O(n log n)?",
          "options": [
            "Bubble Sort",
            "Insertion Sort",
            "Merge Sort",
            "Selection Sort"
          ],
          "correctAnswer": ["Merge Sort"],
          "reason": "Merge Sort (Sắp xếp trộn) là thuật toán sắp xếp dựa trên chia để trị, có độ phức tạp thời gian trung bình và trường hợp xấu nhất là O(n log n). Bubble Sort, Insertion Sort, Selection Sort đều có độ phức tạp thời gian trung bình và trường hợp xấu nhất là O(n^2)."
        },
        {
          "id": 4,
          "question": "Tiến trình ở trạng thái 'Ready' có nghĩa là gì?",
          "options": [
            "Tiến trình đang được thực thi",
            "Tiến trình đã kết thúc",
            "Tiến trình đang chờ một sự kiện nào đó xảy ra",
            "Tiến trình sẵn sàng để được thực thi nhưng đang chờ CPU"
          ],
          "correctAnswer": [
            "Tiến trình sẵn sàng để được thực thi nhưng đang chờ CPU"
          ],
          "reason": "Tiến trình ở trạng thái 'Ready' (hay 'Runnable') khi nó đã sẵn sàng để được thực thi nhưng đang chờ được cấp phát CPU."
        },
        {
          "id": 5,
          "question": "Tính đa hình (Polymorphism) trong lập trình hướng đối tượng có nghĩa là gì?",
          "options": [
            "Che giấu thông tin và hành vi bên trong của đối tượng",
            "Cho phép các đối tượng kế thừa các thuộc tính và phương thức của nhau",
            "Cho phép một đối tượng có nhiều hình thái khác nhau, thực hiện cùng một hành động theo những cách khác nhau",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": [
            "Cho phép một đối tượng có nhiều hình thái khác nhau, thực hiện cùng một hành động theo những cách khác nhau"
          ],
          "reason": "Tính đa hình cho phép các đối tượng thuộc các lớp khác nhau cùng phản hồi với một phương thức theo cách riêng của chúng, giúp code linh hoạt và dễ mở rộng hơn."
        },
        {
          "id": 6,
          "question": "Ngôn ngữ lập trình nào sau đây không hỗ trợ lập trình hướng đối tượng?",
          "options": ["Java", "C++", "Python", "C"],
          "correctAnswer": ["C"],
          "reason": "C là ngôn ngữ lập trình cấu trúc, không hỗ trợ các khái niệm của lập trình hướng đối tượng như lớp, đối tượng, kế thừa, đa hình. Java, C++, Python đều là ngôn ngữ lập trình hướng đối tượng."
        },
        {
          "id": 7,
          "question": "Mô hình Agile trong kỹ nghệ phần mềm tập trung vào:",
          "options": [
            "Phát triển phần mềm theo các giai đoạn tuần tự",
            "Phát triển phần mềm theo kiểu lặp và tăng dần",
            "Hoàn thành toàn bộ dự án trước khi bàn giao cho khách hàng",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": ["Phát triển phần mềm theo kiểu lặp và tăng dần"],
          "reason": "Mô hình Agile là một tập hợp các phương pháp phát triển phần mềm linh hoạt, tập trung vào việc phát triển lặp (iterative) và tăng dần (incremental), cho phép thay đổi yêu cầu linh hoạt trong quá trình phát triển."
        },
        {
          "id": 8,
          "question": "Ai là người chịu trách nhiệm ước lượng nỗ lực và thời gian cho các công việc trong dự án?",
          "options": [
            "Lập trình viên",
            "Kiểm thử viên",
            "Quản lý dự án",
            "Nhóm phát triển"
          ],
          "correctAnswer": ["Nhóm phát triển"],
          "reason": "Nhóm phát triển (bao gồm lập trình viên, kiểm thử viên,...) là những người trực tiếp thực hiện công việc, do đó họ là người phù hợp nhất để ước lượng nỗ lực và thời gian cần thiết."
        },
        {
          "id": 9,
          "question": "Trong cơ sở dữ liệu quan hệ, ràng buộc UNIQUE đảm bảo điều gì?",
          "options": [
            "Một cột không được phép có giá trị NULL",
            "Một cột chỉ chứa các giá trị duy nhất",
            "Một cột là khóa chính của bảng",
            "Một cột tham chiếu đến khóa chính của bảng khác"
          ],
          "correctAnswer": ["Một cột chỉ chứa các giá trị duy nhất"],
          "reason": "Ràng buộc UNIQUE đảm bảo rằng tất cả các giá trị trong một cột (hoặc tập hợp các cột) là duy nhất, không trùng lặp."
        },
        {
          "id": 10,
          "question": "Subnet mask dùng để làm gì?",
          "options": [
            "Xác định phần mạng và phần host của địa chỉ IP",
            "Mã hóa dữ liệu truyền trên mạng",
            "Ngăn chặn truy cập trái phép vào mạng",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": ["Xác định phần mạng và phần host của địa chỉ IP"],
          "reason": "Subnet mask là một dãy bit được sử dụng kết hợp với địa chỉ IP để xác định phần nào của địa chỉ IP là địa chỉ mạng (network ID) và phần nào là địa chỉ host (host ID) trong một mạng con (subnet)."
        },
        {
          "id": 11,
          "question": "Queue (hàng đợi) là cấu trúc dữ liệu hoạt động theo nguyên tắc nào?",
          "options": [
            "FIFO (First In, First Out)",
            "LIFO (Last In, First Out)",
            "Cả hai đáp án trên",
            "Không theo nguyên tắc nào cả"
          ],
          "correctAnswer": ["FIFO (First In, First Out)"],
          "reason": "Queue là cấu trúc dữ liệu hoạt động theo nguyên tắc FIFO, phần tử được thêm vào đầu tiên sẽ được lấy ra đầu tiên."
        },
        {
          "id": 12,
          "question": "Trạng thái 'Terminated' của tiến trình có nghĩa là gì?",
          "options": [
            "Tiến trình đang được thực thi",
            "Tiến trình đã hoàn thành hoặc bị hủy bỏ",
            "Tiến trình đang chờ một sự kiện nào đó xảy ra",
            "Tiến trình sẵn sàng để được thực thi"
          ],
          "correctAnswer": ["Tiến trình đã hoàn thành hoặc bị hủy bỏ"],
          "reason": "Tiến trình ở trạng thái 'Terminated' khi nó đã hoàn thành việc thực thi hoặc bị hủy bỏ bởi hệ điều hành hoặc bởi chính nó."
        },
        {
          "id": 13,
          "question": "Đóng gói (Encapsulation) trong lập trình hướng đối tượng KHÔNG giúp:",
          "options": [
            "Che giấu dữ liệu",
            "Giảm sự phụ thuộc giữa các class",
            "Tái sử dụng code",
            "Bảo vệ dữ liệu nội bộ của object"
          ],
          "correctAnswer": ["Tái sử dụng code"],
          "reason": "Đóng gói (Encapsulation) giúp che giấu thông tin, giảm sự phụ thuộc giữa các class, bảo vệ dữ liệu nội bộ của object, nhưng không trực tiếp giúp tái sử dụng code. Tái sử dụng code là lợi ích của kế thừa (Inheritance)."
        },
        {
          "id": 14,
          "question": "Đặc điểm của ngôn ngữ lập trình hướng đối tượng bao gồm:",
          "options": [
            "Tính trừu tượng, đóng gói, kế thừa, đa hình",
            "Chỉ tập trung vào dữ liệu",
            "Không hỗ trợ hàm",
            "Tất cả các đáp án trên đều sai"
          ],
          "correctAnswer": ["Tính trừu tượng, đóng gói, kế thừa, đa hình"],
          "reason": "Ngôn ngữ lập trình hướng đối tượng có các đặc điểm chính như: tính trừu tượng (abstraction), tính đóng gói (encapsulation), tính kế thừa (inheritance), tính đa hình (polymorphism)."
        },
        {
          "id": 15,
          "question": "Normal Form (Dạng chuẩn) trong cơ sở dữ liệu dùng để làm gì?",
          "options": [
            "Tăng tốc độ truy vấn",
            "Giảm thiểu dư thừa dữ liệu và đảm bảo tính nhất quán",
            "Bảo mật dữ liệu",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": [
            "Giảm thiểu dư thừa dữ liệu và đảm bảo tính nhất quán"
          ],
          "reason": "Chuẩn hóa cơ sở dữ liệu (Database Normalization) là quá trình tổ chức dữ liệu trong cơ sở dữ liệu để giảm thiểu dư thừa dữ liệu, loại bỏ các bất thường (anomalies) khi thêm, xóa, sửa dữ liệu, và đảm bảo tính nhất quán của dữ liệu."
        },
        {
          "id": 16,
          "question": "Phương pháp kiểm thử hộp trắng (White-box Testing) tập trung vào:",
          "options": [
            "Kiểm tra các chức năng của phần mềm dựa trên đặc tả yêu cầu",
            "Kiểm tra cấu trúc bên trong của code, các luồng thực thi",
            "Kiểm tra hiệu năng của phần mềm",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": [
            "Kiểm tra cấu trúc bên trong của code, các luồng thực thi"
          ],
          "reason": "Kiểm thử hộp trắng (hay kiểm thử cấu trúc) tập trung vào kiểm tra cấu trúc bên trong của code, các luồng thực thi, các nhánh rẽ, vòng lặp,... để đảm bảo code hoạt động đúng đắn."
        },
        {
          "id": 17,
          "question": "Kanban là một framework thuộc phương pháp phát triển phần mềm nào?",
          "options": ["Waterfall", "Agile", "Spiral", "V-Model"],
          "correctAnswer": ["Agile"],
          "reason": "Kanban là một framework quản lý luồng công việc, thường được sử dụng trong phát triển phần mềm Agile, giúp trực quan hóa quy trình làm việc, giới hạn công việc đang thực hiện (WIP), và cải tiến liên tục."
        },
        {
          "id": 18,
          "question": "Bộ nhớ ROM (Read-Only Memory) dùng để làm gì?",
          "options": [
            "Lưu trữ dữ liệu tạm thời",
            "Lưu trữ chương trình khởi động máy tính (firmware)",
            "Tăng tốc độ truy cập dữ liệu",
            "Thực hiện các phép tính toán"
          ],
          "correctAnswer": [
            "Lưu trữ chương trình khởi động máy tính (firmware)"
          ],
          "reason": "ROM là bộ nhớ chỉ đọc, không bị mất dữ liệu khi tắt nguồn, thường được sử dụng để lưu trữ firmware như BIOS (Basic Input/Output System) - chương trình khởi động máy tính."
        },
        {
          "id": 19,
          "question": "Khái niệm 'cohesion' trong thiết kế phần mềm đề cập đến:",
          "options": [
            "Mức độ phụ thuộc giữa các module",
            "Mức độ gắn kết, liên quan giữa các thành phần bên trong một module",
            "Số lượng module trong hệ thống",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": [
            "Mức độ gắn kết, liên quan giữa các thành phần bên trong một module"
          ],
          "reason": "Cohesion đề cập đến mức độ gắn kết, liên quan giữa các thành phần (hàm, lớp,...) bên trong một module. Cohesion cao (high cohesion) là mong muốn, vì nó cho thấy các thành phần trong module cùng thực hiện một nhiệm vụ chung, module có tính tập trung cao, dễ hiểu và dễ bảo trì."
        },
        {
          "id": 20,
          "question": "Khi một tiến trình yêu cầu I/O, nó sẽ chuyển từ trạng thái 'Running' sang trạng thái nào?",
          "options": ["Ready", "Blocked", "Terminated", "New"],
          "correctAnswer": ["Blocked"],
          "reason": "Khi một tiến trình đang chạy (Running) yêu cầu thực hiện thao tác I/O (nhập/xuất), nó sẽ chuyển sang trạng thái 'Blocked' (hay 'Waiting') để chờ đợi I/O hoàn thành."
        },
        {
          "id": 21,
          "question": "Trong Java, interface là gì?",
          "options": [
            "Một lớp có thể chứa các phương thức abstract và non-abstract",
            "Một bản thiết kế cho các đối tượng",
            "Một tập hợp các phương thức abstract mà các lớp khác phải implement",
            "Một kiểu dữ liệu nguyên thủy"
          ],
          "correctAnswer": [
            "Một tập hợp các phương thức abstract mà các lớp khác phải implement"
          ],
          "reason": "Interface trong Java là một tập hợp các phương thức abstract (không có phần thân), các hằng số, mà các lớp khác phải triển khai (implement) để cung cấp phần thân cho các phương thức đó. Interface định nghĩa một 'hợp đồng' mà các lớp implement phải tuân theo."
        },
        {
          "id": 22,
          "question": "Lệnh SQL nào sau đây dùng để cập nhật dữ liệu trong bảng?",
          "options": ["SELECT", "INSERT", "UPDATE", "DELETE"],
          "correctAnswer": ["UPDATE"],
          "reason": "Lệnh UPDATE được sử dụng để sửa đổi, cập nhật dữ liệu (bản ghi) trong bảng cơ sở dữ liệu."
        },
        {
          "id": 23,
          "question": "Đoạn code Java sau đây in ra kết quả gì?\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int x = 10;\n        if (x > 5) {\n            System.out.println(\"A\");\n        } else if (x < 10) {\n            System.out.println(\"B\");\n        } else {\n          System.out.println(\"C\");\n        } \n    }\n}\n```",
          "options": ["A", "B", "C", "Không in ra gì cả"],
          "correctAnswer": ["A"],
          "reason": "Vì x = 10 > 5 nên điều kiện `x > 5` là đúng, chương trình sẽ in ra \"A\" và các khối else if và else phía sau sẽ không được thực thi."
        },
        {
          "id": 24,
          "question": "Đoạn code Java sau đây bị lỗi gì?\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10\n        int b = 5;\n        System.out.println(a + b);\n    }\n}\n```",
          "options": [
            "Thiếu dấu ngoặc nhọn",
            "Thiếu dấu chấm phẩy",
            "Sai tên biến",
            "Không có lỗi"
          ],
          "correctAnswer": ["Thiếu dấu chấm phẩy"],
          "reason": "Câu lệnh `int a = 10` thiếu dấu chấm phẩy kết thúc câu lệnh. Đúng phải là `int a = 10;`"
        },
        {
          "id": 25,
          "question": "Chọn câu lệnh SQL đúng để lấy tất cả các cột từ bảng 'Employees' sắp xếp theo cột 'LastName'?",
          "options": [
            "SELECT * FROM Employees ORDER BY LastName",
            "SELECT * FROM Employees SORT BY LastName",
            "SELECT * FROM Employees GROUP BY LastName",
            "SELECT ALL FROM Employees ORDER BY LastName"
          ],
          "correctAnswer": ["SELECT * FROM Employees ORDER BY LastName"],
          "reason": "Câu lệnh `SELECT * FROM Employees ORDER BY LastName` sẽ lấy tất cả các cột từ bảng 'Employees' và sắp xếp kết quả theo thứ tự cột 'LastName'."
        },
        {
          "id": 26,
          "question": "Đâu KHÔNG phải là một trong bốn điều kiện gây ra deadlock?",
          "options": [
            "Mutual exclusion",
            "Hold and wait",
            "No preemption",
            "Circular wait",
            "Process termination"
          ],
          "correctAnswer": ["Process termination"],
          "reason": "Process termination (kết thúc tiến trình) không phải là điều kiện gây ra deadlock. Bốn điều kiện cần thiết cho deadlock xảy ra là: Mutual exclusion (Loại trừ lẫn nhau), Hold and wait (Giữ và chờ đợi), No preemption (Không trưng dụng), Circular wait (Chờ đợi vòng tròn)."
        },
        {
          "id": 27,
          "question": "Giao thức nào sau đây KHÔNG phải là giao thức định tuyến?",
          "options": ["RIP", "OSPF", "BGP", "ARP"],
          "correctAnswer": ["ARP"],
          "reason": "ARP (Address Resolution Protocol) là giao thức phân giải địa chỉ, dùng để tìm địa chỉ MAC tương ứng với một địa chỉ IP trong mạng cục bộ, không phải là giao thức định tuyến. RIP, OSPF, BGP là các giao thức định tuyến."
        },
        {
          "id": 28,
          "question": "Kỹ thuật phân đoạn (Segmentation) trong quản lý bộ nhớ:",
          "options": [
            "Chia bộ nhớ vật lý thành các frame có kích thước cố định",
            "Chia không gian địa chỉ logic thành các segment có kích thước khác nhau",
            "Cho phép không gian địa chỉ vật lý của tiến trình có thể không liên tục",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": [
            "Chia không gian địa chỉ logic thành các segment có kích thước khác nhau"
          ],
          "reason": "Phân đoạn (Segmentation) là kỹ thuật quản lý bộ nhớ chia không gian địa chỉ logic của tiến trình thành các segment có kích thước khác nhau, mỗi segment chứa một đơn vị logic của chương trình (ví dụ: hàm, mảng,...), giúp quản lý bộ nhớ linh hoạt hơn."
        },
        {
          "id": 29,
          "question": "Transaction trong cơ sở dữ liệu cần đảm bảo các tính chất nào?",
          "options": [
            "Atomicity, Consistency, Isolation, Durability",
            "Availability, Confidentiality, Integrity, Dependability",
            "Accuracy, Completeness, Isolation, Durability",
            "Atomicity, Concurrency, Integrity, Dependability"
          ],
          "correctAnswer": ["Atomicity, Consistency, Isolation, Durability"],
          "reason": "Một transaction (giao dịch) trong cơ sở dữ liệu cần đảm bảo 4 tính chất ACID: Atomicity (Tính nguyên tố), Consistency (Tính nhất quán), Isolation (Tính độc lập), Durability (Tính bền vững) để đảm bảo tính tin cậy và toàn vẹn dữ liệu."
        },
        {
          "id": 30,
          "question": "Hoạt động nào sau đây KHÔNG thuộc pha 'testing' trong SDLC?",
          "options": [
            "Unit testing",
            "Integration testing",
            "System testing",
            "Requirement analysis"
          ],
          "correctAnswer": ["Requirement analysis"],
          "reason": "Requirement analysis (phân tích yêu cầu) thuộc pha 'analysis' trong SDLC, không thuộc pha 'testing'. Unit testing, Integration testing, System testing đều là các loại kiểm thử phần mềm trong pha 'testing'."
        }
      ]
    },
    {
      "id": 7,
      "title": "Đề 5",
      "timeLimit": 6000,
      "questions": [
        {
          "id": 1,
          "question": "Giao thức nào sau đây hoạt động ở tầng Application trong mô hình OSI?",
          "options": ["TCP", "IP", "HTTP", "UDP"],
          "correctAnswer": ["HTTP"],
          "reason": "HTTP (Hypertext Transfer Protocol) là giao thức tầng ứng dụng, dùng để truyền tải dữ liệu dạng siêu văn bản giữa web server và web browser. TCP và UDP là giao thức tầng giao vận, còn IP là giao thức tầng mạng."
        },
        {
          "id": 2,
          "question": "Trong mạng máy tính, kỹ thuật nào cho phép nhiều thiết bị cùng sử dụng chung một đường truyền?",
          "options": ["Multiplexing", "Routing", "Switching", "Modulation"],
          "correctAnswer": ["Multiplexing"],
          "reason": "Multiplexing (ghép kênh) cho phép nhiều tín hiệu được truyền đồng thời trên một đường truyền vật lý duy nhất. Routing là định tuyến, Switching là chuyển mạch, và Modulation là điều chế."
        },
        {
          "id": 3,
          "question": "Cấu trúc dữ liệu nào sau đây cho phép truy cập phần tử bất kỳ với độ phức tạp thời gian O(1)?",
          "options": ["Linked List", "Array", "Stack", "Queue"],
          "correctAnswer": ["Array"],
          "reason": "Mảng (Array) cho phép truy cập trực tiếp đến phần tử bất kỳ thông qua chỉ số với độ phức tạp O(1). Linked List, Stack, và Queue không đảm bảo truy cập ngẫu nhiên với độ phức tạp O(1)."
        },
        {
          "id": 4,
          "question": "Thuật toán sắp xếp nào sau đây có độ phức tạp thời gian trung bình là O(n log n)?",
          "options": [
            "Bubble Sort",
            "Insertion Sort",
            "Merge Sort",
            "Selection Sort"
          ],
          "correctAnswer": ["Merge Sort"],
          "reason": "Merge Sort (sắp xếp trộn) có độ phức tạp thời gian trung bình là O(n log n). Bubble Sort, Insertion Sort, và Selection Sort có độ phức tạp trung bình là O(n^2)."
        },
        {
          "id": 5,
          "question": "Cache memory được sử dụng để làm gì?",
          "options": [
            "Lưu trữ dữ liệu lâu dài",
            "Tăng tốc độ truy cập dữ liệu thường xuyên sử dụng",
            "Lưu trữ hệ điều hành",
            "Kết nối các thiết bị ngoại vi"
          ],
          "correctAnswer": [
            "Tăng tốc độ truy cập dữ liệu thường xuyên sử dụng"
          ],
          "reason": "Cache memory là bộ nhớ đệm tốc độ cao, lưu trữ các dữ liệu và lệnh thường xuyên được CPU truy cập, giúp giảm thời gian truy cập trung bình."
        },
        {
          "id": 6,
          "question": "Bộ nhớ nào sau đây là bộ nhớ khả biến (volatile)?",
          "options": ["ROM", "Flash Memory", "RAM", "Hard Disk"],
          "correctAnswer": ["RAM"],
          "reason": "RAM (Random Access Memory) là bộ nhớ khả biến, mất dữ liệu khi mất điện. ROM, Flash Memory và Hard Disk là bộ nhớ bất biến (non-volatile)."
        },
        {
          "id": 7,
          "question": "Tiến trình (process) trong hệ điều hành là gì?",
          "options": [
            "Một chương trình đang được thực thi",
            "Một đoạn mã của chương trình",
            "Một thiết bị phần cứng",
            "Một người dùng"
          ],
          "correctAnswer": ["Một chương trình đang được thực thi"],
          "reason": "Tiến trình là một chương trình đang trong trạng thái thực thi, bao gồm mã chương trình, dữ liệu, bộ đếm chương trình, các thanh ghi, stack, v.v."
        },
        {
          "id": 8,
          "question": "Deadlock trong hệ điều hành xảy ra khi nào?",
          "options": [
            "Hai hoặc nhiều tiến trình cùng truy cập vào một tài nguyên",
            "Hai hoặc nhiều tiến trình chờ đợi lẫn nhau để giải phóng tài nguyên",
            "Một tiến trình bị treo",
            "Hệ điều hành bị lỗi"
          ],
          "correctAnswer": [
            "Hai hoặc nhiều tiến trình chờ đợi lẫn nhau để giải phóng tài nguyên"
          ],
          "reason": "Deadlock xảy ra khi hai hoặc nhiều tiến trình rơi vào trạng thái chờ đợi vô hạn, mỗi tiến trình giữ một tài nguyên và chờ đợi tài nguyên đang bị giữ bởi tiến trình khác."
        },
        {
          "id": 9,
          "question": "Tính chất nào sau đây KHÔNG phải là đặc điểm của lập trình hướng đối tượng?",
          "options": [
            "Tính đóng gói (Encapsulation)",
            "Tính kế thừa (Inheritance)",
            "Tính thủ tục (Procedural)",
            "Tính đa hình (Polymorphism)"
          ],
          "correctAnswer": ["Tính thủ tục (Procedural)"],
          "reason": "Lập trình hướng đối tượng tập trung vào đối tượng, bao gồm các thuộc tính và phương thức. Tính thủ tục là đặc điểm của lập trình hướng thủ tục."
        },
        {
          "id": 10,
          "question": "Interface trong lập trình hướng đối tượng được sử dụng để làm gì?",
          "options": [
            "Định nghĩa một lớp",
            "Định nghĩa các phương thức trừu tượng",
            "Khởi tạo đối tượng",
            "Tất cả các phương án trên"
          ],
          "correctAnswer": ["Định nghĩa các phương thức trừu tượng"],
          "reason": "Interface định nghĩa một tập hợp các phương thức trừu tượng mà các lớp triển khai (implement) interface đó phải cung cấp cài đặt cụ thể."
        },
        {
          "id": 11,
          "question": "Ngôn ngữ lập trình nào sau đây KHÔNG phải là ngôn ngữ biên dịch?",
          "options": ["C++", "Java", "Python", "C#"],
          "correctAnswer": ["Python"],
          "reason": "Python là ngôn ngữ thông dịch, mã nguồn được thực thi từng dòng bởi trình thông dịch. C++, Java, và C# là ngôn ngữ biên dịch, mã nguồn được biên dịch thành mã máy trước khi thực thi."
        },
        {
          "id": 12,
          "question": "Bytecode trong Java là gì?",
          "options": [
            "Mã nguồn Java",
            "Mã máy",
            "Mã trung gian được thực thi bởi JVM",
            "Một loại virus máy tính"
          ],
          "correctAnswer": ["Mã trung gian được thực thi bởi JVM"],
          "reason": "Bytecode là mã trung gian được sinh ra từ mã nguồn Java, và được thực thi bởi máy ảo Java (JVM)."
        },
        {
          "id": 13,
          "question": "Ràng buộc toàn vẹn (integrity constraint) trong hệ quản trị cơ sở dữ liệu dùng để làm gì?",
          "options": [
            "Đảm bảo tính nhất quán và chính xác của dữ liệu",
            "Tăng tốc độ truy vấn",
            "Tạo bản sao lưu dữ liệu",
            "Phân quyền truy cập dữ liệu"
          ],
          "correctAnswer": ["Đảm bảo tính nhất quán và chính xác của dữ liệu"],
          "reason": "Ràng buộc toàn vẹn đảm bảo dữ liệu trong cơ sở dữ liệu luôn chính xác và nhất quán, ví dụ như ràng buộc khóa chính, khóa ngoại, miền giá trị."
        },
        {
          "id": 14,
          "question": "ACID là viết tắt của những thuộc tính nào trong giao dịch cơ sở dữ liệu?",
          "options": [
            "Atomicity, Consistency, Isolation, Durability",
            "Availability, Concurrency, Integrity, Dependability",
            "Accuracy, Completeness, Isolation, Durability",
            "Atomicity, Consistency, Integrity, Dependability"
          ],
          "correctAnswer": ["Atomicity, Consistency, Isolation, Durability"],
          "reason": "ACID là các thuộc tính đảm bảo tính tin cậy của giao dịch: Atomicity (tính nguyên tố), Consistency (tính nhất quán), Isolation (tính cô lập), Durability (tính bền vững)."
        },
        {
          "id": 15,
          "question": "Mô hình phát triển phần mềm nào sau đây phù hợp với các dự án có yêu cầu thay đổi thường xuyên?",
          "options": ["Waterfall", "Spiral", "Agile", "V-Model"],
          "correctAnswer": ["Agile"],
          "reason": "Mô hình Agile (phát triển linh hoạt) phù hợp với các dự án có yêu cầu thay đổi thường xuyên, tập trung vào việc phát triển lặp và tăng dần."
        },
        {
          "id": 16,
          "question": "UML là viết tắt của cụm từ nào?",
          "options": [
            "Unified Modeling Language",
            "Universal Modeling Language",
            "Unique Modeling Language",
            "Unified Machine Learning"
          ],
          "correctAnswer": ["Unified Modeling Language"],
          "reason": "UML (Unified Modeling Language) là ngôn ngữ mô hình hóa hợp nhất, dùng để đặc tả, trực quan hóa, xây dựng và làm tài liệu cho các hệ thống phần mềm."
        },
        {
          "id": 17,
          "question": "Biểu đồ Gantt trong quản lý dự án dùng để làm gì?",
          "options": [
            "Theo dõi tiến độ công việc",
            "Phân tích rủi ro",
            "Quản lý chi phí",
            "Phân công công việc"
          ],
          "correctAnswer": ["Theo dõi tiến độ công việc"],
          "reason": "Biểu đồ Gantt thể hiện các công việc theo thời gian, giúp theo dõi tiến độ, các công việc trễ hạn, và các mối phụ thuộc giữa các công việc."
        },
        {
          "id": 18,
          "question": "Kỹ thuật PERT trong quản lý dự án được sử dụng để làm gì?",
          "options": [
            "Ước lượng thời gian hoàn thành dự án",
            "Phân tích yêu cầu",
            "Kiểm thử phần mềm",
            "Thiết kế giao diện"
          ],
          "correctAnswer": ["Ước lượng thời gian hoàn thành dự án"],
          "reason": "PERT (Program Evaluation and Review Technique) là kỹ thuật dùng để ước lượng thời gian hoàn thành dự án dựa trên thời gian lạc quan, bi quan và có khả năng nhất."
        },
        {
          "id": 19,
          "question": "Tìm lỗi trong đoạn code Java sau và cho biết lỗi ở dòng nào:\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        for (int i = 0; i <= arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n}\n```",
          "options": [
            "Lỗi ở dòng 4",
            "Lỗi ở dòng 5",
            "Lỗi ở dòng 3",
            "Không có lỗi"
          ],
          "correctAnswer": ["Lỗi ở dòng 4"],
          "reason": "Lỗi ở dòng 4: `i <= arr.length`. Chỉ số mảng trong Java bắt đầu từ 0 và kết thúc ở `arr.length - 1`. Vòng lặp `for` đang chạy đến `arr.length`, gây ra lỗi `ArrayIndexOutOfBoundsException` khi `i` bằng `arr.length`."
        },
        {
          "id": 20,
          "question": "Đoạn code Java sau thực hiện việc gì?\n```java\npublic class Mystery {\n    public static int mystery(int n) {\n        if (n == 0) {\n            return 0;\n        } else {\n            return n + mystery(n - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(mystery(5));\n    }\n}\n```",
          "options": [
            "Tính giai thừa của n",
            "Tính tổng các số từ 1 đến n",
            "Kiểm tra số nguyên tố",
            "Tìm số Fibonacci thứ n"
          ],
          "correctAnswer": ["Tính tổng các số từ 1 đến n"],
          "reason": "Hàm `mystery(n)` sử dụng đệ quy để tính tổng các số từ 1 đến n. `mystery(5)` sẽ trả về 5 + 4 + 3 + 2 + 1 = 15."
        },
        {
          "id": 21,
          "question": "Tìm lỗi trong đoạn code Java sau:\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Error {\n    public static void main(String[] args) {\n        List<Integer> numbers = new ArrayList<>();\n        numbers.add(1);\n        numbers.add(2);\n        numbers.add(3);\n        \n        for (int i = 0; i < numbers.size(); i++) {\n             if (numbers.get(i) % 2 == 0) {\n                numbers.remove(i);\n                i--; \n            }\n        }\n        System.out.println(numbers);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi do sử dụng remove khi duyệt list",
            "Lỗi do index vượt quá độ dài của list",
            "Lỗi do sai cú pháp"
          ],
          "correctAnswer": [
            "Lỗi do sử dụng remove khi duyệt list",
            "Lỗi do index vượt quá độ dài của list"
          ],
          "reason": "Khi `remove(i)` được gọi, các phần tử phía sau sẽ được dịch chuyển lên trước, làm thay đổi index của các phần tử còn lại trong `ArrayList`. dẫn đến vòng for duyệt sai phần tử, hoặc lỗi vượt quá độ dài của list"
        },
        {
          "id": 22,
          "question": "Cho bảng `Students` với các cột `StudentID` (INT, PRIMARY KEY), `Name` (VARCHAR), `Major` (VARCHAR), `GPA` (FLOAT). Viết truy vấn SQL để tìm sinh viên có GPA cao nhất.",
          "options": [
            "SELECT * FROM Students WHERE GPA = MAX(GPA);",
            "SELECT * FROM Students ORDER BY GPA DESC LIMIT 1;",
            "SELECT * FROM Students WHERE GPA >= ALL (SELECT GPA FROM Students);",
            "Cả B và C đều đúng"
          ],
          "correctAnswer": ["Cả B và C đều đúng"],
          "reason": "Cả hai câu lệnh B và C đều đúng. Câu B sắp xếp theo GPA giảm dần và lấy dòng đầu tiên (GPA cao nhất). Câu C sử dụng `ALL` để so sánh GPA của mỗi sinh viên với tất cả GPA khác, chọn ra sinh viên có GPA lớn hơn hoặc bằng tất cả."
        },
        {
          "id": 23,
          "question": "Cho bảng `Employees` với các cột `EmployeeID` (INT, PRIMARY KEY), `Name` (VARCHAR), `DepartmentID` (INT), `Salary` (INT). Viết truy vấn SQL để tìm phòng ban có tổng lương cao nhất.",
          "options": [
            "SELECT DepartmentID FROM Employees GROUP BY DepartmentID ORDER BY SUM(Salary) DESC LIMIT 1;",
            "SELECT DepartmentID, SUM(Salary) FROM Employees GROUP BY DepartmentID HAVING SUM(Salary) >= ALL (SELECT SUM(Salary) FROM Employees GROUP BY DepartmentID);",
            "SELECT DepartmentID, MAX(Salary) FROM Employees;",
            "SELECT DepartmentID FROM Employees WHERE Salary = (SELECT MAX(Salary) FROM Employees);"
          ],
          "correctAnswer": [
            "SELECT DepartmentID FROM Employees GROUP BY DepartmentID ORDER BY SUM(Salary) DESC LIMIT 1;",
            "SELECT DepartmentID, SUM(Salary) FROM Employees GROUP BY DepartmentID HAVING SUM(Salary) >= ALL (SELECT SUM(Salary) FROM Employees GROUP BY DepartmentID);"
          ],
          "reason": "Cả A và B đều đúng. Câu A nhóm theo `DepartmentID`, tính tổng lương `SUM(Salary)` của mỗi phòng ban, sắp xếp giảm dần và lấy phòng ban đầu tiên (tổng lương cao nhất). Câu B cũng nhóm theo `DepartmentID`, tính tổng lương và sử dụng `ALL` để so sánh với tổng lương của tất cả các phòng ban khác, chọn ra phòng ban có tổng lương lớn hơn hoặc bằng tất cả."
        },
        {
          "id": 24,
          "question": "Tìm lỗi sai trong câu lệnh SQL sau:\n```sql\nSELECT Name, GPA\nFROM Students\nWHERE Major = 'Computer Science'\nORDER BY GPA DESC;\nGROUP BY Name;\n```",
          "options": [
            "Thiếu dấu chấm phẩy cuối câu",
            "Sai thứ tự mệnh đề",
            "Không thể dùng GROUP BY sau ORDER BY",
            "Không có lỗi"
          ],
          "correctAnswer": [
            "Sai thứ tự mệnh đề",
            "Không thể dùng GROUP BY sau ORDER BY"
          ],
          "reason": "Lỗi cú pháp: `GROUP BY` phải đứng trước `ORDER BY`. Thứ tự đúng của các mệnh đề trong câu lệnh `SELECT` là: `SELECT`, `FROM`, `WHERE`, `GROUP BY`, `HAVING`, `ORDER BY`, `LIMIT`."
        },
        {
          "id": 25,
          "question": "Biểu thức chính quy nào sau đây khớp với các chuỗi bắt đầu bằng 'a', kết thúc bằng 'b', và có thể chứa bất kỳ ký tự nào ở giữa (ngoại trừ xuống dòng)?",
          "options": ["^a.*b$", "^a.+b$", "a*b", "a+b"],
          "correctAnswer": ["^a.*b$", "^a.+b$"],
          "reason": "`^a.*b$` khớp với chuỗi bắt đầu bằng 'a' (`^a`), kết thúc bằng 'b' (`b$`), và có thể chứa bất kỳ ký tự nào (`.`) với số lần xuất hiện bất kỳ (`*`) ở giữa. `^a.+b$` yêu cầu phải có ít nhất một kí tự ở giữa."
        },
        {
          "id": 26,
          "question": "Phương pháp nào sau đây KHÔNG phải là một design pattern phổ biến trong lập trình hướng đối tượng?",
          "options": ["Singleton", "Factory", "Observer", "Waterfall"],
          "correctAnswer": ["Waterfall"],
          "reason": "Waterfall không phải là một design pattern. Nó là một mô hình phát triển phần mềm. Singleton, Factory, và Observer là các design pattern phổ biến."
        },
        {
          "id": 27,
          "question": "Khái niệm \"tight coupling\" trong lập trình hướng đối tượng đề cập đến điều gì?",
          "options": [
            "Các lớp phụ thuộc chặt chẽ vào nhau",
            "Các lớp không có mối liên hệ với nhau",
            "Các lớp có thể dễ dàng thay thế cho nhau",
            "Các lớp được đóng gói tốt"
          ],
          "correctAnswer": ["Các lớp phụ thuộc chặt chẽ vào nhau"],
          "reason": "Tight coupling xảy ra khi các lớp phụ thuộc chặt chẽ vào nhau, thay đổi ở một lớp có thể ảnh hưởng đến các lớp khác. Điều này làm giảm tính linh hoạt và khả năng bảo trì của hệ thống."
        },
        {
          "id": 28,
          "question": "Trong Java, từ khóa `static` được sử dụng cho biến thành viên của lớp có ý nghĩa gì?",
          "options": [
            "Biến đó chỉ có thể được truy cập từ bên trong lớp",
            "Biến đó là một hằng số",
            "Biến đó thuộc về lớp, không thuộc về từng đối tượng cụ thể của lớp",
            "Biến đó được cấp phát bộ nhớ trên heap"
          ],
          "correctAnswer": [
            "Biến đó thuộc về lớp, không thuộc về từng đối tượng cụ thể của lớp"
          ],
          "reason": "Biến static thuộc về lớp, chỉ có một bản sao duy nhất của biến static cho tất cả các đối tượng của lớp đó."
        },
        {
          "id": 29,
          "question": "Tiến trình A đang giữ tài nguyên X và yêu cầu tài nguyên Y. Tiến trình B đang giữ tài nguyên Y và yêu cầu tài nguyên X. Tình huống này mô tả vấn đề gì trong hệ điều hành?",
          "options": [
            "Starvation",
            "Race condition",
            "Deadlock",
            "Segmentation fault"
          ],
          "correctAnswer": ["Deadlock"],
          "reason": "Đây là một ví dụ kinh điển của deadlock, hai tiến trình A và B rơi vào trạng thái chờ đợi lẫn nhau để được cấp phát tài nguyên."
        },
        {
          "id": 30,
          "question": "Kỹ thuật \"phân trang\" (paging) trong quản lý bộ nhớ ảo của hệ điều hành có tác dụng gì?",
          "options": [
            "Chia bộ nhớ vật lý thành các khung trang có kích thước bằng nhau",
            "Chia chương trình thành các trang có kích thước bằng nhau",
            "Cho phép thực thi chương trình có kích thước lớn hơn bộ nhớ vật lý",
            "Tất cả các phương án trên"
          ],
          "correctAnswer": ["Tất cả các phương án trên"],
          "reason": "Phân trang chia bộ nhớ vật lý thành các khung trang (frames) và chương trình thành các trang (pages) có kích thước bằng nhau. Kỹ thuật này cho phép thực thi chương trình có kích thước lớn hơn bộ nhớ vật lý bằng cách chỉ nạp vào bộ nhớ những trang cần thiết tại một thời điểm."
        }
      ]
    },
    {
      "id": 8,
      "title": "Đề 6",
      "timeLimit": 6000,
      "questions": [
        {
          "id": 1,
          "question": "Địa chỉ IP nào sau đây là địa chỉ broadcast trong mạng con 192.168.1.0/24?",
          "options": [
            "192.168.1.0",
            "192.168.1.1",
            "192.168.1.254",
            "192.168.1.255"
          ],
          "correctAnswer": ["192.168.1.255"],
          "reason": "Trong mạng con 192.168.1.0/24, địa chỉ broadcast là địa chỉ có các bit phần host đều bằng 1, tức là 192.168.1.255."
        },
        {
          "id": 2,
          "question": "Protocol nào sau đây đảm bảo truyền dữ liệu tin cậy (reliable) trên mạng?",
          "options": ["UDP", "IP", "TCP", "ICMP"],
          "correctAnswer": ["TCP"],
          "reason": "TCP (Transmission Control Protocol) là giao thức hướng kết nối, cung cấp cơ chế kiểm soát lỗi, kiểm soát luồng và đảm bảo truyền dữ liệu tin cậy. UDP, IP, và ICMP không đảm bảo truyền dữ liệu tin cậy."
        },
        {
          "id": 3,
          "question": "Cây nhị phân tìm kiếm (Binary Search Tree) có độ phức tạp tìm kiếm trung bình là bao nhiêu?",
          "options": ["O(n)", "O(log n)", "O(n log n)", "O(n^2)"],
          "correctAnswer": ["O(log n)"],
          "reason": "Cây nhị phân tìm kiếm có độ phức tạp tìm kiếm trung bình là O(log n) nếu cây cân bằng. Trong trường hợp xấu nhất (cây suy biến), độ phức tạp có thể là O(n)."
        },
        {
          "id": 4,
          "question": "Giải thuật đệ quy nào sau đây KHÔNG sử dụng kỹ thuật chia để trị (divide and conquer)?",
          "options": ["Merge Sort", "Quick Sort", "Binary Search", "Factorial"],
          "correctAnswer": ["Factorial"],
          "reason": "Tính giai thừa (Factorial) không sử dụng kỹ thuật chia để trị. Merge Sort, Quick Sort, và Binary Search đều chia bài toán lớn thành các bài toán con nhỏ hơn để giải quyết."
        },
        {
          "id": 5,
          "question": "Trong kiến trúc máy tính, thanh ghi (register) nào lưu trữ địa chỉ của lệnh tiếp theo sẽ được thực thi?",
          "options": [
            "Program Counter (PC)",
            "Instruction Register (IR)",
            "Memory Address Register (MAR)",
            "Memory Data Register (MDR)"
          ],
          "correctAnswer": ["Program Counter (PC)"],
          "reason": "Program Counter (PC) lưu trữ địa chỉ của lệnh tiếp theo sẽ được thực thi. Instruction Register (IR) lưu trữ lệnh hiện tại đang được thực thi."
        },
        {
          "id": 6,
          "question": "Phương pháp truy cập bộ nhớ nào cho phép CPU truy cập trực tiếp đến bất kỳ ô nhớ nào?",
          "options": [
            "Truy cập tuần tự (Sequential Access)",
            "Truy cập ngẫu nhiên (Random Access)",
            "Truy cập trực tiếp (Direct Access)",
            "Truy cập chỉ mục (Indexed Access)"
          ],
          "correctAnswer": ["Truy cập ngẫu nhiên (Random Access)"],
          "reason": "Truy cập ngẫu nhiên (Random Access) cho phép CPU truy cập trực tiếp đến bất kỳ ô nhớ nào mà không cần phải đi qua các ô nhớ trung gian."
        },
        {
          "id": 7,
          "question": "Tiến trình ở trạng thái nào khi nó đang đợi một sự kiện (ví dụ: I/O) hoàn thành?",
          "options": ["Ready", "Running", "Blocked (Waiting)", "Terminated"],
          "correctAnswer": ["Blocked (Waiting)"],
          "reason": "Khi một tiến trình đang đợi một sự kiện, nó sẽ chuyển sang trạng thái Blocked (Waiting) cho đến khi sự kiện đó hoàn thành."
        },
        {
          "id": 8,
          "question": "Kỹ thuật nào sau đây KHÔNG phải là một giải pháp cho vấn đề race condition trong hệ điều hành?",
          "options": ["Mutex", "Semaphore", "Monitor", "Deadlock"],
          "correctAnswer": ["Deadlock"],
          "reason": "Deadlock là một vấn đề, không phải là giải pháp cho race condition. Mutex, Semaphore, và Monitor là các cơ chế đồng bộ hóa giúp ngăn chặn race condition."
        },
        {
          "id": 9,
          "question": "Trong Java, từ khóa `final` khi áp dụng cho một lớp có ý nghĩa gì?",
          "options": [
            "Lớp đó không thể có phương thức",
            "Lớp đó không thể được kế thừa",
            "Lớp đó không thể tạo đối tượng",
            "Lớp đó là một lớp trừu tượng"
          ],
          "correctAnswer": ["Lớp đó không thể được kế thừa"],
          "reason": "Khi một lớp được khai báo là `final`, nó không thể được sử dụng làm lớp cha để kế thừa."
        },
        {
          "id": 10,
          "question": "Phương thức `equals()` trong Java được sử dụng để làm gì?",
          "options": [
            "So sánh hai đối tượng",
            "Kiểm tra kiểu dữ liệu của đối tượng",
            "Gán giá trị cho đối tượng",
            "Xóa đối tượng khỏi bộ nhớ"
          ],
          "correctAnswer": ["So sánh hai đối tượng"],
          "reason": "Phương thức `equals()` dùng để so sánh nội dung của hai đối tượng. Mặc định, nó so sánh địa chỉ của hai đối tượng, nhưng thường được override để so sánh các thuộc tính của đối tượng."
        },
        {
          "id": 11,
          "question": "Ngôn ngữ lập trình nào sau đây KHÔNG hỗ trợ con trỏ (pointer)?",
          "options": ["C", "C++", "Java", "Pascal"],
          "correctAnswer": ["Java"],
          "reason": "Java không hỗ trợ con trỏ tường minh như C, C++, hay Pascal. Java sử dụng tham chiếu (reference) thay cho con trỏ."
        },
        {
          "id": 12,
          "question": "Quá trình chuyển đổi mã nguồn thành mã máy được gọi là gì?",
          "options": [
            "Biên dịch (Compilation)",
            "Thông dịch (Interpretation)",
            "Liên kết (Linking)",
            "Nạp (Loading)"
          ],
          "correctAnswer": ["Biên dịch (Compilation)"],
          "reason": "Biên dịch (Compilation) là quá trình chuyển đổi mã nguồn (viết bằng ngôn ngữ lập trình bậc cao) thành mã máy (có thể thực thi trực tiếp bởi CPU)."
        },
        {
          "id": 13,
          "question": "Mệnh đề `JOIN` trong SQL được sử dụng để làm gì?",
          "options": [
            "Kết hợp dữ liệu từ hai hoặc nhiều bảng",
            "Sắp xếp dữ liệu",
            "Lọc dữ liệu",
            "Nhóm dữ liệu"
          ],
          "correctAnswer": ["Kết hợp dữ liệu từ hai hoặc nhiều bảng"],
          "reason": "Mệnh đề `JOIN` được sử dụng để kết hợp các dòng từ hai hoặc nhiều bảng dựa trên một cột liên quan giữa chúng."
        },
        {
          "id": 14,
          "question": "Khóa ngoại (Foreign Key) trong cơ sở dữ liệu quan hệ dùng để làm gì?",
          "options": [
            "Định danh duy nhất một dòng trong bảng",
            "Tham chiếu đến khóa chính của bảng khác",
            "Lưu trữ dữ liệu dạng văn bản",
            "Tăng tốc độ truy vấn"
          ],
          "correctAnswer": ["Tham chiếu đến khóa chính của bảng khác"],
          "reason": "Khóa ngoại là một cột (hoặc tập hợp các cột) trong một bảng tham chiếu đến khóa chính của bảng khác, thiết lập mối quan hệ giữa hai bảng."
        },
        {
          "id": 15,
          "question": "Bước nào KHÔNG nằm trong chu trình phát triển phần mềm (Software Development Life Cycle)?",
          "options": ["Phân tích yêu cầu", "Thiết kế", "Kiểm thử", "Marketing"],
          "correctAnswer": ["Marketing"],
          "reason": "Marketing không phải là một bước trong chu trình phát triển phần mềm. Các bước chính thường bao gồm: Phân tích yêu cầu, Thiết kế, Lập trình, Kiểm thử, Triển khai, và Bảo trì."
        },
        {
          "id": 16,
          "question": "Trong mô hình Agile, \"Sprint\" là gì?",
          "options": [
            "Một cuộc họp hàng ngày",
            "Một giai đoạn phát triển ngắn, thường kéo dài từ 1 đến 4 tuần",
            "Một tài liệu mô tả yêu cầu",
            "Một công cụ quản lý mã nguồn"
          ],
          "correctAnswer": [
            "Một giai đoạn phát triển ngắn, thường kéo dài từ 1 đến 4 tuần"
          ],
          "reason": "Trong Agile, Sprint là một khoảng thời gian cố định (thường từ 1-4 tuần) mà nhóm phát triển tập trung hoàn thành một tập hợp các tính năng đã định trước."
        },
        {
          "id": 17,
          "question": "Ai là người chịu trách nhiệm chính trong việc quản lý rủi ro của dự án?",
          "options": ["Project Manager", "Developer", "Tester", "Stakeholder"],
          "correctAnswer": ["Project Manager"],
          "reason": "Project Manager (Quản lý dự án) là người chịu trách nhiệm chính trong việc xác định, phân tích, đánh giá, và xử lý rủi ro của dự án."
        },
        {
          "id": 18,
          "question": "Kỹ thuật \"ước lượng ba điểm\" (three-point estimation) trong quản lý dự án sử dụng các giá trị nào?",
          "options": [
            "Tốt nhất, Xấu nhất, Trung bình",
            "Lạc quan, Bi quan, Có khả năng nhất",
            "Cao, Thấp, Trung bình",
            "Nhanh, Chậm, Trung bình"
          ],
          "correctAnswer": ["Lạc quan, Bi quan, Có khả năng nhất"],
          "reason": "Kỹ thuật ước lượng ba điểm sử dụng ba giá trị: thời gian lạc quan (optimistic), thời gian bi quan (pessimistic), và thời gian có khả năng nhất (most likely) để ước tính thời gian hoặc chi phí."
        },
        {
          "id": 19,
          "question": "Đoạn code Java sau đây làm gì và giá trị của `result` là bao nhiêu?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 4, 5};\n        int result = 0;\n        for (int i = 0; i < numbers.length; i++) {\n            if (i % 2 == 0) {\n                result += numbers[i];\n            } else {\n                result -= numbers[i];\n            }\n        }\n        System.out.println(result);\n    }\n}\n```",
          "options": [
            "Tính tổng các phần tử ở vị trí chẵn, trừ các phần tử ở vị trí lẻ, result = -3",
            "Tính tổng các phần tử ở vị trí lẻ, trừ các phần tử ở vị trí chẵn, result = 3",
            "Tính tổng các phần tử của mảng, result = 15",
            "Tính tổng các phần tử chẵn, trừ các phần tử lẻ, result = -3"
          ],
          "correctAnswer": [
            "Tính tổng các phần tử ở vị trí chẵn, trừ các phần tử ở vị trí lẻ, result = -3"
          ],
          "reason": "Đoạn code lặp qua mảng `numbers`. Nếu chỉ số `i` là chẵn, nó cộng giá trị `numbers[i]` vào `result`. Nếu `i` lẻ, nó trừ `numbers[i]` khỏi `result`. Kết quả cuối cùng là 1 - 2 + 3 - 4 + 5 = 3, tuy nhiên do result ban đầu là 0, nên phải trừ thêm 6 (tổng của index lẻ) nên result cuối cùng là 3."
        },
        {
          "id": 20,
          "question": "Đoạn code sau lỗi ở đâu?\n```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class FindError {\n    public static void main(String[] args) {\n        Map<Integer, String> map = new HashMap<>();\n        map.put(1, \"One\");\n        map.put(2, \"Two\");\n        map.put(3, \"Three\");\n\n        for (Map.Entry<Integer, String> entry : map.entrySet()) {\n            if (entry.getKey() == 2) {\n                map.remove(entry.getKey());\n            }\n        }\n        System.out.println(map);\n    }\n}\n```",
          "options": [
            "Không thể sử dụng remove() trong vòng lặp for-each",
            "Lỗi ở dòng map.put(2, \"Two\");",
            "Không thể dùng entry.getKey()",
            "Không có lỗi"
          ],
          "correctAnswer": [
            "Không thể sử dụng remove() trong vòng lặp for-each"
          ],
          "reason": "Trong Java, bạn không thể trực tiếp xóa phần tử từ `HashMap` khi đang duyệt qua nó bằng vòng lặp for-each sử dụng `entrySet()`. Điều này sẽ gây ra lỗi `ConcurrentModificationException`. Để xóa phần tử, bạn cần sử dụng `Iterator`."
        },
        {
          "id": 21,
          "question": "Đoạn code Java sau in ra kết quả gì?\n```java\npublic class StringTest {\n    public static void main(String[] args) {\n        String s1 = \"hello\";\n        String s2 = \"hello\";\n        String s3 = new String(\"hello\");\n\n        System.out.println(s1 == s2);\n        System.out.println(s1 == s3);\n    }\n}\n```",
          "options": [
            "true, true",
            "true, false",
            "false, true",
            "false, false"
          ],
          "correctAnswer": ["true, false"],
          "reason": "Trong Java, khi sử dụng literal string (như `\"hello\"`), Java sẽ sử dụng string pool để tối ưu bộ nhớ. Do đó, `s1` và `s2` cùng trỏ đến một đối tượng trong string pool. Tuy nhiên, `s3` được tạo ra bằng từ khóa `new`, nên nó sẽ tạo ra một đối tượng mới trên heap. Do đó, `s1 == s2` là `true`, nhưng `s1 == s3` là `false` (so sánh địa chỉ)."
        },
        {
          "id": 22,
          "question": "Cho bảng `Products` với các cột `ProductID` (INT, PRIMARY KEY), `ProductName` (VARCHAR), `CategoryID` (INT), `Price` (FLOAT). Viết truy vấn SQL để tìm các sản phẩm có giá lớn hơn giá trung bình của tất cả các sản phẩm.",
          "options": [
            "SELECT * FROM Products WHERE Price > (SELECT AVG(Price) FROM Products);",
            "SELECT * FROM Products WHERE Price > AVG(Price);",
            "SELECT * FROM Products HAVING Price > (SELECT AVG(Price) FROM Products);",
            "SELECT * FROM Products GROUP BY Price HAVING Price > AVG(Price);"
          ],
          "correctAnswer": [
            "SELECT * FROM Products WHERE Price > (SELECT AVG(Price) FROM Products);"
          ],
          "reason": "Câu lệnh `SELECT * FROM Products WHERE Price > (SELECT AVG(Price) FROM Products)` sử dụng subquery `(SELECT AVG(Price) FROM Products)` để tính giá trung bình của tất cả sản phẩm, sau đó chọn ra các sản phẩm có giá lớn hơn giá trị này."
        },
        {
          "id": 23,
          "question": "Cho bảng `Orders` với các cột `OrderID` (INT, PRIMARY KEY), `CustomerID` (INT), `OrderDate` (DATE), `TotalAmount` (FLOAT) và bảng `Customers` với các cột `CustomerID` (INT, PRIMARY KEY), `CustomerName` (VARCHAR), `Country` (VARCHAR). Viết truy vấn SQL để tìm tên của các khách hàng đến từ 'USA' đã đặt hàng trong năm 2023.",
          "options": [
            "SELECT c.CustomerName FROM Customers c JOIN Orders o ON c.CustomerID = o.CustomerID WHERE c.Country = 'USA' AND o.OrderDate BETWEEN '2023-01-01' AND '2023-12-31';",
            "SELECT CustomerName FROM Customers WHERE Country = 'USA' AND CustomerID IN (SELECT CustomerID FROM Orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31');",
            "SELECT c.CustomerName FROM Customers c, Orders o WHERE c.CustomerID = o.CustomerID AND c.Country = 'USA' AND YEAR(o.OrderDate) = 2023;",
            "Tất cả các đáp án trên đều đúng"
          ],
          "correctAnswer": ["Tất cả các đáp án trên đều đúng"],
          "reason": "Cả ba câu lệnh đều kết hợp bảng `Orders` và `Customers` dựa trên `CustomerID`, lọc ra các khách hàng từ 'USA' và có đơn hàng trong năm 2023. Câu A sử dụng `JOIN`, câu B sử dụng `IN` với subquery, và câu C sử dụng cú pháp `JOIN` cũ và hàm `YEAR()`."
        },
        {
          "id": 24,
          "question": "Tìm lỗi sai trong đoạn SQL sau: \n```sql\nSELECT c.CustomerID, c.CustomerName, o.TotalAmount\nFROM Customers c\nLEFT JOIN Orders o ON c.CustomerID = o.CustomerID AND o.OrderDate > '2023-01-01'\nWHERE o.TotalAmount > 1000;\n```",
          "options": [
            "Sai vị trí của điều kiện trong mệnh đề ON",
            "Không thể sử dụng bí danh bảng (alias) trong mệnh đề WHERE",
            "Không thể sử dụng LEFT JOIN với điều kiện trong mệnh đề ON",
            "Không sai"
          ],
          "correctAnswer": ["Sai vị trí của điều kiện trong mệnh đề ON"],
          "reason": "Điều kiện `o.OrderDate > '2023-01-01'` đang nằm trong mệnh đề `ON` của `LEFT JOIN`. Điều này có nghĩa là nó sẽ được áp dụng trong quá trình join, thay vì lọc kết quả sau khi join. Kết quả là, câu lệnh sẽ trả về tất cả các khách hàng, bất kể họ có đơn hàng nào sau '2023-01-01' hay không. Nếu muốn lọc các đơn hàng sau '2023-01-01', điều kiện này phải được đặt trong mệnh đề `WHERE`."
        },
        {
          "id": 25,
          "question": "Biểu thức chính quy nào sau đây khớp với các địa chỉ email hợp lệ?",
          "options": [
            "\\w+@\\w+\\.\\w+",
            "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}",
            "^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$",
            "Tất cả các đáp án trên"
          ],
          "correctAnswer": ["Tất cả các đáp án trên"],
          "reason": "Cả ba biểu thức chính quy đều khớp với các địa chỉ email cơ bản. Tuy nhiên, để khớp chính xác với tất cả các địa chỉ email hợp lệ theo tiêu chuẩn RFC 5322 thì rất phức tạp. Biểu thức thứ hai `[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}` là một lựa chọn phổ biến và cân bằng giữa độ chính xác và độ phức tạp."
        },
        {
          "id": 26,
          "question": "SOLID là viết tắt của 5 nguyên tắc thiết kế hướng đối tượng. Chữ \"L\" trong SOLID đại diện cho nguyên tắc nào?",
          "options": [
            "Law of Demeter",
            "Liskov Substitution Principle",
            "Least Knowledge Principle",
            "Law of Conservation of Detail"
          ],
          "correctAnswer": ["Liskov Substitution Principle"],
          "reason": "Chữ \"L\" trong SOLID là viết tắt của Liskov Substitution Principle (Nguyên tắc thay thế Liskov). Nguyên tắc này phát biểu rằng các đối tượng của lớp con phải có thể thay thế được cho các đối tượng của lớp cha mà không làm thay đổi tính đúng đắn của chương trình."
        },
        {
          "id": 27,
          "question": "Cohesion trong thiết kế hướng đối tượng là gì?",
          "options": [
            "Mức độ phụ thuộc giữa các module",
            "Mức độ liên quan giữa các thành phần trong một module",
            "Khả năng tái sử dụng của một module",
            "Khả năng mở rộng của một module"
          ],
          "correctAnswer": [
            "Mức độ liên quan giữa các thành phần trong một module"
          ],
          "reason": "Cohesion đề cập đến mức độ liên quan chặt chẽ giữa các thành phần (hàm, lớp, biến) bên trong một module. Một module có tính kết dính cao (high cohesion) thường tốt hơn vì nó tập trung vào một nhiệm vụ cụ thể và dễ bảo trì hơn."
        },
        {
          "id": 28,
          "question": "Trong Java, `HashMap` và `TreeMap` khác nhau như thế nào?",
          "options": [
            "`HashMap` lưu trữ các phần tử theo thứ tự chèn, `TreeMap` lưu trữ theo thứ tự được sắp xếp",
            "`HashMap` cho phép null keys, `TreeMap` không cho phép",
            "`HashMap` có độ phức tạp tìm kiếm trung bình O(1), `TreeMap` có độ phức tạp tìm kiếm trung bình O(log n)",
            "Tất cả các đáp án trên đều đúng"
          ],
          "correctAnswer": ["Tất cả các đáp án trên đều đúng"],
          "reason": "`HashMap` sử dụng bảng băm, cung cấp hiệu suất trung bình O(1) cho các thao tác thêm, xóa, và tìm kiếm. `TreeMap` sử dụng cây đỏ-đen, cung cấp hiệu suất O(log n) và duy trì thứ tự các phần tử. `HashMap` cho phép một khóa null và nhiều giá trị null, trong khi `TreeMap` không cho phép khóa null (nhưng cho phép nhiều giá trị null)."
        },
        {
          "id": 29,
          "question": "Trong hệ điều hành, khi nào thì xảy ra tình trạng \"thrashing\"?",
          "options": [
            "Khi CPU quá tải",
            "Khi hệ thống dành quá nhiều thời gian cho việc chuyển đổi giữa các tiến trình",
            "Khi bộ nhớ bị phân mảnh nghiêm trọng",
            "Khi ổ cứng bị lỗi"
          ],
          "correctAnswer": [
            "Khi hệ thống dành quá nhiều thời gian cho việc chuyển đổi giữa các tiến trình"
          ],
          "reason": "Thrashing xảy ra khi hệ thống dành phần lớn thời gian cho việc chuyển đổi trang (paging) giữa bộ nhớ chính và đĩa cứng, thay vì thực thi các tiến trình. Điều này thường xảy ra khi hệ thống không có đủ bộ nhớ vật lý để chứa tất cả các trang cần thiết cho các tiến trình đang chạy."
        },
        {
          "id": 30,
          "question": "Bộ nhớ ảo (Virtual Memory) trong hệ điều hành cho phép điều gì?",
          "options": [
            "Thực thi các chương trình có kích thước lớn hơn bộ nhớ vật lý",
            "Tăng tốc độ truy cập đĩa cứng",
            "Bảo vệ hệ điều hành khỏi virus",
            "Kết nối nhiều máy tính với nhau"
          ],
          "correctAnswer": [
            "Thực thi các chương trình có kích thước lớn hơn bộ nhớ vật lý"
          ],
          "reason": "Bộ nhớ ảo cho phép hệ điều hành sử dụng một phần của đĩa cứng làm bộ nhớ mở rộng cho RAM. Điều này cho phép thực thi các chương trình có kích thước lớn hơn dung lượng RAM vật lý hiện có."
        }
      ]
    },
    {
      "id": 9,
      "title": "Quiz về Cấu trúc Dữ liệu và Giải thuật",
      "timeLimit": 3600,
      "questions": [
        {
          "id": 1,
          "question": "Cấu trúc dữ liệu nào sử dụng nguyên tắc LIFO (Last In, First Out)?",
          "options": ["Queue", "Stack", "Linked List", "Tree"],
          "correctAnswer": "Stack",
          "reason": "Stack sử dụng nguyên tắc LIFO, nơi phần tử được thêm vào cuối cùng sẽ được lấy ra đầu tiên."
        },
        {
          "id": 2,
          "question": "Thuật toán sắp xếp nào có độ phức tạp trung bình là O(n log n)?",
          "options": [
            "Bubble Sort",
            "Selection Sort",
            "Quick Sort",
            "Insertion Sort"
          ],
          "correctAnswer": "Quick Sort",
          "reason": "Quick Sort có độ phức tạp trung bình là O(n log n) và thường hiệu quả hơn trong thực tế."
        },
        {
          "id": 3,
          "question": "Cấu trúc dữ liệu nào thích hợp để triển khai hàng đợi ưu tiên?",
          "options": ["Array", "Stack", "Heap", "Linked List"],
          "correctAnswer": "Heap",
          "reason": "Heap là cấu trúc dữ liệu thích hợp để triển khai hàng đợi ưu tiên vì nó hỗ trợ truy xuất phần tử có ưu tiên cao nhất một cách hiệu quả."
        },
        {
          "id": 4,
          "question": "Thuật toán tìm kiếm nào hoạt động hiệu quả trên mảng đã được sắp xếp?",
          "options": [
            "Linear Search",
            "Binary Search",
            "Depth-First Search",
            "Breadth-First Search"
          ],
          "correctAnswer": "Binary Search",
          "reason": "Binary Search hoạt động hiệu quả trên mảng đã được sắp xếp với độ phức tạp O(log n)."
        },
        {
          "id": 5,
          "question": "Trong cây nhị phân tìm kiếm, phần tử nào được đặt ở nút gốc?",
          "options": [
            "Phần tử nhỏ nhất",
            "Phần tử lớn nhất",
            "Phần tử trung vị",
            "Bất kỳ phần tử nào"
          ],
          "correctAnswer": "Phần tử trung vị",
          "reason": "Trong cây nhị phân tìm kiếm, thường phần tử trung vị được đặt ở nút gốc để tối ưu hóa quá trình tìm kiếm."
        },
        {
          "id": 6,
          "question": "Thuật toán nào được sử dụng để tìm đường đi ngắn nhất trong đồ thị?",
          "options": [
            "Dijkstra's Algorithm",
            "Kruskal's Algorithm",
            "Prim's Algorithm",
            "Bubble Sort"
          ],
          "correctAnswer": "Dijkstra's Algorithm",
          "reason": "Dijkstra's Algorithm được sử dụng để tìm đường đi ngắn nhất từ một nút nguồn đến các nút khác trong đồ thị có trọng số không âm."
        },
        {
          "id": 7,
          "question": "Cấu trúc dữ liệu nào hỗ trợ tốt cho việc thực hiện đệ quy?",
          "options": ["Queue", "Stack", "Heap", "Array"],
          "correctAnswer": "Stack",
          "reason": "Stack hỗ trợ tốt cho việc thực hiện đệ quy vì nó lưu trữ trạng thái của các lời gọi hàm."
        },
        {
          "id": 8,
          "question": "Thuật toán sắp xếp nào thực hiện chia mảng thành các phần nhỏ hơn và sau đó kết hợp lại?",
          "options": [
            "Merge Sort",
            "Bubble Sort",
            "Selection Sort",
            "Quick Sort"
          ],
          "correctAnswer": "Merge Sort",
          "reason": "Merge Sort chia mảng thành các phần nhỏ hơn, sắp xếp từng phần và sau đó kết hợp lại."
        },
        {
          "id": 9,
          "question": "Cấu trúc dữ liệu nào cho phép truy cập ngẫu nhiên các phần tử?",
          "options": ["Linked List", "Stack", "Queue", "Array"],
          "correctAnswer": "Array",
          "reason": "Array cho phép truy cập ngẫu nhiên các phần tử thông qua chỉ số."
        },
        {
          "id": 10,
          "question": "Trong đồ thị, thuật ngữ nào mô tả số lượng cạnh nối một đỉnh?",
          "options": ["Degree", "Weight", "Path", "Cycle"],
          "correctAnswer": "Degree",
          "reason": "Degree của một đỉnh là số lượng cạnh nối nó với các đỉnh khác."
        },
        {
          "id": 11,
          "question": "Thuật toán nào được sử dụng để xây dựng cây khung tối thiểu?",
          "options": [
            "Dijkstra's Algorithm",
            "Kruskal's Algorithm",
            "Binary Search",
            "Depth-First Search"
          ],
          "correctAnswer": "Kruskal's Algorithm",
          "reason": "Kruskal's Algorithm được sử dụng để xây dựng cây khung tối thiểu trong đồ thị có trọng số."
        },
        {
          "id": 12,
          "question": "Cấu trúc dữ liệu nào phù hợp để triển khai đệ quy vào duyệt cây?",
          "options": ["Queue", "Stack", "Heap", "Array"],
          "correctAnswer": "Stack",
          "reason": "Stack phù hợp để lưu trữ các trạng thái khi thực hiện đệ quy vào duyệt cây."
        },
        {
          "id": 13,
          "question": "Thuật toán nào được sử dụng trong việc tìm kiếm chuỗi con trong một chuỗi lớn?",
          "options": [
            "Knuth-Morris-Pratt",
            "Dijkstra's Algorithm",
            "Merge Sort",
            "Bubble Sort"
          ],
          "correctAnswer": "Knuth-Morris-Pratt",
          "reason": "Knuth-Morris-Pratt là một thuật toán hiệu quả để tìm kiếm chuỗi con trong một chuỗi lớn."
        },
        {
          "id": 14,
          "question": "Trong cây nhị phân, nút lá là gì?",
          "options": [
            "Nút không có con",
            "Nút có hai con",
            "Nút gốc",
            "Nút chỉ có một con"
          ],
          "correctAnswer": "Nút không có con",
          "reason": "Nút lá trong cây nhị phân là nút không có con."
        },
        {
          "id": 15,
          "question": "Cấu trúc dữ liệu nào phù hợp nhất để thực hiện việc quay lại trạng thái trước đó?",
          "options": ["Queue", "Stack", "Heap", "Array"],
          "correctAnswer": "Stack",
          "reason": "Stack cho phép quay lại trạng thái trước đó thông qua nguyên tắc LIFO."
        },
        {
          "id": 16,
          "question": "Thuật toán nào có độ phức tạp thời gian tốt nhất trong trường hợp tốt nhất cho sắp xếp?",
          "options": [
            "Quick Sort",
            "Merge Sort",
            "Bubble Sort",
            "Insertion Sort"
          ],
          "correctAnswer": "Insertion Sort",
          "reason": "Insertion Sort có độ phức tạp thời gian tốt nhất là O(n) trong trường hợp mảng đã được sắp xếp gần như hoàn chỉnh."
        },
        {
          "id": 17,
          "question": "Trong cây nhị phân tìm kiếm, tất cả các nút bên trái của một nút đều nhỏ hơn nút đó, và tất cả các nút bên phải đều lớn hơn nút đó.",
          "options": ["Đúng", "Sai"],
          "correctAnswer": "Đúng",
          "reason": "Cây nhị phân tìm kiếm đảm bảo rằng tất cả các nút bên trái nhỏ hơn nút gốc và tất cả các nút bên phải lớn hơn."
        },
        {
          "id": 18,
          "question": "Thuật toán nào là thuật toán tham lam (greedy algorithm)?",
          "options": [
            "Dijkstra's Algorithm",
            "Merge Sort",
            "Quick Sort",
            "Bubble Sort"
          ],
          "correctAnswer": "Dijkstra's Algorithm",
          "reason": "Dijkstra's Algorithm là một ví dụ của thuật toán tham lam, luôn chọn lựa đường đi ngắn nhất hiện tại."
        },
        {
          "id": 19,
          "question": "Cấu trúc dữ liệu nào hỗ trợ tốt cho việc triển khai bảng băm (hash table)?",
          "options": ["Array", "Linked List", "Stack", "Queue"],
          "correctAnswer": ["Array", "Linked List"],
          "reason": "Chọn nhiều hơn 1 đáp án: Bảng băm thường sử dụng mảng để lưu trữ các túi chứa các phần tử và liên kết danh sách để xử lý va chạm."
        },
        {
          "id": 20,
          "question": "Thuật toán nào được sử dụng để duyệt cây theo chiều sâu?",
          "options": [
            "Breadth-First Search",
            "Depth-First Search",
            "Binary Search",
            "Linear Search"
          ],
          "correctAnswer": "Depth-First Search",
          "reason": "Depth-First Search là thuật toán duyệt cây theo chiều sâu."
        },
        {
          "id": 21,
          "question": "Trong đồ thị, thuật ngữ nào mô tả một chu trình?",
          "options": ["Path", "Cycle", "Tree", "Edge"],
          "correctAnswer": "Cycle",
          "reason": "Cycle là một đường đi trong đồ thị bắt đầu và kết thúc tại cùng một nút."
        },
        {
          "id": 22,
          "question": "Cấu trúc dữ liệu nào không thể thực hiện truy cập ngẫu nhiên?",
          "options": ["Array", "Linked List", "Stack", "Queue"],
          "correctAnswer": ["Linked List", "Stack", "Queue"],
          "reason": "Chọn nhiều hơn 1 đáp án: Linked List, Stack và Queue không hỗ trợ truy cập ngẫu nhiên như Array."
        },
        {
          "id": 23,
          "question": "Thuật toán nào được sử dụng trong tìm kiếm đường đi trong AI?",
          "options": [
            "A* Search",
            "Bubble Sort",
            "Quick Sort",
            "Insertion Sort"
          ],
          "correctAnswer": "A* Search",
          "reason": "A* Search là thuật toán được sử dụng rộng rãi trong tìm kiếm đường đi trong AI."
        },
        {
          "id": 24,
          "question": "Trong đồ thị vô hướng, nếu một đồ thị có n đỉnh và n-1 cạnh và là liên thông, thì đồ thị đó là gì?",
          "options": ["Cycle", "Tree", "Graph đầy đủ", "Disconnected Graph"],
          "correctAnswer": "Tree",
          "reason": "Đồ thị vô hướng liên thông với n đỉnh và n-1 cạnh là một cây."
        },
        {
          "id": 25,
          "question": "Thuật toán nào không phải là thuật toán sắp xếp?",
          "options": [
            "Quick Sort",
            "Merge Sort",
            "Dijkstra's Algorithm",
            "Heap Sort"
          ],
          "correctAnswer": "Dijkstra's Algorithm",
          "reason": "Dijkstra's Algorithm là thuật toán tìm đường đi ngắn nhất, không phải là thuật toán sắp xếp."
        },
        {
          "id": 26,
          "question": "Trong cây AVL, điều kiện gì đảm bảo sự cân bằng?",
          "options": [
            "Chiều cao của các cây con không khác nhau",
            "Chiều cao của hai cây con chênh nhau không quá 1",
            "Tất cả các nút có độ sâu bằng nhau",
            "Cây không có nút con"
          ],
          "correctAnswer": "Chiều cao của hai cây con chênh nhau không quá 1",
          "reason": "Cây AVL đảm bảo rằng chiều cao của hai cây con của mỗi nút chênh nhau không quá 1 để duy trì sự cân bằng."
        },
        {
          "id": 27,
          "question": "Cấu trúc dữ liệu nào thường được sử dụng để triển khai ngăn xếp (stack)?",
          "options": [
            "Array",
            "Linked List",
            "Both Array and Linked List",
            "None of the above"
          ],
          "correctAnswer": "Both Array and Linked List",
          "reason": "Ngăn xếp có thể được triển khai bằng cả mảng (array) và danh sách liên kết (linked list)."
        },
        {
          "id": 28,
          "question": "Thuật toán nào được sử dụng để tìm cây khung tối thiểu trong đồ thị?",
          "options": [
            "Kruskal's Algorithm",
            "Binary Search",
            "Depth-First Search",
            "Breadth-First Search"
          ],
          "correctAnswer": "Kruskal's Algorithm",
          "reason": "Kruskal's Algorithm được sử dụng để tìm cây khung tối thiểu trong đồ thị."
        },
        {
          "id": 29,
          "question": "Trong thuật toán sắp xếp Quick Sort, yếu tố nào quyết định chia mảng?",
          "options": ["Pivot", "Heap", "Queue", "Stack"],
          "correctAnswer": "Pivot",
          "reason": "Pivot là yếu tố được chọn để chia mảng thành các phần nhỏ hơn và lớn hơn trong Quick Sort."
        },
        {
          "id": 30,
          "question": "Cấu trúc dữ liệu nào phù hợp để lưu trữ biểu thức hậu tố (postfix expression)?",
          "options": ["Queue", "Stack", "Heap", "Array"],
          "correctAnswer": "Stack",
          "reason": "Stack được sử dụng để lưu trữ và xử lý biểu thức hậu tố."
        },
        {
          "id": 31,
          "question": "Thuật toán nào được sử dụng để kiểm tra xem một đồ thị có chu trình hay không?",
          "options": [
            "Depth-First Search",
            "Breadth-First Search",
            "Dijkstra's Algorithm",
            "Binary Search"
          ],
          "correctAnswer": "Depth-First Search",
          "reason": "Depth-First Search có thể được sử dụng để phát hiện chu trình trong đồ thị."
        },
        {
          "id": 32,
          "question": "Trong cây nhị phân, mỗi nút có thể có tối đa bao nhiêu nút con?",
          "options": ["1", "2", "3", "Không giới hạn"],
          "correctAnswer": "2",
          "reason": "Trong cây nhị phân, mỗi nút có thể có tối đa 2 nút con."
        },
        {
          "id": 33,
          "question": "Thuật toán nào là một phần của thuật toán Quick Sort?",
          "options": [
            "Partitioning",
            "Merging",
            "Heapifying",
            "None of the above"
          ],
          "correctAnswer": "Partitioning",
          "reason": "Partitioning là bước chính trong Quick Sort để chia mảng dựa trên pivot."
        },
        {
          "id": 34,
          "question": "Cấu trúc dữ liệu nào được sử dụng để triển khai đệ quy không sử dụng ngăn xếp hệ thống?",
          "options": ["Queue", "Heap", "Hash Table", "None of the above"],
          "correctAnswer": "None of the above",
          "reason": "Không có cấu trúc dữ liệu nào thay thế hoàn toàn ngăn xếp hệ thống cho đệ quy."
        },
        {
          "id": 35,
          "question": "Thuật toán nào có độ phức tạp thời gian O(n^2) trong trường hợp xấu nhất?",
          "options": ["Bubble Sort", "Merge Sort", "Quick Sort", "Heap Sort"],
          "correctAnswer": "Bubble Sort",
          "reason": "Bubble Sort có độ phức tạp thời gian O(n^2) trong trường hợp xấu nhất."
        },
        {
          "id": 36,
          "question": "Trong bảng băm, việc xử lý va chạm thường được thực hiện bằng phương pháp nào?",
          "options": [
            "Chaining",
            "Open Addressing",
            "Both Chaining and Open Addressing",
            "None of the above"
          ],
          "correctAnswer": "Both Chaining and Open Addressing",
          "reason": "Va chạm trong bảng băm có thể được xử lý bằng cả hai phương pháp chaining và open addressing."
        },
        {
          "id": 37,
          "question": "Cấu trúc dữ liệu nào phù hợp để triển khai biểu thức toán học có dấu ngoặc?",
          "options": ["Queue", "Stack", "Heap", "Array"],
          "correctAnswer": "Stack",
          "reason": "Stack phù hợp để xử lý các biểu thức toán học có dấu ngoặc bằng cách lưu trữ các dấu ngoặc mở."
        },
        {
          "id": 38,
          "question": "Thuật toán nào không phải là một thuật toán tham lam?",
          "options": [
            "Dijkstra's Algorithm",
            "Kruskal's Algorithm",
            "Dynamic Programming",
            "Prim's Algorithm"
          ],
          "correctAnswer": "Dynamic Programming",
          "reason": "Dynamic Programming không phải là thuật toán tham lam mà là kỹ thuật tối ưu hóa dựa trên việc chia nhỏ vấn đề."
        },
        {
          "id": 39,
          "question": "Trong thuật toán tìm kiếm nhị phân, số lượng bước cần thiết để tìm một phần tử trong mảng có n phần tử là gì?",
          "options": ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
          "correctAnswer": "O(log n)",
          "reason": "Thuật toán tìm kiếm nhị phân có độ phức tạp thời gian là O(log n)."
        },
        {
          "id": 40,
          "question": "Cấu trúc dữ liệu nào cho phép thêm và xóa phần tử ở cả hai đầu?",
          "options": ["Stack", "Queue", "Deque", "Heap"],
          "correctAnswer": "Deque",
          "reason": "Deque (Double-Ended Queue) cho phép thêm và xóa phần tử ở cả hai đầu."
        },
        {
          "id": 41,
          "question": "Thuật toán nào sử dụng chiến lược 'chia để trị'?",
          "options": [
            "Merge Sort",
            "Bubble Sort",
            "Dijkstra's Algorithm",
            "Linear Search"
          ],
          "correctAnswer": "Merge Sort",
          "reason": "Merge Sort sử dụng chiến lược 'chia để trị' bằng cách chia mảng thành các phần nhỏ hơn và sau đó kết hợp lại."
        },
        {
          "id": 42,
          "question": "Trong cây đỏ-đen, tất cả các nút đỏ phải thỏa mãn điều kiện nào?",
          "options": [
            "Nút đỏ không có nút con đỏ",
            "Nút đỏ phải có ít nhất một nút con đỏ",
            "Nút đỏ phải là nút lá",
            "Không có điều kiện nào"
          ],
          "correctAnswer": "Nút đỏ không có nút con đỏ",
          "reason": "Trong cây đỏ-đen, nút đỏ không được có nút con đỏ để duy trì tính cân bằng."
        },
        {
          "id": 43,
          "question": "Cấu trúc dữ liệu nào không hỗ trợ tốt cho việc duyệt theo chiều rộng?",
          "options": ["Queue", "Stack", "Heap", "None of the above"],
          "correctAnswer": "Stack",
          "reason": "Stack không hỗ trợ tốt cho việc duyệt theo chiều rộng, ngược lại Queue là phù hợp."
        },
        {
          "id": 44,
          "question": "Thuật toán nào được sử dụng để kiểm tra tính liên thông của đồ thị?",
          "options": [
            "Depth-First Search",
            "Bubble Sort",
            "Quick Sort",
            "Insertion Sort"
          ],
          "correctAnswer": "Depth-First Search",
          "reason": "Depth-First Search có thể được sử dụng để kiểm tra xem đồ thị có liên thông hay không."
        },
        {
          "id": 45,
          "question": "Trong thuật toán Heap Sort, cây được sử dụng là gì?",
          "options": ["Binary Heap", "AVL Tree", "Red-Black Tree", "B-Tree"],
          "correctAnswer": "Binary Heap",
          "reason": "Heap Sort sử dụng Binary Heap để sắp xếp các phần tử."
        },
        {
          "id": 46,
          "question": "Cấu trúc dữ liệu nào phù hợp để triển khai một bộ đếm (counter) hiệu quả?",
          "options": ["Hash Table", "Stack", "Queue", "Heap"],
          "correctAnswer": "Hash Table",
          "reason": "Hash Table cho phép tăng và truy xuất bộ đếm một cách hiệu quả thông qua các khóa."
        },
        {
          "id": 47,
          "question": "Thuật toán nào là thuật toán sắp xếp không ổn định?",
          "options": [
            "Merge Sort",
            "Quick Sort",
            "Bubble Sort",
            "Insertion Sort"
          ],
          "correctAnswer": "Quick Sort",
          "reason": "Quick Sort là một thuật toán sắp xếp không ổn định vì các phần tử có giá trị bằng nhau có thể được sắp xếp lại."
        },
        {
          "id": 48,
          "question": "Trong bảng băm, hàm băm (hash function) mục đích là gì?",
          "options": [
            "Chia nhỏ dữ liệu",
            "Tạo khóa duy nhất cho mỗi phần tử",
            "Phân bổ dữ liệu vào các túi",
            "Tăng tốc độ truy cập"
          ],
          "correctAnswer": "Phân bổ dữ liệu vào các túi",
          "reason": "Hàm băm phân bổ dữ liệu vào các túi trong bảng băm dựa trên khóa của chúng."
        },
        {
          "id": 49,
          "question": "Cấu trúc dữ liệu nào không phù hợp để triển khai đệ quy?",
          "options": ["Stack", "Heap", "Queue", "None of the above"],
          "correctAnswer": "Queue",
          "reason": "Queue không phù hợp để lưu trữ các trạng thái đệ quy như Stack."
        },
        {
          "id": 50,
          "question": "Thuật toán nào được sử dụng để tìm cây khung tối thiểu với trọng số nhỏ nhất?",
          "options": [
            "Kruskal's Algorithm",
            "Dijkstra's Algorithm",
            "Merge Sort",
            "Bubble Sort"
          ],
          "correctAnswer": "Kruskal's Algorithm",
          "reason": "Kruskal's Algorithm được sử dụng để tìm cây khung tối thiểu với trọng số nhỏ nhất trong đồ thị."
        },
        {
          "id": 51,
          "question": "Trie được sử dụng phổ biến trong ứng dụng nào?",
          "options": [
            "Tìm kiếm từ trong từ điển",
            "Quản lý bộ đếm",
            "Xử lý va chạm trong bảng băm",
            "Triển khai hàng đợi ưu tiên"
          ],
          "correctAnswer": "Tìm kiếm từ trong từ điển",
          "reason": "Trie là cấu trúc dữ liệu hiệu quả để tìm kiếm từ trong từ điển hoặc các ứng dụng liên quan đến chuỗi."
        },
        {
          "id": 52,
          "question": "B-Tree được sử dụng chủ yếu trong hệ thống nào?",
          "options": [
            "Hệ quản trị cơ sở dữ liệu",
            "Ứng dụng AI",
            "Trình duyệt web",
            "Hệ điều hành thời gian thực"
          ],
          "correctAnswer": "Hệ quản trị cơ sở dữ liệu",
          "reason": "B-Tree được sử dụng rộng rãi trong hệ quản trị cơ sở dữ liệu và hệ thống tệp để hỗ trợ truy xuất nhanh và hiệu quả."
        },
        {
          "id": 53,
          "question": "Suffix Tree được sử dụng trong việc giải quyết vấn đề nào?",
          "options": [
            "Tìm kiếm chuỗi con nhanh",
            "Xử lý va chạm trong bảng băm",
            "Quản lý bộ nhớ",
            "Triển khai hàng đợi ưu tiên"
          ],
          "correctAnswer": "Tìm kiếm chuỗi con nhanh",
          "reason": "Suffix Tree cho phép tìm kiếm các chuỗi con trong một chuỗi lớn một cách nhanh chóng và hiệu quả."
        },
        {
          "id": 54,
          "question": "Dynamic Programming là kỹ thuật tối ưu hóa dựa trên nguyên tắc gì?",
          "options": [
            "Chia nhỏ vấn đề thành các phần con",
            "Sử dụng ngăn xếp để lưu trữ trạng thái",
            "Sử dụng hàng đợi để quản lý tiến trình",
            "Sử dụng cây để phân tách dữ liệu"
          ],
          "correctAnswer": "Chia nhỏ vấn đề thành các phần con",
          "reason": "Dynamic Programming tối ưu hóa bằng cách chia nhỏ vấn đề lớn thành các phần nhỏ hơn và giải quyết chúng một cách hiệu quả."
        },
        {
          "id": 55,
          "question": "Thuật toán nào sử dụng hàm băm để tìm kiếm nhanh trong chuỗi?",
          "options": [
            "Rabin-Karp",
            "Bubble Sort",
            "Depth-First Search",
            "Insertion Sort"
          ],
          "correctAnswer": "Rabin-Karp",
          "reason": "Rabin-Karp sử dụng hàm băm để tìm kiếm nhanh các chuỗi con trong một chuỗi lớn."
        },
        {
          "id": 56,
          "question": "Boyer-Moore là một thuật toán thuộc loại nào?",
          "options": [
            "Thuật toán sắp xếp",
            "Thuật toán tìm kiếm chuỗi",
            "Thuật toán đồ thị",
            "Thuật toán đệ quy"
          ],
          "correctAnswer": "Thuật toán tìm kiếm chuỗi",
          "reason": "Boyer-Moore là một thuật toán tìm kiếm chuỗi hiệu quả, đặc biệt khi tìm kiếm trong văn bản lớn."
        },
        {
          "id": 57,
          "question": "Floyd-Warshall Algorithm được sử dụng để giải quyết vấn đề gì?",
          "options": [
            "Tìm đường đi ngắn nhất giữa mọi cặp đỉnh trong đồ thị",
            "Xây dựng cây khung tối thiểu",
            "Tìm chuỗi con dài nhất",
            "Sắp xếp mảng"
          ],
          "correctAnswer": "Tìm đường đi ngắn nhất giữa mọi cặp đỉnh trong đồ thị",
          "reason": "Floyd-Warshall Algorithm tìm đường đi ngắn nhất giữa mọi cặp đỉnh trong đồ thị có trọng số."
        },
        {
          "id": 58,
          "question": "Bellman-Ford Algorithm có thể xử lý được loại đồ thị nào mà Dijkstra's Algorithm không thể?",
          "options": [
            "Đồ thị có trọng số âm",
            "Đồ thị có chu trình",
            "Đồ thị đầy đủ",
            "Đồ thị không liên thông"
          ],
          "correctAnswer": "Đồ thị có trọng số âm",
          "reason": "Bellman-Ford Algorithm có thể xử lý đồ thị có trọng số âm, trong khi Dijkstra's Algorithm không thể."
        },
        {
          "id": 59,
          "question": "Johnson's Algorithm được sử dụng để tìm đường đi ngắn nhất trong đồ thị như thế nào?",
          "options": [
            "Sử dụng Dijkstra's Algorithm với các trọng số đã được điều chỉnh",
            "Sử dụng Depth-First Search và Breadth-First Search kết hợp",
            "Sử dụng thuật toán tham lam",
            "Không sử dụng thuật toán nào"
          ],
          "correctAnswer": "Sử dụng Dijkstra's Algorithm với các trọng số đã được điều chỉnh",
          "reason": "Johnson's Algorithm sử dụng Dijkstra's Algorithm sau khi điều chỉnh trọng số để xử lý các đồ thị có trọng số âm."
        },
        {
          "id": 60,
          "question": "Disjoint Set (Union-Find) thường được sử dụng trong thuật toán nào?",
          "options": [
            "Kruskal's Algorithm",
            "Merge Sort",
            "Bubble Sort",
            "Depth-First Search"
          ],
          "correctAnswer": "Kruskal's Algorithm",
          "reason": "Disjoint Set được sử dụng trong Kruskal's Algorithm để quản lý các tập hợp các đỉnh khi xây dựng cây khung tối thiểu."
        },
        {
          "id": 61,
          "question": "Bloom Filter là gì?",
          "options": [
            "Một cấu trúc dữ liệu xác suất dùng để kiểm tra sự tồn tại của một phần tử",
            "Một loại bảng băm",
            "Một thuật toán sắp xếp",
            "Một thuật toán tìm kiếm chuỗi"
          ],
          "correctAnswer": "Một cấu trúc dữ liệu xác suất dùng để kiểm tra sự tồn tại của một phần tử",
          "reason": "Bloom Filter là cấu trúc dữ liệu xác suất được sử dụng để kiểm tra xem một phần tử có tồn tại trong tập hợp hay không, với khả năng sai sót nhất định."
        },
        {
          "id": 62,
          "question": "Skip List có lợi thế gì so với cây tìm kiếm nhị phân cân bằng?",
          "options": [
            "Dễ dàng triển khai",
            "Hiệu suất tìm kiếm nhanh hơn trong mọi trường hợp",
            "Sử dụng ít bộ nhớ hơn",
            "Không có lợi thế nào"
          ],
          "correctAnswer": "Dễ dàng triển khai",
          "reason": "Skip List dễ dàng triển khai hơn so với các cây tìm kiếm nhị phân cân bằng và có hiệu suất tương đương trong nhiều trường hợp."
        },
        {
          "id": 63,
          "question": "Amortized Analysis được sử dụng để đánh giá độ phức tạp thời gian của các thuật toán như thế nào?",
          "options": [
            "Tính trung bình trên một chuỗi các thao tác",
            "Tính trong trường hợp xấu nhất cho một thao tác đơn lẻ",
            "Tính trong trường hợp tốt nhất cho một thao tác đơn lẻ",
            "Không được sử dụng để đánh giá độ phức tạp thời gian"
          ],
          "correctAnswer": "Tính trung bình trên một chuỗi các thao tác",
          "reason": "Amortized Analysis tính toán độ phức tạp thời gian trung bình trên một chuỗi các thao tác, giúp hiểu rõ hơn về hiệu suất tổng thể."
        },
        {
          "id": 64,
          "question": "Big-O, Big-Theta và Big-Omega thể hiện gì trong phân tích độ phức tạp?",
          "options": [
            "Big-O biểu thị giới hạn trên, Big-Theta biểu thị giới hạn chính xác, Big-Omega biểu thị giới hạn dưới",
            "Big-O biểu thị giới hạn dưới, Big-Theta biểu thị giới hạn trên, Big-Omega biểu thị giới hạn chính xác",
            "Cả ba đều biểu thị giới hạn trên",
            "Cả ba đều biểu thị giới hạn dưới"
          ],
          "correctAnswer": "Big-O biểu thị giới hạn trên, Big-Theta biểu thị giới hạn chính xác, Big-Omega biểu thị giới hạn dưới",
          "reason": "Big-O thể hiện giới hạn trên, Big-Theta thể hiện giới hạn chính xác, và Big-Omega thể hiện giới hạn dưới của độ phức tạp thời gian."
        },
        {
          "id": 65,
          "question": "Trie có thể giảm độ phức tạp của việc tìm kiếm từ điển từ O(n) xuống?",
          "options": ["Đúng", "Sai"],
          "correctAnswer": "Đúng",
          "reason": "Trie có thể giảm độ phức tạp tìm kiếm từ O(n) xuống O(m), với m là độ dài của từ cần tìm."
        },
        {
          "id": 66,
          "question": "B-Tree phù hợp với việc lưu trữ dữ liệu trên thiết bị ngoại vi như ổ cứng vì lý do gì?",
          "options": [
            "Giảm số lần truy cập đĩa",
            "Tăng tốc độ CPU",
            "Giảm tiêu thụ năng lượng",
            "Không phù hợp"
          ],
          "correctAnswer": "Giảm số lần truy cập đĩa",
          "reason": "B-Tree giảm số lần truy cập đĩa bằng cách giữ cho cây cân bằng và sâu tối thiểu, phù hợp với lưu trữ trên ổ cứng."
        },
        {
          "id": 67,
          "question": "Suffix Array có ưu điểm gì so với Suffix Tree?",
          "options": [
            "Tiết kiệm bộ nhớ hơn",
            "Xây dựng nhanh hơn",
            "Tìm kiếm nhanh hơn",
            "Không có ưu điểm nào"
          ],
          "correctAnswer": "Tiết kiệm bộ nhớ hơn",
          "reason": "Suffix Array thường tiết kiệm bộ nhớ hơn so với Suffix Tree và thích hợp cho các ứng dụng cần lưu trữ hiệu quả."
        },
        {
          "id": 68,
          "question": "Dynamic Programming thường được sử dụng để giải quyết các bài toán thuộc loại nào?",
          "options": [
            "Bài toán tối ưu hóa",
            "Bài toán tìm kiếm chuỗi",
            "Bài toán sắp xếp",
            "Bài toán đồ thị"
          ],
          "correctAnswer": "Bài toán tối ưu hóa",
          "reason": "Dynamic Programming thường được sử dụng để giải quyết các bài toán tối ưu hóa bằng cách chia nhỏ chúng thành các bài toán con."
        },
        {
          "id": 69,
          "question": "Thuật toán Rabin-Karp sử dụng gì để thực hiện tìm kiếm chuỗi?",
          "options": ["Hàm băm", "Ngăn xếp", "Hàng đợi", "Cây"],
          "correctAnswer": "Hàm băm",
          "reason": "Rabin-Karp sử dụng hàm băm để nhanh chóng xác định các vị trí có thể chứa chuỗi con cần tìm."
        },
        {
          "id": 70,
          "question": "Thuật toán Boyer-Moore có ưu điểm gì khi tìm kiếm chuỗi?",
          "options": [
            "Thường đi qua văn bản từ phải sang trái",
            "Sử dụng ít bộ nhớ hơn",
            "Thực hiện tìm kiếm nhanh hơn trong thực tế",
            "Không yêu cầu mảng đã sắp xếp"
          ],
          "correctAnswer": "Thực hiện tìm kiếm nhanh hơn trong thực tế",
          "reason": "Boyer-Moore thường thực hiện tìm kiếm nhanh hơn trong thực tế nhờ các quy tắc nhảy tối ưu khi so khớp không thành công."
        },
        {
          "id": 71,
          "question": "Floyd-Warshall Algorithm có thể phát hiện được gì trong đồ thị?",
          "options": [
            "Chu trình âm",
            "Cây khung tối thiểu",
            "Chu trình dương",
            "Không phát hiện được gì"
          ],
          "correctAnswer": "Chu trình âm",
          "reason": "Floyd-Warshall Algorithm có thể phát hiện chu trình âm trong đồ thị bằng cách kiểm tra đường đi ngắn nhất sau mỗi bước lặp."
        },
        {
          "id": 72,
          "question": "Bellman-Ford Algorithm có thể sử dụng trong đồ thị có chu trình âm hay không?",
          "options": ["Có", "Không"],
          "correctAnswer": "Có",
          "reason": "Bellman-Ford Algorithm có thể xử lý đồ thị có chu trình âm và kiểm tra sự tồn tại của chúng."
        },
        {
          "id": 73,
          "question": "Johnson's Algorithm phù hợp với loại đồ thị nào?",
          "options": [
            "Đồ thị có trọng số âm và không âm",
            "Đồ thị chỉ có trọng số không âm",
            "Đồ thị không có trọng số",
            "Đồ thị chỉ có trọng số âm"
          ],
          "correctAnswer": "Đồ thị có trọng số âm và không âm",
          "reason": "Johnson's Algorithm có thể xử lý đồ thị có trọng số âm và không âm bằng cách điều chỉnh trọng số trước khi áp dụng Dijkstra's Algorithm."
        },
        {
          "id": 74,
          "question": "Disjoint Set thường được triển khai bằng cách nào để tối ưu hóa?",
          "options": [
            "Path Compression và Union by Rank",
            "Sử dụng mảng đơn giản",
            "Sử dụng ngăn xếp",
            "Không cần tối ưu hóa"
          ],
          "correctAnswer": "Path Compression và Union by Rank",
          "reason": "Path Compression và Union by Rank giúp tối ưu hóa các thao tác tìm kiếm và hợp nhất trong Disjoint Set, làm giảm độ phức tạp thời gian."
        },
        {
          "id": 75,
          "question": "Bloom Filter có khả năng nào đặc biệt?",
          "options": [
            "Có thể báo sai khi nói phần tử không tồn tại",
            "Có thể báo sai khi nói phần tử tồn tại",
            "Không bao giờ báo sai",
            "Không sử dụng bộ nhớ"
          ],
          "correctAnswer": "Có thể báo sai khi nói phần tử tồn tại",
          "reason": "Bloom Filter có thể trả về false positives khi nói rằng một phần tử tồn tại trong tập hợp, nhưng không bao giờ trả về false negatives."
        },
        {
          "id": 76,
          "question": "Skip List sử dụng cấu trúc gì để tăng tốc độ tìm kiếm?",
          "options": [
            "Các cấp độ liên kết ngẫu nhiên",
            "Cấu trúc cây",
            "Ngăn xếp",
            "Hàng đợi"
          ],
          "correctAnswer": "Các cấp độ liên kết ngẫu nhiên",
          "reason": "Skip List sử dụng các cấp độ liên kết ngẫu nhiên để bỏ qua các phần tử không cần thiết, tăng tốc độ tìm kiếm."
        },
        {
          "id": 77,
          "question": "Trong Dynamic Programming, kỹ thuật nào được sử dụng để tránh tính toán lại các bài toán con?",
          "options": [
            "Memoization",
            "Backtracking",
            "Greedy",
            "Divide and Conquer"
          ],
          "correctAnswer": "Memoization",
          "reason": "Memoization lưu trữ kết quả của các bài toán con đã tính toán để tránh tính toán lại, tăng hiệu quả của Dynamic Programming."
        },
        {
          "id": 78,
          "question": "Amortized Analysis thường được sử dụng để phân tích độ phức tạp của cấu trúc dữ liệu nào?",
          "options": ["Array List", "Linked List", "Hash Table", "Queue"],
          "correctAnswer": "Array List",
          "reason": "Amortized Analysis được sử dụng để phân tích độ phức tạp của Array List, đặc biệt khi thực hiện các thao tác thêm phần tử."
        },
        {
          "id": 79,
          "question": "Big-Theta (Θ) được sử dụng để biểu diễn gì trong phân tích độ phức tạp?",
          "options": [
            "Giới hạn trên và dưới đồng thời",
            "Chỉ giới hạn trên",
            "Chỉ giới hạn dưới",
            "Không được sử dụng"
          ],
          "correctAnswer": "Giới hạn trên và dưới đồng thời",
          "reason": "Big-Theta (Θ) biểu diễn rằng hàm đó có độ phức tạp nằm trong giới hạn trên và dưới đồng thời."
        },
        {
          "id": 80,
          "question": "Trong Trie, mỗi nút đại diện cho gì?",
          "options": [
            "Một ký tự trong từ",
            "Một từ hoàn chỉnh",
            "Một phần tử của mảng",
            "Một đường dẫn trong cây"
          ],
          "correctAnswer": "Một ký tự trong từ",
          "reason": "Trong Trie, mỗi nút đại diện cho một ký tự trong từ, tạo thành các đường dẫn từ gốc đến các nút lá để hình thành các từ hoàn chỉnh."
        },
        {
          "id": 81,
          "question": "Fenwick Tree (Binary Indexed Tree) được sử dụng để giải quyết vấn đề gì?",
          "options": [
            "Tính tổng trên dãy số",
            "Tìm kiếm nhị phân",
            "Sắp xếp mảng",
            "Tìm đường đi ngắn nhất"
          ],
          "correctAnswer": "Tính tổng trên dãy số",
          "reason": "Fenwick Tree được thiết kế để tính tổng các phần tử trong một dãy số và cập nhật chúng một cách hiệu quả."
        },
        {
          "id": 82,
          "question": "Segment Tree được sử dụng để thực hiện các thao tác nào một cách hiệu quả?",
          "options": [
            "Tính tổng, tìm min/max trong một khoảng",
            "Sắp xếp mảng",
            "Tìm kiếm chuỗi con",
            "Xử lý va chạm trong bảng băm"
          ],
          "correctAnswer": "Tính tổng, tìm min/max trong một khoảng",
          "reason": "Segment Tree cho phép tính tổng, tìm giá trị nhỏ nhất hoặc lớn nhất trong một khoảng một cách nhanh chóng."
        },
        {
          "id": 83,
          "question": "Splay Tree là một loại cây nào?",
          "options": [
            "Cây nhị phân tìm kiếm tự cân bằng",
            "Cây đỏ-đen",
            "Cây AVL",
            "Cây trie"
          ],
          "correctAnswer": "Cây nhị phân tìm kiếm tự cân bằng",
          "reason": "Splay Tree là một loại cây nhị phân tìm kiếm tự cân bằng bằng cách sắp xếp lại cây mỗi khi truy cập một nút."
        },
        {
          "id": 84,
          "question": "Thuật toán Euler được sử dụng để giải quyết vấn đề gì trong đồ thị?",
          "options": [
            "Tìm đường đi Euler trong đồ thị",
            "Tìm cây khung tối thiểu",
            "Phân loại đồ thị",
            "Tìm thành phần liên thông"
          ],
          "correctAnswer": "Tìm đường đi Euler trong đồ thị",
          "reason": "Thuật toán Euler tìm kiếm và xác định sự tồn tại của đường đi Euler trong đồ thị."
        },
        {
          "id": 85,
          "question": "Thuật toán nào được sử dụng để tìm các thành phần mạnh liên thông trong đồ thị?",
          "options": [
            "Kosaraju's Algorithm",
            "Dijkstra's Algorithm",
            "Kruskal's Algorithm",
            "Bubble Sort"
          ],
          "correctAnswer": "Kosaraju's Algorithm",
          "reason": "Kosaraju's Algorithm là một trong những thuật toán hiệu quả để tìm các thành phần mạnh liên thông trong đồ thị."
        },
        {
          "id": 86,
          "question": "Topological Sorting chỉ áp dụng cho loại đồ thị nào?",
          "options": [
            "Đồ thị có hướng không có chu trình",
            "Đồ thị vô hướng",
            "Đồ thị có hướng có chu trình",
            "Đồ thị đầy đủ"
          ],
          "correctAnswer": "Đồ thị có hướng không có chu trình",
          "reason": "Topological Sorting chỉ có thể thực hiện trên đồ thị có hướng không có chu trình (DAG - Directed Acyclic Graph)."
        },
        {
          "id": 87,
          "question": "K-d Tree thường được sử dụng trong ứng dụng nào?",
          "options": [
            "Tìm kiếm không gian nhiều chiều",
            "Sắp xếp mảng",
            "Tìm kiếm chuỗi con",
            "Quản lý bộ nhớ"
          ],
          "correctAnswer": "Tìm kiếm không gian nhiều chiều",
          "reason": "K-d Tree là một cấu trúc dữ liệu hiệu quả để thực hiện tìm kiếm trong không gian nhiều chiều, thường được sử dụng trong đồ họa máy tính và học máy."
        },
        {
          "id": 88,
          "question": "Treap là sự kết hợp của hai cấu trúc dữ liệu nào?",
          "options": [
            "Cây nhị phân tìm kiếm và Heap",
            "Cây trie và Cây đỏ-đen",
            "Cây AVL và Cây nhị phân tìm kiếm",
            "Cây B và Cây Heap"
          ],
          "correctAnswer": "Cây nhị phân tìm kiếm và Heap",
          "reason": "Treap kết hợp đặc điểm của cây nhị phân tìm kiếm và heap để duy trì cân bằng và hỗ trợ các thao tác tìm kiếm, chèn, xóa hiệu quả."
        },
        {
          "id": 89,
          "question": "Thuật toán nào thuộc loại NP-Complete?",
          "options": [
            "Travelling Salesman Problem",
            "Binary Search",
            "Bubble Sort",
            "Dijkstra's Algorithm"
          ],
          "correctAnswer": "Travelling Salesman Problem",
          "reason": "Travelling Salesman Problem là một ví dụ điển hình của bài toán NP-Complete, nơi không có thuật toán giải quyết hiệu quả cho tất cả các trường hợp."
        },
        {
          "id": 90,
          "question": "Khái niệm P vs NP đề cập đến điều gì?",
          "options": [
            "Mối quan hệ giữa các lớp độ phức tạp tính toán",
            "So sánh giữa các cấu trúc dữ liệu",
            "Hiệu quả của các thuật toán sắp xếp",
            "Không liên quan đến toán học"
          ],
          "correctAnswer": "Mối quan hệ giữa các lớp độ phức tạp tính toán",
          "reason": "P vs NP là một vấn đề nổi tiếng trong khoa học máy tính về mối quan hệ giữa các lớp độ phức tạp tính toán P và NP."
        },
        {
          "id": 91,
          "question": "Thuật toán ngẫu nhiên (Randomized Algorithms) có ưu điểm gì?",
          "options": [
            "Đơn giản và thường có hiệu suất tốt trong thực tế",
            "Luôn đúng 100%",
            "Không cần bộ nhớ phụ",
            "Không có ưu điểm nào"
          ],
          "correctAnswer": "Đơn giản và thường có hiệu suất tốt trong thực tế",
          "reason": "Thuật toán ngẫu nhiên thường đơn giản và có hiệu suất tốt trong thực tế, đặc biệt trong các vấn đề phức tạp."
        },
        {
          "id": 92,
          "question": "Cấu trúc dữ liệu LRU Cache sử dụng các cấu trúc nào để quản lý bộ nhớ?",
          "options": [
            "Hash Table và Doubly Linked List",
            "Array và Stack",
            "Queue và Heap",
            "Trie và Binary Search Tree"
          ],
          "correctAnswer": "Hash Table và Doubly Linked List",
          "reason": "LRU Cache sử dụng Hash Table để truy cập nhanh và Doubly Linked List để quản lý thứ tự sử dụng của các phần tử."
        },
        {
          "id": 93,
          "question": "Thuật toán xử lý bit (Bit Manipulation) thường được sử dụng để làm gì?",
          "options": [
            "Tối ưu hóa các phép tính số học và logic",
            "Xử lý chuỗi",
            "Sắp xếp mảng",
            "Quản lý bộ nhớ"
          ],
          "correctAnswer": "Tối ưu hóa các phép tính số học và logic",
          "reason": "Bit Manipulation được sử dụng để tối ưu hóa các phép tính số học và logic bằng cách thao tác trực tiếp trên các bit của số."
        },
        {
          "id": 94,
          "question": "Heavy-Light Decomposition thường được sử dụng trong loại bài toán nào?",
          "options": [
            "Duyệt cây và truy vấn đường đi trong cây",
            "Sắp xếp mảng",
            "Tìm kiếm chuỗi con",
            "Xử lý va chạm trong bảng băm"
          ],
          "correctAnswer": "Duyệt cây và truy vấn đường đi trong cây",
          "reason": "Heavy-Light Decomposition là kỹ thuật được sử dụng để phân tách cây thành các đường nặng và nhẹ, giúp thực hiện các truy vấn đường đi hiệu quả."
        },
        {
          "id": 95,
          "question": "Thuật toán song song (Parallel Algorithms) được sử dụng để làm gì?",
          "options": [
            "Tăng tốc độ thực hiện các thuật toán bằng cách chia nhỏ công việc thành các phần có thể thực hiện đồng thời",
            "Giảm độ phức tạp không gian",
            "Tối ưu hóa các thuật toán tìm kiếm chuỗi",
            "Không có ứng dụng thực tế"
          ],
          "correctAnswer": "Tăng tốc độ thực hiện các thuật toán bằng cách chia nhỏ công việc thành các phần có thể thực hiện đồng thời",
          "reason": "Thuật toán song song tận dụng khả năng xử lý đồng thời của nhiều bộ xử lý để tăng tốc độ thực hiện các thuật toán phức tạp."
        },
        {
          "id": 96,
          "question": "Thuật toán nào được sử dụng để kiểm tra đồ thị có chu trình Euler không?",
          "options": [
            "Euler's Algorithm",
            "Kosaraju's Algorithm",
            "Dijkstra's Algorithm",
            "Bubble Sort"
          ],
          "correctAnswer": "Euler's Algorithm",
          "reason": "Euler's Algorithm được sử dụng để kiểm tra sự tồn tại của chu trình Euler trong đồ thị."
        },
        {
          "id": 97,
          "question": "Trong Dynamic Programming, kỹ thuật nào được sử dụng để lưu trữ kết quả của các bài toán con đã giải?",
          "options": [
            "Memoization",
            "Backtracking",
            "Greedy",
            "Divide and Conquer"
          ],
          "correctAnswer": "Memoization",
          "reason": "Memoization lưu trữ kết quả của các bài toán con đã giải để tránh tính toán lại, tăng hiệu quả của Dynamic Programming."
        },
        {
          "id": 98,
          "question": "Thuật toán nào là một ví dụ của thuật toán phân tán (Divide and Conquer)?",
          "options": [
            "Merge Sort",
            "Bubble Sort",
            "Dijkstra's Algorithm",
            "Insertion Sort"
          ],
          "correctAnswer": "Merge Sort",
          "reason": "Merge Sort là một ví dụ điển hình của thuật toán phân tán, chia mảng thành các phần nhỏ hơn và sau đó kết hợp lại."
        },
        {
          "id": 99,
          "question": "Cấu trúc dữ liệu nào phù hợp để thực hiện các thao tác LRU Cache?",
          "options": [
            "Hash Table và Doubly Linked List",
            "Stack và Queue",
            "Heap và Array",
            "Trie và Binary Search Tree"
          ],
          "correctAnswer": "Hash Table và Doubly Linked List",
          "reason": "LRU Cache sử dụng Hash Table để truy cập nhanh và Doubly Linked List để quản lý thứ tự sử dụng của các phần tử."
        },
        {
          "id": 100,
          "question": "Trong thuật toán Bit Manipulation, phép toán nào dùng để kiểm tra xem một bit cụ thể có được bật hay không?",
          "options": ["AND", "OR", "XOR", "NOT"],
          "correctAnswer": "AND",
          "reason": "Phép toán AND có thể được sử dụng để kiểm tra xem một bit cụ thể có được bật hay không bằng cách kết hợp với một mặt nạ bit phù hợp."
        }
      ]
    },
    {
      "id": 10,
      "title": "Quiz về Mạng Máy Tính",
      "timeLimit": 1800,
      "questions": [
        {
          "id": 1,
          "question": "Mô hình OSI bao gồm bao nhiêu tầng?",
          "options": ["5", "6", "7", "8"],
          "correctAnswer": "7",
          "reason": "Mô hình OSI bao gồm 7 tầng: Physical, Data Link, Network, Transport, Session, Presentation, Application."
        },
        {
          "id": 2,
          "question": "Giao thức nào hoạt động ở tầng Transport trong mô hình OSI?",
          "options": ["IP", "TCP", "HTTP", "Ethernet"],
          "correctAnswer": "TCP",
          "reason": "TCP (Transmission Control Protocol) hoạt động ở tầng Transport, cung cấp dịch vụ kết nối đáng tin cậy."
        },
        {
          "id": 3,
          "question": "Địa chỉ MAC được sử dụng ở tầng nào của mô hình OSI?",
          "options": ["Application", "Network", "Data Link", "Physical"],
          "correctAnswer": "Data Link",
          "reason": "Địa chỉ MAC được sử dụng ở tầng Data Link để xác định thiết bị trên mạng nội bộ."
        },
        {
          "id": 4,
          "question": "Giao thức nào được sử dụng để gửi email?",
          "options": ["SMTP", "FTP", "HTTP", "DNS"],
          "correctAnswer": "SMTP",
          "reason": "SMTP (Simple Mail Transfer Protocol) được sử dụng để gửi email qua mạng."
        },
        {
          "id": 5,
          "question": "Điểm khác biệt chính giữa IPv4 và IPv6 là gì?",
          "options": [
            "Độ dài địa chỉ",
            "Tốc độ truyền dữ liệu",
            "Phương thức mã hóa",
            "Không có sự khác biệt"
          ],
          "correctAnswer": "Độ dài địa chỉ",
          "reason": "IPv6 sử dụng địa chỉ 128-bit so với IPv4 sử dụng địa chỉ 32-bit, tăng khả năng định danh thiết bị."
        },
        {
          "id": 6,
          "question": "Giao thức nào được sử dụng để phân giải tên miền thành địa chỉ IP?",
          "options": ["DNS", "DHCP", "FTP", "SMTP"],
          "correctAnswer": "DNS",
          "reason": "DNS (Domain Name System) chuyển đổi tên miền dễ nhớ thành địa chỉ IP."
        },
        {
          "id": 7,
          "question": "Router hoạt động ở tầng nào của mô hình OSI?",
          "options": ["Data Link", "Network", "Transport", "Application"],
          "correctAnswer": "Network",
          "reason": "Router hoạt động ở tầng Network để định tuyến gói tin giữa các mạng khác nhau."
        },
        {
          "id": 8,
          "question": "Giao thức nào cung cấp dịch vụ truyền dữ liệu không kết nối?",
          "options": ["TCP", "UDP", "HTTP", "FTP"],
          "correctAnswer": "UDP",
          "reason": "UDP (User Datagram Protocol) cung cấp dịch vụ truyền dữ liệu không kết nối, nhanh nhưng không đáng tin cậy."
        },
        {
          "id": 9,
          "question": "Cổng mặc định cho giao thức HTTP là gì?",
          "options": ["80", "443", "21", "22"],
          "correctAnswer": "80",
          "reason": "Cổng mặc định cho HTTP là 80."
        },
        {
          "id": 10,
          "question": "VPN là viết tắt của gì?",
          "options": [
            "Virtual Private Network",
            "Virtual Public Network",
            "Very Private Network",
            "Virtual Protocol Network"
          ],
          "correctAnswer": "Virtual Private Network",
          "reason": "VPN stands for Virtual Private Network, which creates a secure connection over the internet."
        },
        {
          "id": 11,
          "question": "Trong mạng LAN, thiết bị nào được sử dụng để kết nối các thiết bị với nhau?",
          "options": ["Router", "Switch", "Modem", "Firewall"],
          "correctAnswer": "Switch",
          "reason": "Switch được sử dụng để kết nối các thiết bị trong mạng LAN và chuyển tiếp dữ liệu dựa trên địa chỉ MAC."
        },
        {
          "id": 12,
          "question": "Giao thức nào đảm bảo truyền dữ liệu chính xác và theo thứ tự?",
          "options": ["UDP", "TCP", "IP", "HTTP"],
          "correctAnswer": "TCP",
          "reason": "TCP đảm bảo dữ liệu được truyền chính xác và theo thứ tự thông qua các cơ chế kiểm soát lỗi và sắp xếp lại gói tin."
        },
        {
          "id": 13,
          "question": "Subnet Mask dùng để làm gì?",
          "options": [
            "Xác định mạng con và phần host",
            "Mã hóa dữ liệu",
            "Định tuyến gói tin",
            "Phân giải tên miền"
          ],
          "correctAnswer": "Xác định mạng con và phần host",
          "reason": "Subnet Mask xác định phần nào của địa chỉ IP đại diện cho mạng con và phần nào đại diện cho host."
        },
        {
          "id": 14,
          "question": "Giao thức nào được sử dụng để truyền dữ liệu trên Internet?",
          "options": ["FTP", "HTTP", "IP", "All of the above"],
          "correctAnswer": "All of the above",
          "reason": "FTP, HTTP, và IP đều được sử dụng để truyền dữ liệu trên Internet trong các ngữ cảnh khác nhau."
        },
        {
          "id": 15,
          "question": "Trong mạng Wi-Fi, chuẩn nào cung cấp tốc độ cao nhất?",
          "options": ["802.11a", "802.11b", "802.11g", "802.11ac"],
          "correctAnswer": "802.11ac",
          "reason": "802.11ac là chuẩn Wi-Fi mới nhất với tốc độ truyền dữ liệu cao hơn so với các chuẩn trước."
        },
        {
          "id": 16,
          "question": "Giao thức nào được sử dụng để quản lý địa chỉ IP tự động trong mạng?",
          "options": ["DNS", "DHCP", "FTP", "SMTP"],
          "correctAnswer": "DHCP",
          "reason": "DHCP (Dynamic Host Configuration Protocol) tự động cấp phát địa chỉ IP cho các thiết bị trong mạng."
        },
        {
          "id": 17,
          "question": "Biểu tượng nào biểu thị mạng không dây trên biểu tượng hệ thống?",
          "options": [
            "Một dải sóng",
            "Một cáp Ethernet",
            "Một hình tam giác",
            "Một hình vuông"
          ],
          "correctAnswer": "Một dải sóng",
          "reason": "Biểu tượng mạng không dây thường được biểu thị bằng một dải sóng hoặc các vòng sóng phân tán."
        },
        {
          "id": 18,
          "question": "Giao thức nào được sử dụng để bảo mật các phiên làm việc trên HTTP?",
          "options": ["HTTPS", "FTP", "SMTP", "TELNET"],
          "correctAnswer": "HTTPS",
          "reason": "HTTPS (HyperText Transfer Protocol Secure) sử dụng SSL/TLS để bảo mật các phiên làm việc trên HTTP."
        },
        {
          "id": 19,
          "question": "Loại địa chỉ IP nào không được sử dụng cho mạng riêng?",
          "options": [
            "10.0.0.0 - 10.255.255.255",
            "172.16.0.0 - 172.31.255.255",
            "192.168.0.0 - 192.168.255.255",
            "8.8.8.8"
          ],
          "correctAnswer": "8.8.8.8",
          "reason": "8.8.8.8 là địa chỉ IP công cộng của Google DNS, không thuộc dải địa chỉ IP riêng."
        },
        {
          "id": 20,
          "question": "Trong mạng máy tính, thuật ngữ 'latency' đề cập đến gì?",
          "options": ["Băng thông", "Độ trễ", "Mất gói tin", "Địa chỉ IP"],
          "correctAnswer": "Độ trễ",
          "reason": "Latency là độ trễ trong việc truyền dữ liệu từ nguồn đến đích trong mạng."
        },
        {
          "id": 21,
          "question": "Giao thức nào được sử dụng để truyền tải dữ liệu thời gian thực như âm thanh và video?",
          "options": ["TCP", "UDP", "HTTP", "FTP"],
          "correctAnswer": "UDP",
          "reason": "UDP được sử dụng cho các ứng dụng thời gian thực vì nó nhanh hơn TCP và không yêu cầu kết nối."
        },
        {
          "id": 22,
          "question": "Cổng mặc định cho giao thức HTTPS là gì?",
          "options": ["80", "443", "21", "22"],
          "correctAnswer": "443",
          "reason": "Cổng mặc định cho HTTPS là 443."
        },
        {
          "id": 23,
          "question": "Trong mạng LAN, địa chỉ IP nào thường được sử dụng cho gateway?",
          "options": [
            "192.168.1.1",
            "255.255.255.0",
            "192.168.1.255",
            "0.0.0.0"
          ],
          "correctAnswer": "192.168.1.1",
          "reason": "192.168.1.1 thường được sử dụng làm địa chỉ IP cho gateway trong mạng LAN."
        },
        {
          "id": 24,
          "question": "Protocol nào đảm bảo rằng gói tin đến đúng thứ tự?",
          "options": ["UDP", "TCP", "IP", "ICMP"],
          "correctAnswer": "TCP",
          "reason": "TCP đảm bảo gói tin được truyền đến đúng thứ tự thông qua cơ chế kiểm soát luồng và sắp xếp lại gói tin."
        },
        {
          "id": 25,
          "question": "Trong mạng Wi-Fi, chuẩn nào hoạt động ở băng tần 2.4 GHz?",
          "options": ["802.11a", "802.11b", "802.11ac", "802.11ad"],
          "correctAnswer": "802.11b",
          "reason": "802.11b hoạt động ở băng tần 2.4 GHz."
        },
        {
          "id": 26,
          "question": "Trong mạng IPv4, phần nào của địa chỉ IP xác định mạng?",
          "options": [
            "Phần đầu tiên",
            "Phần giữa",
            "Phần cuối",
            "Phần tùy thuộc vào Subnet Mask"
          ],
          "correctAnswer": "Phần tùy thuộc vào Subnet Mask",
          "reason": "Phần của địa chỉ IP xác định mạng phụ thuộc vào Subnet Mask được sử dụng."
        },
        {
          "id": 27,
          "question": "Giao thức nào được sử dụng để truy cập từ xa vào máy chủ?",
          "options": ["FTP", "SSH", "HTTP", "SMTP"],
          "correctAnswer": "SSH",
          "reason": "SSH (Secure Shell) được sử dụng để truy cập từ xa vào máy chủ một cách an toàn."
        },
        {
          "id": 28,
          "question": "Trong mạng máy tính, thuật ngữ 'bandwidth' đề cập đến gì?",
          "options": ["Độ trễ", "Băng thông", "Độ tin cậy", "Mất gói tin"],
          "correctAnswer": "Băng thông",
          "reason": "Bandwidth là khả năng truyền dữ liệu của một kênh truyền, thường được đo bằng Mbps hoặc Gbps."
        },
        {
          "id": 29,
          "question": "Giao thức nào được sử dụng để truyền dữ liệu qua mạng không dây bảo mật?",
          "options": ["WEP", "WPA", "WPA2", "All of the above"],
          "correctAnswer": "All of the above",
          "reason": "WEP, WPA, và WPA2 đều là các giao thức bảo mật được sử dụng trong mạng không dây."
        },
        {
          "id": 30,
          "question": "Giao thức nào được sử dụng để nhận địa chỉ IP tự động từ router?",
          "options": ["DNS", "DHCP", "HTTP", "FTP"],
          "correctAnswer": "DHCP",
          "reason": "DHCP (Dynamic Host Configuration Protocol) được sử dụng để nhận địa chỉ IP tự động từ router."
        },
        {
          "id": 31,
          "question": "Giao thức nào được sử dụng để điều khiển các thiết bị mạng?",
          "options": ["TCP", "UDP", "SNMP", "HTTP"],
          "correctAnswer": "SNMP",
          "reason": "SNMP (Simple Network Management Protocol) được sử dụng để điều khiển và giám sát các thiết bị mạng."
        },
        {
          "id": 32,
          "question": "Trong mạng máy tính, NAT là viết tắt của gì?",
          "options": [
            "Network Address Translation",
            "Network Access Technology",
            "New Access Terminal",
            "Network Authentication Tool"
          ],
          "correctAnswer": "Network Address Translation",
          "reason": "NAT (Network Address Translation) chuyển đổi địa chỉ IP nội bộ thành địa chỉ IP công cộng để tiết kiệm địa chỉ IP và bảo mật mạng."
        },
        {
          "id": 33,
          "question": "Giao thức nào được sử dụng để mã hóa dữ liệu trong HTTPS?",
          "options": ["SSL/TLS", "IPsec", "SSH", "WEP"],
          "correctAnswer": "SSL/TLS",
          "reason": "SSL/TLS được sử dụng để mã hóa dữ liệu trong HTTPS, đảm bảo an toàn cho thông tin truyền tải."
        },
        {
          "id": 34,
          "question": "Trong mạng Wi-Fi, chuẩn 802.11ax còn được gọi là gì?",
          "options": ["Wi-Fi 5", "Wi-Fi 6", "Wi-Fi 4", "Wi-Fi 7"],
          "correctAnswer": "Wi-Fi 6",
          "reason": "802.11ax được gọi là Wi-Fi 6, cung cấp tốc độ cao hơn và hiệu quả tốt hơn trong môi trường nhiều thiết bị."
        },
        {
          "id": 35,
          "question": "Giao thức nào đảm bảo rằng dữ liệu được truyền một cách đáng tin cậy và theo thứ tự?",
          "options": ["UDP", "TCP", "ICMP", "IGMP"],
          "correctAnswer": "TCP",
          "reason": "TCP (Transmission Control Protocol) đảm bảo dữ liệu được truyền một cách đáng tin cậy và theo thứ tự."
        },
        {
          "id": 36,
          "question": "Trong mạng máy tính, DMZ là viết tắt của gì?",
          "options": [
            "Demilitarized Zone",
            "Distributed Management Zone",
            "Dynamic Memory Zone",
            "Domain Management Zone"
          ],
          "correctAnswer": "Demilitarized Zone",
          "reason": "DMZ (Demilitarized Zone) là khu vực mạng tách biệt giữa mạng nội bộ và mạng công cộng để tăng cường bảo mật."
        },
        {
          "id": 37,
          "question": "Giao thức nào được sử dụng để quản lý và thiết lập các kết nối VPN?",
          "options": ["PPTP", "FTP", "SMTP", "SNMP"],
          "correctAnswer": "PPTP",
          "reason": "PPTP (Point-to-Point Tunneling Protocol) được sử dụng để quản lý và thiết lập các kết nối VPN."
        },
        {
          "id": 38,
          "question": "Trong mạng máy tính, ARP là viết tắt của gì?",
          "options": [
            "Address Resolution Protocol",
            "Automatic Routing Protocol",
            "Advanced Routing Process",
            "Access Routing Protocol"
          ],
          "correctAnswer": "Address Resolution Protocol",
          "reason": "ARP (Address Resolution Protocol) được sử dụng để ánh xạ địa chỉ IP sang địa chỉ MAC."
        },
        {
          "id": 39,
          "question": "Giao thức nào được sử dụng để truyền tải video trực tuyến với hiệu suất cao?",
          "options": ["HTTP", "FTP", "RTSP", "SMTP"],
          "correctAnswer": "RTSP",
          "reason": "RTSP (Real-Time Streaming Protocol) được sử dụng để truyền tải video trực tuyến với hiệu suất cao."
        },
        {
          "id": 40,
          "question": "Trong mạng máy tính, VLAN là viết tắt của gì?",
          "options": [
            "Virtual Local Area Network",
            "Virtual Large Area Network",
            "Virtual Logical Area Network",
            "Virtual Linked Area Network"
          ],
          "correctAnswer": "Virtual Local Area Network",
          "reason": "VLAN (Virtual Local Area Network) cho phép phân chia một mạng vật lý thành các mạng logic độc lập."
        },
        {
          "id": 41,
          "question": "Trong mạng máy tính, giao thức nào được sử dụng để định tuyến gói tin trong mạng lớn?",
          "options": ["RIP", "DNS", "HTTP", "FTP"],
          "correctAnswer": "RIP",
          "reason": "RIP (Routing Information Protocol) được sử dụng để định tuyến gói tin trong các mạng lớn."
        },
        {
          "id": 42,
          "question": "Trong mạng máy tính, multicast được sử dụng để làm gì?",
          "options": [
            "Gửi dữ liệu đến một người nhận duy nhất",
            "Gửi dữ liệu đến tất cả các người nhận",
            "Gửi dữ liệu đến một nhóm người nhận",
            "Gửi dữ liệu theo đường dẫn ngẫu nhiên"
          ],
          "correctAnswer": "Gửi dữ liệu đến một nhóm người nhận",
          "reason": "Multicast được sử dụng để gửi dữ liệu đến một nhóm người nhận cụ thể trong mạng."
        },
        {
          "id": 43,
          "question": "Trong mạng máy tính, cổng 53 thường được sử dụng cho giao thức nào?",
          "options": ["DNS", "FTP", "HTTP", "SMTP"],
          "correctAnswer": "DNS",
          "reason": "Cổng 53 thường được sử dụng cho giao thức DNS (Domain Name System)."
        },
        {
          "id": 44,
          "question": "Trong mạng máy tính, gói tin nào được sử dụng để kiểm tra kết nối mạng?",
          "options": [
            "ICMP Echo Request",
            "TCP SYN",
            "UDP Datagram",
            "HTTP GET"
          ],
          "correctAnswer": "ICMP Echo Request",
          "reason": "ICMP Echo Request được sử dụng trong lệnh ping để kiểm tra kết nối mạng."
        },
        {
          "id": 45,
          "question": "Trong mạng máy tính, thuật ngữ 'QoS' đề cập đến gì?",
          "options": [
            "Quality of Service",
            "Quick Operational System",
            "Query Optimization Service",
            "Quantum Operation System"
          ],
          "correctAnswer": "Quality of Service",
          "reason": "QoS (Quality of Service) đề cập đến khả năng quản lý và đảm bảo chất lượng dịch vụ mạng."
        },
        {
          "id": 46,
          "question": "Trong mạng máy tính, công nghệ nào cho phép nhiều mạng logic chạy trên cùng một hạ tầng vật lý?",
          "options": ["VLAN", "VPN", "NAT", "DMZ"],
          "correctAnswer": "VLAN",
          "reason": "VLAN (Virtual Local Area Network) cho phép nhiều mạng logic chạy trên cùng một hạ tầng vật lý."
        },
        {
          "id": 47,
          "question": "Trong mạng máy tính, thuật ngữ 'Firewall' đề cập đến gì?",
          "options": [
            "Thiết bị lưu trữ dữ liệu",
            "Phần mềm quản lý tài nguyên",
            "Công cụ bảo mật mạng kiểm soát lưu lượng truy cập",
            "Giao thức truyền dữ liệu"
          ],
          "correctAnswer": "Công cụ bảo mật mạng kiểm soát lưu lượng truy cập",
          "reason": "Firewall là công cụ bảo mật mạng được sử dụng để kiểm soát và quản lý lưu lượng truy cập vào và ra khỏi mạng."
        },
        {
          "id": 48,
          "question": "Trong mạng máy tính, thuật ngữ 'BGP' là viết tắt của gì?",
          "options": [
            "Border Gateway Protocol",
            "Basic Gateway Protocol",
            "Binary Gateway Protocol",
            "Backend Gateway Protocol"
          ],
          "correctAnswer": "Border Gateway Protocol",
          "reason": "BGP (Border Gateway Protocol) là giao thức định tuyến được sử dụng để trao đổi thông tin định tuyến giữa các hệ thống tự trị trên Internet."
        },
        {
          "id": 49,
          "question": "Trong mạng máy tính, 'SSID' là viết tắt của gì?",
          "options": [
            "Service Set Identifier",
            "Secure Service Identifier",
            "Standard Service ID",
            "Single Service Identifier"
          ],
          "correctAnswer": "Service Set Identifier",
          "reason": "SSID (Service Set Identifier) là tên mạng không dây mà người dùng thấy khi tìm kiếm mạng Wi-Fi."
        },
        {
          "id": 50,
          "question": "Trong mạng máy tính, công nghệ 'MPLS' được sử dụng để làm gì?",
          "options": [
            "Phân chia mạng thành các VLAN",
            "Tăng cường bảo mật mạng",
            "Quản lý và định tuyến lưu lượng mạng dựa trên nhãn",
            "Giảm độ trễ trong truyền dữ liệu"
          ],
          "correctAnswer": "Quản lý và định tuyến lưu lượng mạng dựa trên nhãn",
          "reason": "MPLS (Multiprotocol Label Switching) được sử dụng để quản lý và định tuyến lưu lượng mạng dựa trên nhãn, giúp tăng hiệu suất và khả năng quản lý mạng."
        }
      ]
    },
    {
      "id": 11,
      "title": "Quiz về Kỹ Nghệ Phần Mềm",
      "timeLimit": 1800,
      "questions": [
        {
          "id": 1,
          "question": "SDLC là viết tắt của cụm từ nào?",
          "options": [
            "Software Development Life Cycle",
            "System Design Life Cycle",
            "Software Design and Logic Control",
            "System Development Life Cycle"
          ],
          "correctAnswer": "Software Development Life Cycle",
          "reason": "SDLC stands for Software Development Life Cycle, which outlines the process of developing software."
        },
        {
          "id": 2,
          "question": "Phương pháp Agile tập trung vào điều gì?",
          "options": [
            "Lập kế hoạch chi tiết trước",
            "Phát triển theo từng sprint và phản hồi liên tục",
            "Giảm thiểu sự tương tác với khách hàng",
            "Thực hiện kiểm thử cuối cùng"
          ],
          "correctAnswer": "Phát triển theo từng sprint và phản hồi liên tục",
          "reason": "Agile focuses on iterative development through sprints and continuous feedback from stakeholders."
        },
        {
          "id": 3,
          "question": "Mẫu thiết kế nào cung cấp một cách để tạo ra các đối tượng mà không cần chỉ định lớp cụ thể?",
          "options": ["Singleton", "Factory Method", "Observer", "Decorator"],
          "correctAnswer": "Factory Method",
          "reason": "Factory Method cung cấp một cách để tạo ra các đối tượng mà không cần chỉ định lớp cụ thể."
        },
        {
          "id": 4,
          "question": "Trong quản lý dự án phần mềm, giai đoạn nào đi sau khi phân tích yêu cầu?",
          "options": ["Thiết kế", "Kiểm thử", "Triển khai", "Bảo trì"],
          "correctAnswer": "Thiết kế",
          "reason": "Sau khi phân tích yêu cầu, giai đoạn tiếp theo là thiết kế hệ thống dựa trên yêu cầu đã thu thập."
        },
        {
          "id": 5,
          "question": "Phương pháp nào trong Agile nhấn mạnh sự cải tiến liên tục?",
          "options": [
            "Waterfall",
            "Scrum",
            "Kanban",
            "XP (Extreme Programming)"
          ],
          "correctAnswer": "XP (Extreme Programming)",
          "reason": "XP (Extreme Programming) nhấn mạnh sự cải tiến liên tục thông qua các kỹ thuật như lập trình cặp và phát triển hướng kiểm thử."
        },
        {
          "id": 6,
          "question": "Trong UML, biểu tượng nào biểu thị một lớp?",
          "options": [
            "Hình chữ nhật với ba phần",
            "Hình tròn",
            "Hình tam giác",
            "Hình vuông"
          ],
          "correctAnswer": "Hình chữ nhật với ba phần",
          "reason": "Trong UML, một lớp được biểu thị bằng hình chữ nhật chia thành ba phần: tên lớp, thuộc tính, và phương thức."
        },
        {
          "id": 7,
          "question": "Phân tích yêu cầu thường được thực hiện bởi ai trong dự án phần mềm?",
          "options": [
            "Lập trình viên",
            "Chuyên viên phân tích hệ thống",
            "Tester",
            "Quản lý dự án"
          ],
          "correctAnswer": "Chuyên viên phân tích hệ thống",
          "reason": "Chuyên viên phân tích hệ thống thường chịu trách nhiệm phân tích và thu thập yêu cầu từ khách hàng và người dùng."
        },
        {
          "id": 8,
          "question": "Kiểm thử đơn vị (Unit Testing) tập trung vào kiểm tra gì?",
          "options": [
            "Toàn bộ hệ thống",
            "Các module hoặc đơn vị nhỏ nhất của mã nguồn",
            "Giao diện người dùng",
            "Hiệu suất hệ thống"
          ],
          "correctAnswer": "Các module hoặc đơn vị nhỏ nhất của mã nguồn",
          "reason": "Kiểm thử đơn vị tập trung vào việc kiểm tra các module hoặc đơn vị nhỏ nhất của mã nguồn để đảm bảo chúng hoạt động đúng."
        },
        {
          "id": 9,
          "question": "Trong quản lý dự án phần mềm, phương pháp Waterfall có đặc điểm nào?",
          "options": [
            "Linh hoạt và lặp lại",
            "Theo tiến trình tuyến tính và từng bước rõ ràng",
            "Tập trung vào phản hồi liên tục",
            "Sử dụng Kanban board"
          ],
          "correctAnswer": "Theo tiến trình tuyến tính và từng bước rõ ràng",
          "reason": "Phương pháp Waterfall theo tiến trình tuyến tính và chia dự án thành các bước rõ ràng không linh hoạt."
        },
        {
          "id": 10,
          "question": "Version Control System (VCS) được sử dụng để làm gì?",
          "options": [
            "Quản lý mã nguồn và theo dõi các thay đổi",
            "Kiểm thử phần mềm",
            "Thiết kế giao diện người dùng",
            "Quản lý tài liệu dự án"
          ],
          "correctAnswer": "Quản lý mã nguồn và theo dõi các thay đổi",
          "reason": "VCS được sử dụng để quản lý mã nguồn, theo dõi các thay đổi và hợp tác giữa các nhà phát triển."
        },
        {
          "id": 11,
          "question": "Mẫu thiết kế Singleton đảm bảo gì?",
          "options": [
            "Một lớp chỉ có thể có một instance duy nhất",
            "Một lớp có thể tạo nhiều instance",
            "Một lớp không thể được kế thừa",
            "Một lớp luôn luôn được khởi tạo cùng lúc"
          ],
          "correctAnswer": "Một lớp chỉ có thể có một instance duy nhất",
          "reason": "Mẫu thiết kế Singleton đảm bảo rằng một lớp chỉ có thể có một instance duy nhất trong toàn bộ ứng dụng."
        },
        {
          "id": 12,
          "question": "Phương pháp nào trong Agile sử dụng các sprint để phát triển phần mềm?",
          "options": ["Kanban", "Scrum", "Waterfall", "Lean"],
          "correctAnswer": "Scrum",
          "reason": "Scrum sử dụng các sprint, thường là từ 2-4 tuần, để phát triển phần mềm theo từng giai đoạn nhỏ."
        },
        {
          "id": 13,
          "question": "Trong UML, mối quan hệ kế thừa được biểu thị bằng gì?",
          "options": [
            "Mũi tên rỗng",
            "Mũi tên đầy",
            "Dấu chấm hỏi",
            "Dấu gạch ngang"
          ],
          "correctAnswer": "Mũi tên rỗng",
          "reason": "Mối quan hệ kế thừa trong UML được biểu thị bằng một mũi tên rỗng từ lớp con đến lớp cha."
        },
        {
          "id": 14,
          "question": "Phương pháp nào nhấn mạnh vào việc giao tiếp liên tục với khách hàng và thích ứng với thay đổi?",
          "options": ["Waterfall", "Agile", "V-Model", "Spiral"],
          "correctAnswer": "Agile",
          "reason": "Phương pháp Agile nhấn mạnh vào sự giao tiếp liên tục với khách hàng và khả năng thích ứng với các thay đổi trong yêu cầu."
        },
        {
          "id": 15,
          "question": "Trong quản lý dự án phần mềm, tài liệu nào mô tả chi tiết các yêu cầu chức năng?",
          "options": [
            "SRS (Software Requirements Specification)",
            "Design Document",
            "Test Plan",
            "User Manual"
          ],
          "correctAnswer": "SRS (Software Requirements Specification)",
          "reason": "SRS mô tả chi tiết các yêu cầu chức năng và phi chức năng của phần mềm."
        },
        {
          "id": 16,
          "question": "Mẫu thiết kế Observer được sử dụng để làm gì?",
          "options": [
            "Tạo đối tượng phụ thuộc và thông báo khi có thay đổi",
            "Quản lý phiên bản",
            "Tạo một đối tượng duy nhất",
            "Giao tiếp giữa các lớp không liên quan"
          ],
          "correctAnswer": "Tạo đối tượng phụ thuộc và thông báo khi có thay đổi",
          "reason": "Observer pattern cho phép một đối tượng (subject) thông báo cho các đối tượng phụ thuộc (observers) khi có sự thay đổi."
        },
        {
          "id": 17,
          "question": "Phương pháp nào trong Agile tập trung vào việc tối ưu hóa luồng công việc và giảm thiểu lãng phí?",
          "options": ["Scrum", "Kanban", "XP", "Lean"],
          "correctAnswer": "Kanban",
          "reason": "Kanban tập trung vào việc tối ưu hóa luồng công việc và giảm thiểu lãng phí bằng cách sử dụng các bảng Kanban để theo dõi tiến độ."
        },
        {
          "id": 18,
          "question": "Trong UML, biểu đồ lớp thể hiện gì?",
          "options": [
            "Các lớp và mối quan hệ giữa chúng",
            "Các luồng dữ liệu",
            "Các hoạt động trong hệ thống",
            "Các trường hợp sử dụng"
          ],
          "correctAnswer": "Các lớp và mối quan hệ giữa chúng",
          "reason": "Biểu đồ lớp trong UML thể hiện các lớp, thuộc tính, phương thức và mối quan hệ giữa các lớp."
        },
        {
          "id": 19,
          "question": "Trong Agile, vai trò Scrum Master chịu trách nhiệm gì?",
          "options": [
            "Quản lý dự án",
            "Hướng dẫn nhóm về quy trình Scrum",
            "Phát triển phần mềm",
            "Kiểm thử phần mềm"
          ],
          "correctAnswer": "Hướng dẫn nhóm về quy trình Scrum",
          "reason": "Scrum Master chịu trách nhiệm hướng dẫn và hỗ trợ nhóm về quy trình Scrum, giúp loại bỏ các rào cản."
        },
        {
          "id": 20,
          "question": "Phương pháp nào trong Agile tập trung vào viết mã sạch và kiểm thử liên tục?",
          "options": ["Scrum", "Kanban", "XP (Extreme Programming)", "Lean"],
          "correctAnswer": "XP (Extreme Programming)",
          "reason": "XP (Extreme Programming) tập trung vào việc viết mã sạch, kiểm thử liên tục và lập trình cặp để cải thiện chất lượng phần mềm."
        },
        {
          "id": 21,
          "question": "Trong quản lý dự án, biểu đồ Gantt được sử dụng để làm gì?",
          "options": [
            "Theo dõi tiến độ dự án",
            "Phân tích yêu cầu",
            "Thiết kế hệ thống",
            "Kiểm thử phần mềm"
          ],
          "correctAnswer": "Theo dõi tiến độ dự án",
          "reason": "Biểu đồ Gantt được sử dụng để theo dõi tiến độ dự án, hiển thị các nhiệm vụ và thời gian dự kiến."
        },
        {
          "id": 22,
          "question": "Mẫu thiết kế Decorator cho phép gì?",
          "options": [
            "Thêm chức năng vào đối tượng một cách linh hoạt",
            "Quản lý phiên bản",
            "Tạo đối tượng duy nhất",
            "Tách rời giao tiếp giữa các lớp"
          ],
          "correctAnswer": "Thêm chức năng vào đối tượng một cách linh hoạt",
          "reason": "Decorator pattern cho phép thêm chức năng vào đối tượng một cách linh hoạt mà không thay đổi cấu trúc của nó."
        },
        {
          "id": 23,
          "question": "Trong Agile, thuật ngữ 'sprint' đề cập đến gì?",
          "options": [
            "Một giai đoạn dài trong dự án",
            "Một chu kỳ phát triển ngắn, thường từ 2-4 tuần",
            "Một cuộc họp định kỳ",
            "Một tài liệu yêu cầu"
          ],
          "correctAnswer": "Một chu kỳ phát triển ngắn, thường từ 2-4 tuần",
          "reason": "Sprint là một chu kỳ phát triển ngắn trong Scrum, thường kéo dài từ 2-4 tuần, trong đó nhóm hoàn thành một phần công việc cụ thể."
        },
        {
          "id": 24,
          "question": "Trong quản lý dự án phần mềm, kỹ thuật nào được sử dụng để xác định các công việc cần thực hiện?",
          "options": [
            "Work Breakdown Structure (WBS)",
            "Gantt Chart",
            "PERT Chart",
            "Critical Path Method"
          ],
          "correctAnswer": "Work Breakdown Structure (WBS)",
          "reason": "WBS được sử dụng để phân tách dự án thành các công việc nhỏ hơn và quản lý chúng một cách hiệu quả."
        },
        {
          "id": 25,
          "question": "Mẫu thiết kế Strategy cho phép gì?",
          "options": [
            "Thay đổi thuật toán mà không thay đổi đối tượng sử dụng",
            "Tạo một đối tượng duy nhất",
            "Thêm chức năng vào đối tượng một cách linh hoạt",
            "Quản lý phiên bản"
          ],
          "correctAnswer": "Thay đổi thuật toán mà không thay đổi đối tượng sử dụng",
          "reason": "Strategy pattern cho phép thay đổi thuật toán một cách linh hoạt mà không ảnh hưởng đến đối tượng sử dụng."
        },
        {
          "id": 26,
          "question": "Trong Agile, thuật ngữ 'backlog' đề cập đến gì?",
          "options": [
            "Danh sách các nhiệm vụ chưa hoàn thành",
            "Danh sách các yêu cầu đã hoàn thành",
            "Một công cụ quản lý dự án",
            "Một phương pháp kiểm thử"
          ],
          "correctAnswer": "Danh sách các nhiệm vụ chưa hoàn thành",
          "reason": "Backlog là danh sách các nhiệm vụ, yêu cầu hoặc tính năng chưa hoàn thành mà nhóm sẽ thực hiện trong các sprint tiếp theo."
        },
        {
          "id": 27,
          "question": "Trong quản lý dự án, kỹ thuật PERT được sử dụng để làm gì?",
          "options": [
            "Đánh giá rủi ro dự án",
            "Tính toán thời gian hoàn thành dự án dựa trên các ước lượng thời gian khác nhau",
            "Theo dõi tiến độ dự án",
            "Phân tích yêu cầu"
          ],
          "correctAnswer": "Tính toán thời gian hoàn thành dự án dựa trên các ước lượng thời gian khác nhau",
          "reason": "PERT (Program Evaluation Review Technique) được sử dụng để tính toán thời gian hoàn thành dự án dựa trên các ước lượng thời gian tối ưu, trung bình và bi quan."
        },
        {
          "id": 28,
          "question": "Mẫu thiết kế Singleton thường được sử dụng trong trường hợp nào?",
          "options": [
            "Quản lý kết nối cơ sở dữ liệu",
            "Thêm chức năng vào đối tượng",
            "Phân tách giao tiếp giữa các lớp",
            "Tạo nhiều instance của lớp"
          ],
          "correctAnswer": "Quản lý kết nối cơ sở dữ liệu",
          "reason": "Singleton pattern đảm bảo chỉ có một instance duy nhất của lớp, thường được sử dụng để quản lý kết nối cơ sở dữ liệu."
        },
        {
          "id": 29,
          "question": "Trong Agile, vai trò Product Owner chịu trách nhiệm gì?",
          "options": [
            "Quản lý tiến độ dự án",
            "Xác định và ưu tiên các yêu cầu sản phẩm",
            "Hướng dẫn nhóm về quy trình Scrum",
            "Kiểm thử phần mềm"
          ],
          "correctAnswer": "Xác định và ưu tiên các yêu cầu sản phẩm",
          "reason": "Product Owner chịu trách nhiệm xác định các yêu cầu sản phẩm và ưu tiên chúng trong backlog để đảm bảo rằng nhóm phát triển tập trung vào các giá trị cao nhất."
        },
        {
          "id": 30,
          "question": "Trong quản lý dự án phần mềm, KPI là viết tắt của gì?",
          "options": [
            "Key Performance Indicator",
            "Knowledge Process Indicator",
            "Key Project Indicator",
            "Knowledge Performance Indicator"
          ],
          "correctAnswer": "Key Performance Indicator",
          "reason": "KPI (Key Performance Indicator) là các chỉ số chính được sử dụng để đo lường hiệu suất và tiến độ của dự án."
        },
        {
          "id": 31,
          "question": "Trong Agile, thuật ngữ 'velocity' đề cập đến gì?",
          "options": [
            "Số lượng công việc hoàn thành trong một sprint",
            "Tốc độ xử lý của phần mềm",
            "Tốc độ phát triển nhóm",
            "Số lượng lỗi được tìm thấy"
          ],
          "correctAnswer": "Số lượng công việc hoàn thành trong một sprint",
          "reason": "Velocity là số lượng công việc (thường được tính bằng story points) mà nhóm có thể hoàn thành trong một sprint."
        },
        {
          "id": 32,
          "question": "Phương pháp nào trong Agile tập trung vào việc sử dụng Kanban boards để quản lý công việc?",
          "options": ["Scrum", "Kanban", "XP (Extreme Programming)", "Lean"],
          "correctAnswer": "Kanban",
          "reason": "Kanban sử dụng Kanban boards để quản lý và tối ưu hóa luồng công việc, giúp theo dõi tiến độ và hạn chế số lượng công việc đang thực hiện."
        },
        {
          "id": 33,
          "question": "Trong UML, biểu đồ hoạt động (Activity Diagram) thể hiện gì?",
          "options": [
            "Cấu trúc lớp và mối quan hệ",
            "Luồng công việc và các hoạt động",
            "Tương tác giữa các đối tượng",
            "Các trường hợp sử dụng"
          ],
          "correctAnswer": "Luồng công việc và các hoạt động",
          "reason": "Activity Diagram trong UML thể hiện luồng công việc và các hoạt động diễn ra trong hệ thống."
        },
        {
          "id": 34,
          "question": "Trong quản lý dự án, tài liệu nào mô tả chi tiết kiến trúc phần mềm?",
          "options": ["SRS", "Design Document", "Test Plan", "User Manual"],
          "correctAnswer": "Design Document",
          "reason": "Design Document mô tả chi tiết kiến trúc và thiết kế của phần mềm, bao gồm các thành phần, mô-đun và mối quan hệ giữa chúng."
        },
        {
          "id": 35,
          "question": "Trong Agile, thuật ngữ 'retrospective' đề cập đến gì?",
          "options": [
            "Cuộc họp lập kế hoạch sprint",
            "Cuộc họp đánh giá sprint vừa qua để cải thiện quy trình",
            "Cuộc họp đánh giá tiến độ dự án",
            "Cuộc họp với khách hàng"
          ],
          "correctAnswer": "Cuộc họp đánh giá sprint vừa qua để cải thiện quy trình",
          "reason": "Retrospective là cuộc họp diễn ra sau mỗi sprint để đánh giá những gì đã làm tốt và những gì cần cải thiện trong quy trình làm việc."
        },
        {
          "id": 36,
          "question": "Trong quản lý dự án phần mềm, 'burn down chart' được sử dụng để làm gì?",
          "options": [
            "Theo dõi tiến độ dự án so với kế hoạch",
            "Phân tích rủi ro",
            "Quản lý ngân sách",
            "Đánh giá chất lượng phần mềm"
          ],
          "correctAnswer": "Theo dõi tiến độ dự án so với kế hoạch",
          "reason": "Burn down chart được sử dụng để theo dõi tiến độ dự án bằng cách hiển thị lượng công việc còn lại so với thời gian."
        },
        {
          "id": 37,
          "question": "Trong UML, biểu đồ tuần tự (Sequence Diagram) thể hiện gì?",
          "options": [
            "Cấu trúc lớp và mối quan hệ",
            "Luồng dữ liệu",
            "Tương tác giữa các đối tượng theo thời gian",
            "Các hoạt động trong hệ thống"
          ],
          "correctAnswer": "Tương tác giữa các đối tượng theo thời gian",
          "reason": "Sequence Diagram trong UML thể hiện cách các đối tượng tương tác với nhau theo thứ tự thời gian để thực hiện một chức năng hoặc quy trình."
        },
        {
          "id": 38,
          "question": "Trong Agile, từ khóa 'story point' đề cập đến gì?",
          "options": [
            "Số lượng dòng mã",
            "Độ khó hoặc kích thước của một user story",
            "Thời gian cần để hoàn thành một công việc",
            "Số lượng lỗi trong phần mềm"
          ],
          "correctAnswer": "Độ khó hoặc kích thước của một user story",
          "reason": "Story point là đơn vị đo lường độ khó hoặc kích thước của một user story, không liên quan trực tiếp đến thời gian."
        },
        {
          "id": 39,
          "question": "Trong quản lý dự án phần mềm, kỹ thuật nào được sử dụng để ước lượng thời gian hoàn thành các công việc?",
          "options": ["Delphi Technique", "PERT", "MoSCoW", "SWOT Analysis"],
          "correctAnswer": "Delphi Technique",
          "reason": "Delphi Technique là kỹ thuật dựa trên ý kiến của chuyên gia để ước lượng thời gian hoàn thành các công việc trong dự án."
        },
        {
          "id": 40,
          "question": "Trong Agile, từ khóa nào được sử dụng để giới hạn số lượng công việc đang thực hiện?",
          "options": [
            "Work in Progress (WIP)",
            "Sprint Backlog",
            "Product Backlog",
            "Burn Down Chart"
          ],
          "correctAnswer": "Work in Progress (WIP)",
          "reason": "Work in Progress (WIP) limits được sử dụng để giới hạn số lượng công việc đang thực hiện cùng một lúc, giúp tăng hiệu suất và giảm lãng phí."
        },
        {
          "id": 41,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để phân tích và biểu diễn mối quan hệ giữa các yếu tố nội bộ và bên ngoài?",
          "options": ["SWOT Analysis", "PERT", "Gantt Chart", "WBS"],
          "correctAnswer": "SWOT Analysis",
          "reason": "SWOT Analysis được sử dụng để phân tích Strengths, Weaknesses, Opportunities và Threats của dự án, giúp đánh giá mối quan hệ giữa các yếu tố nội bộ và bên ngoài."
        },
        {
          "id": 42,
          "question": "Trong UML, biểu đồ trường hợp sử dụng (Use Case Diagram) thể hiện gì?",
          "options": [
            "Các lớp và mối quan hệ",
            "Các tình huống sử dụng và tương tác với hệ thống",
            "Luồng công việc",
            "Tương tác giữa các đối tượng"
          ],
          "correctAnswer": "Các tình huống sử dụng và tương tác với hệ thống",
          "reason": "Use Case Diagram trong UML thể hiện các tình huống sử dụng (use cases) và tương tác giữa người dùng (actors) với hệ thống."
        },
        {
          "id": 43,
          "question": "Trong quản lý dự án phần mềm, KPI nào thường được sử dụng để đo lường hiệu suất nhóm phát triển?",
          "options": [
            "Burn Down Rate",
            "Customer Satisfaction",
            "Velocity",
            "All of the above"
          ],
          "correctAnswer": "All of the above",
          "reason": "Burn Down Rate, Customer Satisfaction và Velocity đều là các KPI quan trọng được sử dụng để đo lường hiệu suất nhóm phát triển trong dự án phần mềm."
        },
        {
          "id": 44,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để phân chia dự án thành các công việc nhỏ hơn?",
          "options": [
            "Work Breakdown Structure (WBS)",
            "Gantt Chart",
            "PERT",
            "SWOT Analysis"
          ],
          "correctAnswer": "Work Breakdown Structure (WBS)",
          "reason": "WBS được sử dụng để phân chia dự án thành các công việc nhỏ hơn, dễ quản lý và theo dõi hơn."
        },
        {
          "id": 45,
          "question": "Trong Agile, từ khóa 'burn up chart' thể hiện gì?",
          "options": [
            "Số lượng công việc đã hoàn thành theo thời gian",
            "Số lượng công việc còn lại",
            "Lịch trình dự án",
            "Phân tích rủi ro"
          ],
          "correctAnswer": "Số lượng công việc đã hoàn thành theo thời gian",
          "reason": "Burn up chart thể hiện số lượng công việc đã hoàn thành theo thời gian, giúp theo dõi tiến độ dự án."
        },
        {
          "id": 46,
          "question": "Trong quản lý dự án, phương pháp nào tập trung vào việc tối ưu hóa luồng công việc và giảm thiểu lãng phí?",
          "options": ["Agile", "Lean", "Waterfall", "Scrum"],
          "correctAnswer": "Lean",
          "reason": "Lean tập trung vào việc tối ưu hóa luồng công việc và giảm thiểu các hoạt động lãng phí trong quá trình phát triển phần mềm."
        },
        {
          "id": 47,
          "question": "Trong UML, biểu đồ trạng thái (State Diagram) thể hiện gì?",
          "options": [
            "Cấu trúc lớp và mối quan hệ",
            "Luồng dữ liệu",
            "Trạng thái và chuyển đổi trạng thái của một đối tượng",
            "Tương tác giữa các đối tượng"
          ],
          "correctAnswer": "Trạng thái và chuyển đổi trạng thái của một đối tượng",
          "reason": "State Diagram trong UML thể hiện các trạng thái khác nhau của một đối tượng và các chuyển đổi giữa các trạng thái đó."
        },
        {
          "id": 48,
          "question": "Trong quản lý dự án, từ khóa 'scope creep' đề cập đến gì?",
          "options": [
            "Phạm vi dự án mở rộng không kiểm soát",
            "Giảm phạm vi dự án",
            "Tăng ngân sách dự án",
            "Thay đổi nhóm dự án"
          ],
          "correctAnswer": "Phạm vi dự án mở rộng không kiểm soát",
          "reason": "Scope creep đề cập đến việc phạm vi dự án mở rộng không kiểm soát thông qua việc thêm các yêu cầu mới mà không điều chỉnh các nguồn lực."
        },
        {
          "id": 49,
          "question": "Trong Agile, kỹ thuật nào được sử dụng để đảm bảo rằng mã nguồn luôn luôn có thể được triển khai?",
          "options": [
            "Pair Programming",
            "Test-Driven Development (TDD)",
            "Continuous Integration (CI)",
            "All of the above"
          ],
          "correctAnswer": "All of the above",
          "reason": "Pair Programming, TDD và CI đều là các kỹ thuật được sử dụng trong Agile để đảm bảo rằng mã nguồn luôn luôn có thể được triển khai."
        },
        {
          "id": 50,
          "question": "Trong quản lý dự án phần mềm, thuật ngữ 'deliverable' đề cập đến gì?",
          "options": [
            "Các tài liệu dự án",
            "Các phần mềm được hoàn thiện và giao cho khách hàng",
            "Các cuộc họp dự án",
            "Các lỗi phần mềm"
          ],
          "correctAnswer": "Các phần mềm được hoàn thiện và giao cho khách hàng",
          "reason": "Deliverable là các sản phẩm, phần mềm hoặc tài liệu được hoàn thiện và giao cho khách hàng hoặc các bên liên quan khác."
        }
      ]
    },
    {
      "id": 12,
      "title": "Quiz về Cú Pháp Java Sai",
      "timeLimit": 900,
      "questions": [
        {
          "id": 1,
          "question": "Đoạn mã sau có lỗi cú pháp ở đâu?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\"\n    }\n}\n```",
          "options": [
            "Thiếu dấu chấm phẩy ở cuối dòng println",
            "Thiếu dấu ngoặc nhọn đóng cho phương thức main",
            "Thiếu dấu ngoặc kép kết thúc chuỗi",
            "Không có lỗi cú pháp"
          ],
          "correctAnswer": "Thiếu dấu chấm phẩy ở cuối dòng println",
          "reason": "Dòng `System.out.println(\"Hello World\"` thiếu dấu chấm phẩy (;) ở cuối."
        },
        {
          "id": 2,
          "question": "Đoạn mã sau có lỗi gì?\n```java\nint x = \"10\";\n```",
          "options": [
            "Không có lỗi",
            "Không thể gán chuỗi cho biến int",
            "Thiếu dấu chấm phẩy",
            "Biến x nên là String"
          ],
          "correctAnswer": "Không thể gán chuỗi cho biến int",
          "reason": "Không thể gán một chuỗi (`\"10\"`) cho một biến kiểu int."
        },
        {
          "id": 3,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Example {\n    public static void main(String[] args) {\n        for(int i = 0; i < 10; i++)\n            System.out.println(i);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu ngoặc nhọn cho vòng lặp for",
            "Lỗi logic trong điều kiện vòng lặp",
            "Biến i không được khai báo đúng cách"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã này hợp lệ trong Java, mặc dù không sử dụng dấu ngoặc nhọn cho vòng lặp for."
        },
        {
          "id": 4,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = null;\n        System.out.println(s.length());\n    }\n}\n```",
          "options": [
            "Không có lỗi cú pháp",
            "Lỗi NullPointerException",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi cú pháp",
          "reason": "Đoạn mã không có lỗi cú pháp, nhưng sẽ gây ra NullPointerException khi chạy vì s là null."
        },
        {
          "id": 5,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int[] arr = new int[5];\n        arr[5] = 10;\n    }\n}\n```",
          "options": [
            "Không có lỗi cú pháp",
            "Lỗi IndexOutOfBoundsException",
            "Thiếu dấu ngoặc nhọn",
            "Biến arr chưa được khởi tạo"
          ],
          "correctAnswer": "Không có lỗi cú pháp",
          "reason": "Đoạn mã không có lỗi cú pháp, nhưng sẽ gây ra IndexOutOfBoundsException khi chạy vì arr[5] vượt quá kích thước mảng."
        },
        {
          "id": 6,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        if(true)\n            System.out.println(\"True\");\n        else\n            System.out.println(\"False\");\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu ngoặc nhọn cho khối if-else",
            "Lỗi logic trong điều kiện",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ, sử dụng dấu ngoặc nhọn không bắt buộc cho các khối đơn lẻ trong if-else."
        },
        {
          "id": 7,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public void Test() {\n        // constructor\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Phương thức Test không phải là constructor vì có kiểu trả về void",
            "Thiếu dấu ngoặc nhọn đóng",
            "Constructor không được phép có tham số"
          ],
          "correctAnswer": "Phương thức Test không phải là constructor vì có kiểu trả về void",
          "reason": "Constructor không có kiểu trả về, nhưng phương thức Test có kiểu trả về void nên nó là một phương thức bình thường, không phải constructor."
        },
        {
          "id": 8,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        a = a++;\n        System.out.println(a);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Biến a sẽ tăng giá trị lên 11 nhưng in ra 10",
            "Biến a sẽ tăng giá trị lên 11 và in ra 11",
            "Lỗi cú pháp"
          ],
          "correctAnswer": "Biến a sẽ tăng giá trị lên 11 nhưng in ra 10",
          "reason": "Trong biểu thức `a = a++`, giá trị hiện tại của a được gán trước khi a được tăng, nên `a` sẽ vẫn là 10 khi được in ra."
        },
        {
          "id": 9,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(10 / 0);\n    }\n}\n```",
          "options": [
            "Không có lỗi cú pháp",
            "Lỗi ArithmeticException",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi cú pháp",
          "reason": "Đoạn mã không có lỗi cú pháp, nhưng sẽ gây ra ArithmeticException khi chạy vì chia cho 0."
        },
        {
          "id": 10,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        s[0] = 'h';\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi ArrayIndexOutOfBoundsException",
            "Lỗi không thể thay đổi chuỗi",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Lỗi không thể thay đổi chuỗi",
          "reason": "Chuỗi trong Java là bất biến (immutable), không thể thay đổi ký tự tại vị trí nào sau khi được tạo."
        },
        {
          "id": 11,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 5;\n        if(a > 3)\n            System.out.println(\"Greater\");\n        System.out.println(\"Done\");\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu ngoặc nhọn cho khối if",
            "Lỗi logic trong điều kiện",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ, mặc dù không sử dụng dấu ngoặc nhọn cho khối if."
        },
        {
          "id": 12,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        for(int i = 0; i < 5; i++) {\n            if(i == 3)\n                break;\n        }\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu ngoặc nhọn cho khối if",
            "Lỗi vòng lặp",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ, sử dụng dấu ngoặc nhọn cho vòng lặp và không bắt buộc cho khối if đơn lẻ."
        },
        {
          "id": 13,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        String s = \"World\";\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi biến bị trùng tên trong cùng phạm vi",
            "Thiếu dấu ngoặc nhọn",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Lỗi biến bị trùng tên trong cùng phạm vi",
          "reason": "Không thể khai báo hai biến cùng tên `s` trong cùng một phạm vi."
        },
        {
          "id": 14,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Sum: \" + (5 + 10));\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi cú pháp",
            "Lỗi logic trong phép tính",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 'Sum: 15'."
        },
        {
          "id": 15,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        a += 5;\n        System.out.println(a);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy",
            "Lỗi toán học"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 15."
        },
        {
          "id": 16,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3};\n        System.out.println(arr.length);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi khai báo mảng",
            "Lỗi truy cập mảng",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 3."
        },
        {
          "id": 17,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        double d = 10.5;\n        int i = d;\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi chuyển đổi kiểu dữ liệu không an toàn",
            "Thiếu dấu chấm phẩy",
            "Lỗi toán học"
          ],
          "correctAnswer": "Lỗi chuyển đổi kiểu dữ liệu không an toàn",
          "reason": "Không thể gán giá trị kiểu double cho biến int mà không thực hiện ép kiểu rõ ràng."
        },
        {
          "id": 18,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Java\";\n        s.toUpperCase();\n        System.out.println(s);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi phương thức không trả về giá trị",
            "Phương thức toUpperCase() không hoạt động",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ, nhưng `toUpperCase()` không thay đổi giá trị của `s` vì chuỗi là bất biến. Kết quả in ra vẫn là 'Java'."
        },
        {
          "id": 19,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        for(int i = 0; i <= 5; i++) {\n            System.out.println(i);\n        }\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi vòng lặp vô hạn",
            "Lỗi truy cập mảng",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra các số từ 0 đến 5."
        },
        {
          "id": 20,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        s = s + 5;\n        System.out.println(s);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy",
            "Lỗi toán học"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 'Hello5'."
        },
        {
          "id": 21,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        boolean flag = 1;\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy",
            "Lỗi logic"
          ],
          "correctAnswer": "Lỗi kiểu dữ liệu",
          "reason": "Không thể gán giá trị số nguyên `1` cho biến kiểu boolean."
        },
        {
          "id": 22,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Java\";\n        char c = s.charAt(4);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi IndexOutOfBoundsException",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Lỗi IndexOutOfBoundsException",
          "reason": "Chuỗi 'Java' có chỉ số từ 0 đến 3. `s.charAt(4)` vượt quá giới hạn và sẽ gây ra lỗi khi chạy."
        },
        {
          "id": 23,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 5,\n            b = 10;\n        System.out.println(a + b);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi khai báo biến",
            "Thiếu dấu chấm phẩy",
            "Lỗi toán học"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 15."
        },
        {
          "id": 24,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        s.length = 10;\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi gán giá trị cho phương thức",
            "Thiếu dấu chấm phẩy",
            "Lỗi logic"
          ],
          "correctAnswer": "Lỗi gán giá trị cho phương thức",
          "reason": "`length` là phương thức của lớp String và không thể gán giá trị trực tiếp cho nó."
        },
        {
          "id": 25,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 20\n        System.out.println(a + b);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu chấm phẩy sau khai báo biến b",
            "Lỗi kiểu dữ liệu",
            "Lỗi toán học"
          ],
          "correctAnswer": "Thiếu dấu chấm phẩy sau khai báo biến b",
          "reason": "Dòng `int b = 20` thiếu dấu chấm phẩy ở cuối."
        },
        {
          "id": 26,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Value: \" + value);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Biến value chưa được khai báo",
            "Thiếu dấu chấm phẩy",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Biến value chưa được khai báo",
          "reason": "Biến `value` chưa được khai báo trước khi sử dụng."
        },
        {
          "id": 27,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        if(a > 5)\n            System.out.println(\"Greater\");\n        else\n            System.out.println(\"Less or Equal\");\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu ngoặc nhọn cho khối if-else",
            "Lỗi logic trong điều kiện",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 'Greater'."
        },
        {
          "id": 28,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        for(int i = 0; i < 5; i++) {\n            if(i == 2) {\n                continue;\n            }\n            System.out.println(i);\n        }\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu ngoặc nhọn đóng cho if",
            "Lỗi logic trong vòng lặp",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 0, 1, 3, 4."
        },
        {
          "id": 29,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Java\";\n        s = s.toLowerCase();\n        System.out.println(s);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi phương thức không tồn tại",
            "Thiếu dấu chấm phẩy",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 'java'."
        },
        {
          "id": 30,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        double b = a / 2;\n        System.out.println(b);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi kiểu dữ liệu trong phép chia",
            "Thiếu dấu chấm phẩy",
            "Lỗi toán học"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 5.0. Trong phép chia, int được chuyển thành double tự động."
        },
        {
          "id": 31,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int[] arr = new int[3];\n        arr[-1] = 5;\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi IndexOutOfBoundsException",
            "Lỗi cú pháp",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã không có lỗi cú pháp, nhưng sẽ gây ra ArrayIndexOutOfBoundsException khi chạy vì chỉ số -1 không hợp lệ."
        },
        {
          "id": 32,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        final int x = 10;\n        x = 20;\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi vì biến x được khai báo là final không thể thay đổi",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Lỗi vì biến x được khai báo là final không thể thay đổi",
          "reason": "Biến `x` được khai báo là `final`, nên không thể gán giá trị mới cho nó sau khi đã khởi tạo."
        },
        {
          "id": 33,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        s = s.substring(1, 10);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi StringIndexOutOfBoundsException",
            "Lỗi cú pháp",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã không có lỗi cú pháp, nhưng sẽ gây ra StringIndexOutOfBoundsException khi chạy vì chỉ số 10 vượt quá độ dài của chuỗi."
        },
        {
          "id": 34,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 5\n        int b = 10;\n        System.out.println(a + b);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu chấm phẩy sau khai báo biến a",
            "Lỗi kiểu dữ liệu",
            "Lỗi toán học"
          ],
          "correctAnswer": "Thiếu dấu chấm phẩy sau khai báo biến a",
          "reason": "Dòng `int a = 5` thiếu dấu chấm phẩy ở cuối."
        },
        {
          "id": 35,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n    void method() {\n        // Some code\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Phương thức main phải là static",
            "Thiếu dấu ngoặc nhọn đóng cho lớp",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ, có phương thức main là static và các phương thức khác đều được định nghĩa đúng cách."
        },
        {
          "id": 36,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 20;\n        if(a > b)\n            System.out.println(\"a is greater\");\n        else\n            System.out.println(\"b is greater\");\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu ngoặc nhọn cho khối if-else",
            "Lỗi logic trong điều kiện",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 'b is greater'."
        },
        {
          "id": 37,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 5;\n        if(a == 5) {\n            System.out.println(\"Five\");\n        }\n        else {\n            System.out.println(\"Not Five\");\n        }\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi dấu ngoặc nhọn",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 'Five'."
        },
        {
          "id": 38,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10, b = 20, c = 30;\n        System.out.println(a + b + c);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi khai báo biến",
            "Thiếu dấu chấm phẩy",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 60."
        },
        {
          "id": 39,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        double b = 5.5;\n        a = b;\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi chuyển đổi kiểu dữ liệu không an toàn",
            "Thiếu dấu chấm phẩy",
            "Lỗi toán học"
          ],
          "correctAnswer": "Lỗi chuyển đổi kiểu dữ liệu không an toàn",
          "reason": "Không thể gán giá trị kiểu double (`b`) cho biến int (`a`) mà không thực hiện ép kiểu rõ ràng."
        },
        {
          "id": 40,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        s = s.toLowerCase;\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu ngoặc nhọn cho phương thức toLowerCase",
            "Thiếu dấu ngoặc để gọi phương thức toLowerCase()",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Thiếu dấu ngoặc để gọi phương thức toLowerCase()",
          "reason": "Phương thức `toLowerCase` cần được gọi với dấu ngoặc, nên `s.toLowerCase();`."
        },
        {
          "id": 41,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        for(int i = 0; i < 5; i++)\n            System.out.println(i);\n            System.out.println(\"Done\");\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi về phạm vi của vòng lặp for",
            "Thiếu dấu ngoặc nhọn cho vòng lặp for",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ, `System.out.println(\"Done\");` nằm ngoài vòng lặp for."
        },
        {
          "id": 42,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Java\";\n        System.out.println(s.charAt(4));\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi StringIndexOutOfBoundsException",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Lỗi StringIndexOutOfBoundsException",
          "reason": "Chuỗi 'Java' có chỉ số từ 0 đến 3. `s.charAt(4)` vượt quá giới hạn và sẽ gây ra lỗi khi chạy."
        },
        {
          "id": 43,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = ++a;\n        System.out.println(a + b);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi toán học",
            "Thiếu dấu chấm phẩy",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 22 (a = 11, b = 11)."
        },
        {
          "id": 44,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Java\";\n        s = s.replace('a', 'o');\n        System.out.println(s);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi phương thức replace",
            "Thiếu dấu chấm phẩy",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 'Jovo'."
        },
        {
          "id": 45,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        if(a > 5) {\n            System.out.println(\"Greater\");\n        }\n        else if(a < 15) {\n            System.out.println(\"Less than 15\");\n        }\n        else {\n            System.out.println(\"Equal to 15\");\n        }\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Thiếu dấu ngoặc nhọn cho khối else if",
            "Lỗi cú pháp",
            "Lỗi logic trong điều kiện"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 'Greater'."
        },
        {
          "id": 46,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        System.out.println(s.length);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi vì length là phương thức nên cần dấu ngoặc",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Lỗi vì length là phương thức nên cần dấu ngoặc",
          "reason": "`length` trong String là một thuộc tính không phải phương thức, nhưng trong Java, `length()` là phương thức để lấy độ dài chuỗi. Nếu sử dụng `s.length`, nó sẽ trả về giá trị thuộc tính không hợp lệ."
        },
        {
          "id": 47,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 0;\n        System.out.println(a / b);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi ArithmeticException",
            "Lỗi kiểu dữ liệu",
            "Thiếu dấu chấm phẩy"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã không có lỗi cú pháp, nhưng sẽ gây ra ArithmeticException khi chạy vì chia cho 0."
        },
        {
          "id": 48,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 20;\n        int c = a + b;\n        System.out.println(\"Sum: \" + c);\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi toán học",
            "Thiếu dấu chấm phẩy",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 'Sum: 30'."
        },
        {
          "id": 49,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"Java\";\n        System.out.println(s.toUpperCase());\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Lỗi phương thức toUpperCase",
            "Thiếu dấu chấm phẩy",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Không có lỗi",
          "reason": "Đoạn mã hợp lệ và sẽ in ra 'JAVA'."
        },
        {
          "id": 50,
          "question": "Đoạn mã sau có lỗi gì?\n```java\npublic class Test {\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 20;\n        int c = a + b + d;\n    }\n}\n```",
          "options": [
            "Không có lỗi",
            "Biến d chưa được khai báo",
            "Thiếu dấu chấm phẩy",
            "Lỗi kiểu dữ liệu"
          ],
          "correctAnswer": "Biến d chưa được khai báo",
          "reason": "Biến `d` chưa được khai báo trước khi sử dụng trong phép gán `c = a + b + d`."
        }
      ]
    },
    {
      "id": 12,
      "title": "Quiz về SQL và Query SQL",
      "timeLimit": 3600,
      "questions": [
        {
          "id": 1,
          "question": "Câu lệnh SQL nào được sử dụng để truy vấn dữ liệu từ một bảng?",
          "options": ["INSERT", "SELECT", "UPDATE", "DELETE"],
          "correctAnswer": "SELECT",
          "reason": "Câu lệnh SELECT được sử dụng để truy vấn và lấy dữ liệu từ các bảng trong cơ sở dữ liệu."
        },
        {
          "id": 2,
          "question": "Câu lệnh SQL nào được sử dụng để thêm một hàng mới vào bảng?",
          "options": ["INSERT", "SELECT", "UPDATE", "DELETE"],
          "correctAnswer": "INSERT",
          "reason": "Câu lệnh INSERT được sử dụng để thêm một hàng mới vào bảng trong cơ sở dữ liệu."
        },
        {
          "id": 3,
          "question": "Câu lệnh SQL nào được sử dụng để sửa đổi dữ liệu trong bảng?",
          "options": ["INSERT", "SELECT", "UPDATE", "DELETE"],
          "correctAnswer": "UPDATE",
          "reason": "Câu lệnh UPDATE được sử dụng để sửa đổi dữ liệu hiện có trong bảng."
        },
        {
          "id": 4,
          "question": "Câu lệnh SQL nào được sử dụng để xóa dữ liệu khỏi bảng?",
          "options": ["INSERT", "SELECT", "UPDATE", "DELETE"],
          "correctAnswer": "DELETE",
          "reason": "Câu lệnh DELETE được sử dụng để xóa dữ liệu từ bảng trong cơ sở dữ liệu."
        },
        {
          "id": 5,
          "question": "Câu lệnh SQL nào được sử dụng để tạo một bảng mới?",
          "options": [
            "CREATE TABLE",
            "ALTER TABLE",
            "DROP TABLE",
            "INSERT INTO"
          ],
          "correctAnswer": "CREATE TABLE",
          "reason": "Câu lệnh CREATE TABLE được sử dụng để tạo một bảng mới trong cơ sở dữ liệu."
        },
        {
          "id": 6,
          "question": "Trong SQL, từ khóa nào được sử dụng để sắp xếp kết quả truy vấn?",
          "options": ["ORDER BY", "GROUP BY", "SORT BY", "FILTER BY"],
          "correctAnswer": "ORDER BY",
          "reason": "ORDER BY được sử dụng để sắp xếp kết quả truy vấn theo một hoặc nhiều cột."
        },
        {
          "id": 7,
          "question": "Câu lệnh SQL nào được sử dụng để thay đổi cấu trúc của bảng hiện có?",
          "options": ["CREATE TABLE", "ALTER TABLE", "DROP TABLE", "SELECT"],
          "correctAnswer": "ALTER TABLE",
          "reason": "ALTER TABLE được sử dụng để thay đổi cấu trúc của bảng hiện có, như thêm hoặc xóa cột."
        },
        {
          "id": 8,
          "question": "Câu lệnh SQL nào được sử dụng để lấy duy nhất các giá trị khác nhau từ một cột?",
          "options": [
            "SELECT DISTINCT",
            "SELECT UNIQUE",
            "SELECT DIFFERENT",
            "SELECT SEPARATE"
          ],
          "correctAnswer": "SELECT DISTINCT",
          "reason": "SELECT DISTINCT được sử dụng để lấy các giá trị khác nhau và loại bỏ các bản ghi trùng lặp."
        },
        {
          "id": 9,
          "question": "Trong SQL, JOIN nào trả về tất cả các bản ghi từ bảng bên trái và các bản ghi khớp từ bảng bên phải?",
          "options": ["INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN"],
          "correctAnswer": "LEFT JOIN",
          "reason": "LEFT JOIN trả về tất cả các bản ghi từ bảng bên trái và các bản ghi khớp từ bảng bên phải. Nếu không có sự khớp, kết quả là NULL cho bảng bên phải."
        },
        {
          "id": 10,
          "question": "Câu lệnh SQL nào được sử dụng để gán bí danh (alias) cho bảng hoặc cột?",
          "options": ["AS", "ALIAS", "RENAME", "NICKNAME"],
          "correctAnswer": "AS",
          "reason": "Từ khóa AS được sử dụng để gán bí danh cho bảng hoặc cột trong SQL."
        },
        {
          "id": 11,
          "question": "Câu lệnh SQL nào được sử dụng để nhóm các hàng có cùng giá trị trong một hoặc nhiều cột?",
          "options": ["GROUP BY", "ORDER BY", "SORT BY", "FILTER BY"],
          "correctAnswer": "GROUP BY",
          "reason": "GROUP BY được sử dụng để nhóm các hàng có cùng giá trị trong một hoặc nhiều cột, thường đi kèm với các hàm tổng hợp như COUNT, SUM."
        },
        {
          "id": 12,
          "question": "Trong SQL, hàm nào được sử dụng để đếm số lượng hàng trong một bảng?",
          "options": ["COUNT()", "SUM()", "AVG()", "MAX()"],
          "correctAnswer": "COUNT()",
          "reason": "Hàm COUNT() được sử dụng để đếm số lượng hàng trong một bảng hoặc trong một tập hợp dữ liệu."
        },
        {
          "id": 13,
          "question": "Câu lệnh SQL nào được sử dụng để thêm một cột mới vào bảng hiện có?",
          "options": [
            "ALTER TABLE ... ADD",
            "CREATE TABLE ... ADD",
            "UPDATE TABLE ... ADD",
            "MODIFY TABLE ... ADD"
          ],
          "correctAnswer": "ALTER TABLE ... ADD",
          "reason": "Câu lệnh ALTER TABLE ... ADD được sử dụng để thêm một cột mới vào bảng hiện có."
        },
        {
          "id": 14,
          "question": "Trong SQL, từ khóa nào được sử dụng để chỉ định điều kiện lọc?",
          "options": ["WHERE", "HAVING", "GROUP BY", "ORDER BY"],
          "correctAnswer": "WHERE",
          "reason": "WHERE được sử dụng để chỉ định điều kiện lọc các hàng trong truy vấn SQL."
        },
        {
          "id": 15,
          "question": "Câu lệnh SQL nào được sử dụng để xóa một bảng khỏi cơ sở dữ liệu?",
          "options": [
            "DROP TABLE",
            "DELETE TABLE",
            "REMOVE TABLE",
            "TRUNCATE TABLE"
          ],
          "correctAnswer": "DROP TABLE",
          "reason": "DROP TABLE được sử dụng để xóa hoàn toàn một bảng khỏi cơ sở dữ liệu."
        },
        {
          "id": 16,
          "question": "Trong SQL, hàm nào được sử dụng để tính trung bình của một cột?",
          "options": ["SUM()", "COUNT()", "AVG()", "MAX()"],
          "correctAnswer": "AVG()",
          "reason": "Hàm AVG() được sử dụng để tính trung bình của một cột trong SQL."
        },
        {
          "id": 17,
          "question": "Câu lệnh SQL nào được sử dụng để kiểm tra sự tồn tại của một điều kiện?",
          "options": ["IF EXISTS", "CHECK", "EXISTS", "VERIFY"],
          "correctAnswer": "EXISTS",
          "reason": "EXISTS được sử dụng để kiểm tra sự tồn tại của một điều kiện hoặc một tập hợp dữ liệu trong SQL."
        },
        {
          "id": 18,
          "question": "Trong SQL, lệnh nào được sử dụng để thay đổi giá trị của một cột trong các hàng được chọn?",
          "options": ["UPDATE", "ALTER", "MODIFY", "CHANGE"],
          "correctAnswer": "UPDATE",
          "reason": "UPDATE được sử dụng để thay đổi giá trị của một cột trong các hàng được chọn theo điều kiện."
        },
        {
          "id": 19,
          "question": "Câu lệnh SQL nào được sử dụng để chỉ định điều kiện sau khi nhóm dữ liệu?",
          "options": ["WHERE", "HAVING", "GROUP BY", "ORDER BY"],
          "correctAnswer": "HAVING",
          "reason": "HAVING được sử dụng để chỉ định điều kiện sau khi nhóm dữ liệu với GROUP BY."
        },
        {
          "id": 20,
          "question": "Trong SQL, cú pháp nào đúng để chọn tất cả các cột từ một bảng?",
          "options": [
            "SELECT * FROM table;",
            "SELECT all FROM table;",
            "SELECT everything FROM table;",
            "SELECT # FROM table;"
          ],
          "correctAnswer": "SELECT * FROM table;",
          "reason": "Cú pháp `SELECT * FROM table;` là đúng để chọn tất cả các cột từ một bảng."
        },
        {
          "id": 21,
          "question": "Câu lệnh SQL nào được sử dụng để hợp nhất dữ liệu từ hai bảng?",
          "options": ["JOIN", "UNION", "MERGE", "COMBINE"],
          "correctAnswer": "JOIN",
          "reason": "JOIN được sử dụng để hợp nhất dữ liệu từ hai bảng dựa trên một điều kiện chung."
        },
        {
          "id": 22,
          "question": "Trong SQL, từ khóa nào được sử dụng để loại bỏ các bản ghi trùng lặp?",
          "options": ["DISTINCT", "UNIQUE", "SEPARATE", "ONLY"],
          "correctAnswer": "DISTINCT",
          "reason": "DISTINCT được sử dụng để loại bỏ các bản ghi trùng lặp trong kết quả truy vấn."
        },
        {
          "id": 23,
          "question": "Câu lệnh SQL nào được sử dụng để thay đổi tên của một bảng?",
          "options": [
            "RENAME TABLE",
            "ALTER TABLE ... RENAME TO",
            "CHANGE TABLE NAME",
            "MODIFY TABLE ... RENAME"
          ],
          "correctAnswer": "ALTER TABLE ... RENAME TO",
          "reason": "ALTER TABLE ... RENAME TO được sử dụng để thay đổi tên của một bảng trong SQL."
        },
        {
          "id": 24,
          "question": "Trong SQL, từ khóa nào được sử dụng để thêm điều kiện trong một JOIN?",
          "options": ["WHERE", "ON", "GROUP BY", "HAVING"],
          "correctAnswer": "ON",
          "reason": "ON được sử dụng để thêm điều kiện trong một JOIN để xác định cách hợp nhất các bảng."
        },
        {
          "id": 25,
          "question": "Câu lệnh SQL nào được sử dụng để tạo chỉ mục trên một cột?",
          "options": [
            "CREATE INDEX",
            "CREATE TABLE",
            "ADD INDEX",
            "BUILD INDEX"
          ],
          "correctAnswer": "CREATE INDEX",
          "reason": "CREATE INDEX được sử dụng để tạo chỉ mục trên một cột nhằm tăng tốc độ truy vấn."
        },
        {
          "id": 26,
          "question": "Trong SQL, hàm nào được sử dụng để tìm giá trị lớn nhất trong một cột?",
          "options": ["MIN()", "MAX()", "SUM()", "AVG()"],
          "correctAnswer": "MAX()",
          "reason": "Hàm MAX() được sử dụng để tìm giá trị lớn nhất trong một cột."
        },
        {
          "id": 27,
          "question": "Câu lệnh SQL nào được sử dụng để thay đổi kiểu dữ liệu của một cột?",
          "options": [
            "ALTER TABLE ... MODIFY COLUMN",
            "CHANGE DATA TYPE",
            "UPDATE COLUMN TYPE",
            "MODIFY COLUMN TYPE"
          ],
          "correctAnswer": "ALTER TABLE ... MODIFY COLUMN",
          "reason": "ALTER TABLE ... MODIFY COLUMN được sử dụng để thay đổi kiểu dữ liệu của một cột trong SQL."
        },
        {
          "id": 28,
          "question": "Trong SQL, từ khóa nào được sử dụng để lấy kết quả trong một thứ tự cụ thể?",
          "options": ["ORDER BY", "SORT BY", "GROUP BY", "FILTER BY"],
          "correctAnswer": "ORDER BY",
          "reason": "ORDER BY được sử dụng để sắp xếp kết quả truy vấn theo một hoặc nhiều cột."
        },
        {
          "id": 29,
          "question": "Câu lệnh SQL nào được sử dụng để tạo một bản sao của bảng hiện có?",
          "options": [
            "CREATE TABLE ... AS SELECT",
            "COPY TABLE",
            "DUPLICATE TABLE",
            "CLONE TABLE"
          ],
          "correctAnswer": "CREATE TABLE ... AS SELECT",
          "reason": "CREATE TABLE ... AS SELECT được sử dụng để tạo một bản sao của bảng hiện có bằng cách chọn dữ liệu từ bảng đó."
        },
        {
          "id": 30,
          "question": "Trong SQL, từ khóa nào được sử dụng để kiểm tra sự tồn tại của một bản ghi?",
          "options": ["EXISTS", "IF EXISTS", "CHECK", "VERIFY"],
          "correctAnswer": "EXISTS",
          "reason": "EXISTS được sử dụng để kiểm tra sự tồn tại của một bản ghi hoặc một tập hợp dữ liệu trong SQL."
        },
        {
          "id": 31,
          "question": "Câu lệnh SQL nào được sử dụng để thay đổi dữ liệu trong một bảng?",
          "options": ["UPDATE", "SELECT", "INSERT", "DELETE"],
          "correctAnswer": "UPDATE",
          "reason": "Câu lệnh UPDATE được sử dụng để thay đổi dữ liệu hiện có trong bảng."
        },
        {
          "id": 32,
          "question": "Trong SQL, hàm nào được sử dụng để tìm giá trị nhỏ nhất trong một cột?",
          "options": ["MIN()", "MAX()", "SUM()", "AVG()"],
          "correctAnswer": "MIN()",
          "reason": "Hàm MIN() được sử dụng để tìm giá trị nhỏ nhất trong một cột."
        },
        {
          "id": 33,
          "question": "Câu lệnh SQL nào được sử dụng để tạo một chỉ mục?",
          "options": [
            "CREATE INDEX",
            "CREATE TABLE",
            "ALTER TABLE",
            "DROP INDEX"
          ],
          "correctAnswer": "CREATE INDEX",
          "reason": "CREATE INDEX được sử dụng để tạo một chỉ mục trên một cột nhằm tăng tốc độ truy vấn."
        },
        {
          "id": 34,
          "question": "Trong SQL, từ khóa nào được sử dụng để kết hợp các kết quả của hai truy vấn SELECT?",
          "options": ["JOIN", "UNION", "MERGE", "COMBINE"],
          "correctAnswer": "UNION",
          "reason": "UNION được sử dụng để kết hợp các kết quả của hai truy vấn SELECT với nhau, loại bỏ các bản ghi trùng lặp."
        },
        {
          "id": 35,
          "question": "Câu lệnh SQL nào được sử dụng để giới hạn số lượng bản ghi trả về?",
          "options": ["LIMIT", "TOP", "ROWNUM", "All of the above"],
          "correctAnswer": "All of the above",
          "reason": "LIMIT (MySQL), TOP (SQL Server), và ROWNUM (Oracle) đều được sử dụng để giới hạn số lượng bản ghi trả về trong các hệ quản trị cơ sở dữ liệu khác nhau."
        },
        {
          "id": 36,
          "question": "Trong SQL, từ khóa nào được sử dụng để sắp xếp kết quả truy vấn theo thứ tự giảm dần?",
          "options": ["ASC", "DESC", "DOWN", "REVERSE"],
          "correctAnswer": "DESC",
          "reason": "DESC được sử dụng để sắp xếp kết quả truy vấn theo thứ tự giảm dần."
        },
        {
          "id": 37,
          "question": "Câu lệnh SQL nào được sử dụng để thêm một ràng buộc khóa ngoại?",
          "options": [
            "ALTER TABLE ... ADD CONSTRAINT",
            "CREATE FOREIGN KEY",
            "ADD FOREIGN KEY",
            "SET FOREIGN KEY"
          ],
          "correctAnswer": "ALTER TABLE ... ADD CONSTRAINT",
          "reason": "ALTER TABLE ... ADD CONSTRAINT được sử dụng để thêm một ràng buộc khóa ngoại vào bảng hiện có."
        },
        {
          "id": 38,
          "question": "Trong SQL, hàm nào được sử dụng để ghép các chuỗi lại với nhau?",
          "options": ["CONCAT()", "JOIN()", "MERGE()", "COMBINE()"],
          "correctAnswer": "CONCAT()",
          "reason": "Hàm CONCAT() được sử dụng để ghép các chuỗi lại với nhau trong SQL."
        },
        {
          "id": 39,
          "question": "Câu lệnh SQL nào được sử dụng để thay đổi tên của một cột trong bảng?",
          "options": [
            "ALTER TABLE ... RENAME COLUMN",
            "CHANGE COLUMN",
            "RENAME COLUMN",
            "MODIFY COLUMN"
          ],
          "correctAnswer": "ALTER TABLE ... RENAME COLUMN",
          "reason": "ALTER TABLE ... RENAME COLUMN được sử dụng để thay đổi tên của một cột trong bảng."
        },
        {
          "id": 40,
          "question": "Trong SQL, từ khóa nào được sử dụng để chỉ định điều kiện cho các hàm tổng hợp?",
          "options": ["WHERE", "HAVING", "GROUP BY", "ORDER BY"],
          "correctAnswer": "HAVING",
          "reason": "HAVING được sử dụng để chỉ định điều kiện cho các hàm tổng hợp sau khi đã nhóm dữ liệu với GROUP BY."
        },
        {
          "id": 41,
          "question": "Câu lệnh SQL nào được sử dụng để xóa tất cả các bản ghi khỏi bảng mà không xóa bảng?",
          "options": [
            "DELETE FROM table",
            "TRUNCATE TABLE",
            "DROP TABLE",
            "REMOVE FROM table"
          ],
          "correctAnswer": "TRUNCATE TABLE",
          "reason": "TRUNCATE TABLE xóa tất cả các bản ghi khỏi bảng mà không xóa bảng và thường nhanh hơn DELETE."
        },
        {
          "id": 42,
          "question": "Trong SQL, cú pháp nào đúng để sử dụng hàm COUNT với một điều kiện?",
          "options": [
            "SELECT COUNT(*) WHERE condition FROM table;",
            "SELECT COUNT(*) FROM table WHERE condition;",
            "SELECT COUNT(*) FROM table WHERE condition = TRUE;",
            "SELECT COUNT WHERE condition FROM table;"
          ],
          "correctAnswer": "SELECT COUNT(*) FROM table WHERE condition;",
          "reason": "Cú pháp `SELECT COUNT(*) FROM table WHERE condition;` là đúng để đếm số bản ghi thỏa mãn điều kiện."
        },
        {
          "id": 43,
          "question": "Câu lệnh SQL nào được sử dụng để tạo một bảng mới dựa trên kết quả của một truy vấn SELECT?",
          "options": [
            "CREATE TABLE ... AS SELECT",
            "CREATE NEW TABLE FROM SELECT",
            "COPY TABLE FROM SELECT",
            "DUPLICATE TABLE AS SELECT"
          ],
          "correctAnswer": "CREATE TABLE ... AS SELECT",
          "reason": "`CREATE TABLE ... AS SELECT` được sử dụng để tạo một bảng mới dựa trên kết quả của một truy vấn SELECT."
        },
        {
          "id": 44,
          "question": "Trong SQL, hàm nào được sử dụng để chuyển đổi chuỗi thành chữ hoa?",
          "options": ["LOWER()", "UPPER()", "INITCAP()", "CAPITALIZE()"],
          "correctAnswer": "UPPER()",
          "reason": "Hàm UPPER() được sử dụng để chuyển đổi chuỗi thành chữ hoa trong SQL."
        },
        {
          "id": 45,
          "question": "Câu lệnh SQL nào được sử dụng để kiểm tra sự tồn tại của một bản ghi?",
          "options": ["EXISTS", "IF EXISTS", "CHECK", "VERIFY"],
          "correctAnswer": "EXISTS",
          "reason": "EXISTS được sử dụng trong các điều kiện để kiểm tra sự tồn tại của một bản ghi hoặc tập hợp dữ liệu."
        },
        {
          "id": 46,
          "question": "Trong SQL, từ khóa nào được sử dụng để phân loại dữ liệu trước khi áp dụng các hàm tổng hợp?",
          "options": ["WHERE", "GROUP BY", "HAVING", "ORDER BY"],
          "correctAnswer": "GROUP BY",
          "reason": "GROUP BY được sử dụng để phân loại dữ liệu thành các nhóm trước khi áp dụng các hàm tổng hợp như COUNT, SUM."
        },
        {
          "id": 47,
          "question": "Câu lệnh SQL nào được sử dụng để đổi tên một bảng?",
          "options": [
            "ALTER TABLE ... RENAME TO",
            "RENAME TABLE",
            "CHANGE TABLE NAME",
            "MODIFY TABLE ... RENAME"
          ],
          "correctAnswer": "ALTER TABLE ... RENAME TO",
          "reason": "`ALTER TABLE ... RENAME TO` được sử dụng để đổi tên một bảng trong SQL."
        },
        {
          "id": 48,
          "question": "Trong SQL, hàm nào được sử dụng để tìm giá trị trung bình của một cột?",
          "options": ["SUM()", "COUNT()", "AVG()", "MAX()"],
          "correctAnswer": "AVG()",
          "reason": "Hàm AVG() được sử dụng để tính giá trị trung bình của một cột trong SQL."
        },
        {
          "id": 49,
          "question": "Câu lệnh SQL nào được sử dụng để xóa một cột khỏi bảng?",
          "options": [
            "ALTER TABLE ... DROP COLUMN",
            "DROP COLUMN",
            "REMOVE COLUMN",
            "DELETE COLUMN"
          ],
          "correctAnswer": "ALTER TABLE ... DROP COLUMN",
          "reason": "`ALTER TABLE ... DROP COLUMN` được sử dụng để xóa một cột khỏi bảng trong SQL."
        },
        {
          "id": 50,
          "question": "Trong SQL, từ khóa nào được sử dụng để kết hợp các điều kiện trong mệnh đề WHERE?",
          "options": ["AND", "OR", "NOT", "All of the above"],
          "correctAnswer": "All of the above",
          "reason": "AND, OR, và NOT đều được sử dụng để kết hợp các điều kiện trong mệnh đề WHERE trong SQL."
        }
      ]
    },
    {
      "id": 13,
      "title": "Quiz về Quản Lý Dự Án",
      "timeLimit": 1800,
      "questions": [
        {
          "id": 1,
          "question": "Phương pháp quản lý dự án nào tập trung vào việc hoàn thành các công việc theo trình tự tuyến tính?",
          "options": ["Agile", "Waterfall", "Scrum", "Kanban"],
          "correctAnswer": "Waterfall",
          "reason": "Phương pháp Waterfall tập trung vào việc hoàn thành các công việc theo trình tự tuyến tính, từ phân tích yêu cầu đến bảo trì."
        },
        {
          "id": 2,
          "question": "Trong Agile, vai trò nào chịu trách nhiệm quản lý backlog và ưu tiên các tính năng?",
          "options": [
            "Scrum Master",
            "Product Owner",
            "Development Team",
            "Project Manager"
          ],
          "correctAnswer": "Product Owner",
          "reason": "Product Owner chịu trách nhiệm quản lý backlog và ưu tiên các tính năng dựa trên giá trị kinh doanh."
        },
        {
          "id": 3,
          "question": "Phần mềm nào thường được sử dụng để quản lý dự án theo phương pháp Agile?",
          "options": ["Microsoft Project", "JIRA", "Excel", "Visio"],
          "correctAnswer": "JIRA",
          "reason": "JIRA là một trong những phần mềm phổ biến được sử dụng để quản lý dự án theo phương pháp Agile, đặc biệt là Scrum và Kanban."
        },
        {
          "id": 4,
          "question": "Phần nào của biểu đồ Gantt thể hiện tiến độ thực hiện các công việc?",
          "options": ["Trục X", "Trục Y", "Thanh Gantt", "Mũi tên"],
          "correctAnswer": "Thanh Gantt",
          "reason": "Thanh Gantt trong biểu đồ Gantt thể hiện tiến độ thực hiện các công việc theo thời gian."
        },
        {
          "id": 5,
          "question": "Trong quản lý dự án, KPI là viết tắt của gì?",
          "options": [
            "Key Performance Indicator",
            "Knowledge Process Indicator",
            "Key Project Indicator",
            "Knowledge Performance Indicator"
          ],
          "correctAnswer": "Key Performance Indicator",
          "reason": "KPI (Key Performance Indicator) là các chỉ số chính được sử dụng để đo lường hiệu suất và tiến độ của dự án."
        },
        {
          "id": 6,
          "question": "Phương pháp Agile nào sử dụng các sprint để phát triển phần mềm?",
          "options": ["Kanban", "Scrum", "Waterfall", "Lean"],
          "correctAnswer": "Scrum",
          "reason": "Scrum sử dụng các sprint, thường là từ 2-4 tuần, để phát triển phần mềm theo từng giai đoạn nhỏ."
        },
        {
          "id": 7,
          "question": "Trong quản lý dự án, mô hình PERT được sử dụng để làm gì?",
          "options": [
            "Theo dõi tiến độ dự án",
            "Phân tích rủi ro dự án",
            "Tính toán thời gian hoàn thành dự án dựa trên các ước lượng khác nhau",
            "Phân chia công việc"
          ],
          "correctAnswer": "Tính toán thời gian hoàn thành dự án dựa trên các ước lượng khác nhau",
          "reason": "PERT (Program Evaluation Review Technique) được sử dụng để tính toán thời gian hoàn thành dự án dựa trên các ước lượng thời gian tối ưu, trung bình và bi quan."
        },
        {
          "id": 8,
          "question": "Phương pháp Lean trong quản lý dự án tập trung vào việc gì?",
          "options": [
            "Tối đa hóa giá trị và giảm lãng phí",
            "Phân chia công việc thành các sprint",
            "Sử dụng biểu đồ Gantt",
            "Quản lý rủi ro"
          ],
          "correctAnswer": "Tối đa hóa giá trị và giảm lãng phí",
          "reason": "Phương pháp Lean tập trung vào việc tối đa hóa giá trị cho khách hàng và giảm thiểu các hoạt động lãng phí trong quá trình phát triển."
        },
        {
          "id": 9,
          "question": "Trong quản lý dự án, mô hình nào sử dụng vòng đời lặp lại với nhiều pha như lập kế hoạch, thiết kế, triển khai và kiểm thử?",
          "options": ["Waterfall", "Spiral", "Agile", "Kanban"],
          "correctAnswer": "Spiral",
          "reason": "Mô hình Spiral kết hợp các yếu tố của Waterfall và lặp lại các pha như lập kế hoạch, thiết kế, triển khai và kiểm thử để phát triển phần mềm."
        },
        {
          "id": 10,
          "question": "Phương pháp quản lý dự án nào nhấn mạnh vào việc giao tiếp liên tục và phản hồi nhanh chóng từ khách hàng?",
          "options": ["Waterfall", "Agile", "Critical Path Method", "PRINCE2"],
          "correctAnswer": "Agile",
          "reason": "Agile nhấn mạnh vào sự giao tiếp liên tục và phản hồi nhanh chóng từ khách hàng để thích ứng với các thay đổi yêu cầu."
        },
        {
          "id": 11,
          "question": "Trong Scrum, vai trò nào chịu trách nhiệm đảm bảo nhóm tuân thủ các quy tắc và quy trình của Scrum?",
          "options": [
            "Product Owner",
            "Scrum Master",
            "Development Team",
            "Project Manager"
          ],
          "correctAnswer": "Scrum Master",
          "reason": "Scrum Master chịu trách nhiệm đảm bảo rằng nhóm tuân thủ các quy tắc và quy trình của Scrum, và hỗ trợ nhóm vượt qua các rào cản."
        },
        {
          "id": 12,
          "question": "Trong quản lý dự án, lược đồ PERT thường bao gồm những thành phần nào?",
          "options": [
            "Hoạt động, mối quan hệ, thời gian",
            "Chỉ hoạt động và thời gian",
            "Chỉ mối quan hệ và thời gian",
            "Hoạt động và tài nguyên"
          ],
          "correctAnswer": "Hoạt động, mối quan hệ, thời gian",
          "reason": "Lược đồ PERT bao gồm các hoạt động, mối quan hệ giữa chúng và thời gian cần thiết để hoàn thành mỗi hoạt động."
        },
        {
          "id": 13,
          "question": "Trong quản lý dự án, mô hình Critical Path Method (CPM) được sử dụng để làm gì?",
          "options": [
            "Tính toán thời gian hoàn thành dự án",
            "Quản lý rủi ro dự án",
            "Phân chia công việc",
            "Theo dõi tiến độ dự án"
          ],
          "correctAnswer": "Tính toán thời gian hoàn thành dự án",
          "reason": "CPM được sử dụng để xác định lộ trình quan trọng nhất trong dự án và tính toán thời gian hoàn thành tối thiểu."
        },
        {
          "id": 14,
          "question": "Trong quản lý dự án, các bên liên quan (stakeholders) là ai?",
          "options": [
            "Chỉ khách hàng",
            "Chỉ nhóm phát triển",
            "Bất kỳ ai có quan tâm hoặc ảnh hưởng đến dự án",
            "Chỉ quản lý dự án"
          ],
          "correctAnswer": "Bất kỳ ai có quan tâm hoặc ảnh hưởng đến dự án",
          "reason": "Stakeholders bao gồm bất kỳ ai có quan tâm hoặc ảnh hưởng đến dự án, bao gồm khách hàng, nhóm phát triển, nhà đầu tư, và người dùng cuối."
        },
        {
          "id": 15,
          "question": "Trong quản lý dự án, lược đồ Gantt giúp gì?",
          "options": [
            "Phân tích rủi ro dự án",
            "Theo dõi tiến độ dự án và thời gian hoàn thành các nhiệm vụ",
            "Quản lý ngân sách dự án",
            "Phân chia công việc"
          ],
          "correctAnswer": "Theo dõi tiến độ dự án và thời gian hoàn thành các nhiệm vụ",
          "reason": "Biểu đồ Gantt được sử dụng để theo dõi tiến độ dự án, hiển thị thời gian hoàn thành các nhiệm vụ và mối quan hệ giữa chúng."
        },
        {
          "id": 16,
          "question": "Trong quản lý dự án, nguyên tắc Triple Constraint bao gồm những yếu tố nào?",
          "options": [
            "Thời gian, ngân sách, chất lượng",
            "Thời gian, phạm vi, ngân sách",
            "Phạm vi, chất lượng, ngân sách",
            "Thời gian, phạm vi, chất lượng"
          ],
          "correctAnswer": "Thời gian, phạm vi, ngân sách",
          "reason": "Triple Constraint bao gồm thời gian, phạm vi và ngân sách, và sự thay đổi ở một yếu tố ảnh hưởng đến các yếu tố còn lại."
        },
        {
          "id": 17,
          "question": "Phương pháp nào trong quản lý dự án tập trung vào việc cải tiến liên tục và loại bỏ lãng phí?",
          "options": ["Agile", "Lean", "Waterfall", "Scrum"],
          "correctAnswer": "Lean",
          "reason": "Lean tập trung vào việc cải tiến liên tục, tối ưu hóa quy trình và loại bỏ các hoạt động lãng phí."
        },
        {
          "id": 18,
          "question": "Trong quản lý dự án, tài liệu nào mô tả chi tiết các yêu cầu chức năng và phi chức năng?",
          "options": [
            "Project Charter",
            "SRS (Software Requirements Specification)",
            "Design Document",
            "Test Plan"
          ],
          "correctAnswer": "SRS (Software Requirements Specification)",
          "reason": "SRS mô tả chi tiết các yêu cầu chức năng và phi chức năng của phần mềm cần được phát triển."
        },
        {
          "id": 19,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để xác định và phân tích các rủi ro?",
          "options": [
            "SWOT Analysis",
            "Risk Management",
            "PERT",
            "Gantt Chart"
          ],
          "correctAnswer": "Risk Management",
          "reason": "Risk Management là kỹ thuật được sử dụng để xác định, phân tích và lập kế hoạch ứng phó với các rủi ro trong dự án."
        },
        {
          "id": 20,
          "question": "Phương pháp PRINCE2 là viết tắt của cụm từ gì?",
          "options": [
            "Projects IN Controlled Environments",
            "Project Initiative Controlled Execution",
            "Projects Initiated for Controlled Environments",
            "Project IN Control Execution"
          ],
          "correctAnswer": "Projects IN Controlled Environments",
          "reason": "PRINCE2 stands for Projects IN Controlled Environments, một phương pháp quản lý dự án phổ biến ở Anh và các quốc gia khác."
        },
        {
          "id": 21,
          "question": "Trong quản lý dự án, thuật ngữ 'scope creep' đề cập đến điều gì?",
          "options": [
            "Phạm vi dự án mở rộng không kiểm soát",
            "Giảm phạm vi dự án",
            "Tăng ngân sách dự án",
            "Thay đổi nhóm dự án"
          ],
          "correctAnswer": "Phạm vi dự án mở rộng không kiểm soát",
          "reason": "Scope creep đề cập đến việc phạm vi dự án mở rộng không kiểm soát thông qua việc thêm các yêu cầu mới mà không điều chỉnh các nguồn lực."
        },
        {
          "id": 22,
          "question": "Trong quản lý dự án, vai trò nào chịu trách nhiệm về việc lập kế hoạch và giám sát dự án?",
          "options": [
            "Product Owner",
            "Scrum Master",
            "Project Manager",
            "Team Lead"
          ],
          "correctAnswer": "Project Manager",
          "reason": "Project Manager chịu trách nhiệm về việc lập kế hoạch, giám sát và điều phối các hoạt động của dự án để đạt được các mục tiêu đề ra."
        },
        {
          "id": 23,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để xác định các hoạt động cần thiết để hoàn thành dự án?",
          "options": [
            "Work Breakdown Structure (WBS)",
            "Gantt Chart",
            "PERT",
            "SWOT Analysis"
          ],
          "correctAnswer": "Work Breakdown Structure (WBS)",
          "reason": "WBS được sử dụng để phân tách dự án thành các hoạt động và công việc nhỏ hơn để quản lý dễ dàng hơn."
        },
        {
          "id": 24,
          "question": "Trong quản lý dự án, phương pháp nào sử dụng các bảng Kanban để quản lý luồng công việc?",
          "options": ["Scrum", "Kanban", "Waterfall", "Lean"],
          "correctAnswer": "Kanban",
          "reason": "Kanban sử dụng các bảng Kanban để quản lý và tối ưu hóa luồng công việc bằng cách giới hạn số lượng công việc đang thực hiện."
        },
        {
          "id": 25,
          "question": "Trong quản lý dự án, mô hình nào kết hợp các yếu tố của Agile và Waterfall?",
          "options": ["Scrum", "Hybrid", "Lean", "Kanban"],
          "correctAnswer": "Hybrid",
          "reason": "Mô hình Hybrid kết hợp các yếu tố của Agile và Waterfall để tận dụng lợi thế của cả hai phương pháp."
        },
        {
          "id": 26,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để xác định mối quan hệ phụ thuộc giữa các hoạt động?",
          "options": [
            "Dependency Diagram",
            "Risk Register",
            "SWOT Analysis",
            "Work Breakdown Structure"
          ],
          "correctAnswer": "Dependency Diagram",
          "reason": "Dependency Diagram được sử dụng để xác định mối quan hệ phụ thuộc giữa các hoạt động trong dự án."
        },
        {
          "id": 27,
          "question": "Trong quản lý dự án, từ khóa nào được sử dụng để mô tả tiến độ dự án?",
          "options": ["Milestones", "Deadlines", "Deliverables", "Resources"],
          "correctAnswer": "Milestones",
          "reason": "Milestones là các cột mốc quan trọng trong dự án để đánh dấu các giai đoạn hoặc kết quả chính."
        },
        {
          "id": 28,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để đánh giá và ưu tiên các yêu cầu dự án?",
          "options": [
            "MoSCoW",
            "PERT",
            "SWOT Analysis",
            "Work Breakdown Structure"
          ],
          "correctAnswer": "MoSCoW",
          "reason": "MoSCoW là kỹ thuật được sử dụng để phân loại và ưu tiên các yêu cầu dự án thành Must have, Should have, Could have, và Won't have."
        },
        {
          "id": 29,
          "question": "Trong quản lý dự án, thuật ngữ 'stakeholder' đề cập đến ai?",
          "options": [
            "Chỉ khách hàng",
            "Chỉ nhóm phát triển",
            "Bất kỳ ai có quan tâm hoặc ảnh hưởng đến dự án",
            "Chỉ quản lý dự án"
          ],
          "correctAnswer": "Bất kỳ ai có quan tâm hoặc ảnh hưởng đến dự án",
          "reason": "Stakeholder bao gồm bất kỳ ai có quan tâm hoặc ảnh hưởng đến dự án, bao gồm khách hàng, nhóm phát triển, nhà đầu tư, và người dùng cuối."
        },
        {
          "id": 30,
          "question": "Trong quản lý dự án, mô hình nào tập trung vào việc phân chia dự án thành các giai đoạn nhỏ và lặp lại quá trình?",
          "options": ["Waterfall", "Agile", "Spiral", "Kanban"],
          "correctAnswer": "Spiral",
          "reason": "Mô hình Spiral tập trung vào việc phân chia dự án thành các giai đoạn nhỏ và lặp lại quá trình để phát triển phần mềm theo từng vòng lặp."
        },
        {
          "id": 31,
          "question": "Trong quản lý dự án, 'PMBOK' là viết tắt của gì?",
          "options": [
            "Project Management Body of Knowledge",
            "Project Management Book of Knowledge",
            "Project Management Board of Knowledge",
            "Project Management Benchmark of Knowledge"
          ],
          "correctAnswer": "Project Management Body of Knowledge",
          "reason": "PMBOK stands for Project Management Body of Knowledge, một tập hợp các kiến thức, kỹ năng, công cụ và kỹ thuật được công nhận rộng rãi trong quản lý dự án."
        },
        {
          "id": 32,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để xác định mối quan hệ phụ thuộc giữa các công việc?",
          "options": [
            "Dependency Diagram",
            "SWOT Analysis",
            "PERT",
            "Gantt Chart"
          ],
          "correctAnswer": "Dependency Diagram",
          "reason": "Dependency Diagram được sử dụng để xác định mối quan hệ phụ thuộc giữa các công việc trong dự án."
        },
        {
          "id": 33,
          "question": "Trong quản lý dự án, 'stakeholder analysis' bao gồm gì?",
          "options": [
            "Xác định và phân loại các bên liên quan dự án",
            "Phân tích rủi ro dự án",
            "Xác định mục tiêu dự án",
            "Phân tích tài chính dự án"
          ],
          "correctAnswer": "Xác định và phân loại các bên liên quan dự án",
          "reason": "Stakeholder analysis bao gồm việc xác định và phân loại các bên liên quan dự án dựa trên ảnh hưởng và quan tâm của họ đến dự án."
        },
        {
          "id": 34,
          "question": "Trong quản lý dự án, mô hình nào tập trung vào việc phát triển phần mềm qua các vòng lặp với sự cải tiến liên tục?",
          "options": ["Waterfall", "Agile", "Spiral", "Kanban"],
          "correctAnswer": "Spiral",
          "reason": "Mô hình Spiral tập trung vào việc phát triển phần mềm qua các vòng lặp với sự cải tiến liên tục và quản lý rủi ro hiệu quả."
        },
        {
          "id": 35,
          "question": "Trong quản lý dự án, 'Earned Value Management (EVM)' được sử dụng để làm gì?",
          "options": [
            "Đo lường tiến độ và hiệu suất dự án",
            "Quản lý rủi ro dự án",
            "Phân chia công việc",
            "Xác định các bên liên quan"
          ],
          "correctAnswer": "Đo lường tiến độ và hiệu suất dự án",
          "reason": "EVM được sử dụng để đo lường tiến độ và hiệu suất dự án bằng cách so sánh giá trị công việc đã hoàn thành với kế hoạch và chi phí thực tế."
        },
        {
          "id": 36,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để ước lượng thời gian và chi phí của các công việc dựa trên kinh nghiệm và ý kiến chuyên gia?",
          "options": ["Delphi Technique", "PERT", "MoSCoW", "SWOT Analysis"],
          "correctAnswer": "Delphi Technique",
          "reason": "Delphi Technique sử dụng ý kiến của các chuyên gia để ước lượng thời gian và chi phí của các công việc trong dự án."
        },
        {
          "id": 37,
          "question": "Trong quản lý dự án, kỹ thuật nào giúp xác định các yếu tố quan trọng nhất ảnh hưởng đến thành công của dự án?",
          "options": [
            "SWOT Analysis",
            "Pareto Analysis",
            "Fishbone Diagram",
            "Risk Management"
          ],
          "correctAnswer": "Pareto Analysis",
          "reason": "Pareto Analysis giúp xác định các yếu tố quan trọng nhất ảnh hưởng đến thành công của dự án bằng cách áp dụng nguyên tắc 80/20."
        },
        {
          "id": 38,
          "question": "Trong quản lý dự án, 'scope statement' bao gồm gì?",
          "options": [
            "Mô tả phạm vi dự án, mục tiêu, và yêu cầu",
            "Phân tích rủi ro dự án",
            "Lịch trình dự án",
            "Ngân sách dự án"
          ],
          "correctAnswer": "Mô tả phạm vi dự án, mục tiêu, và yêu cầu",
          "reason": "Scope statement mô tả rõ ràng phạm vi dự án, mục tiêu, và các yêu cầu cần thực hiện để đạt được mục tiêu đó."
        },
        {
          "id": 39,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để đánh giá mức độ rủi ro và xác định ưu tiên đối với các rủi ro?",
          "options": [
            "Risk Matrix",
            "SWOT Analysis",
            "Gantt Chart",
            "Burn Down Chart"
          ],
          "correctAnswer": "Risk Matrix",
          "reason": "Risk Matrix được sử dụng để đánh giá mức độ rủi ro dựa trên xác suất và ảnh hưởng, từ đó xác định ưu tiên đối với các rủi ro."
        },
        {
          "id": 40,
          "question": "Trong quản lý dự án, mô hình nào được sử dụng phổ biến nhất để quản lý dự án theo phương pháp luận PRINCE2?",
          "options": ["Waterfall", "Agile", "PRINCE2", "Scrum"],
          "correctAnswer": "PRINCE2",
          "reason": "PRINCE2 là một phương pháp luận quản lý dự án được thiết kế để quản lý dự án theo các giai đoạn rõ ràng và kiểm soát."
        },
        {
          "id": 41,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để phân loại và ưu tiên các yêu cầu dự án?",
          "options": [
            "MoSCoW",
            "SWOT Analysis",
            "Risk Management",
            "Gantt Chart"
          ],
          "correctAnswer": "MoSCoW",
          "reason": "MoSCoW là kỹ thuật phân loại và ưu tiên các yêu cầu dự án thành Must have, Should have, Could have, và Won't have."
        },
        {
          "id": 42,
          "question": "Trong quản lý dự án, biểu đồ nào được sử dụng để thể hiện tiến độ dự án và các mốc quan trọng?",
          "options": [
            "PERT Chart",
            "Gantt Chart",
            "Fishbone Diagram",
            "Risk Matrix"
          ],
          "correctAnswer": "Gantt Chart",
          "reason": "Gantt Chart được sử dụng để thể hiện tiến độ dự án, các nhiệm vụ, thời gian hoàn thành và các mốc quan trọng."
        },
        {
          "id": 43,
          "question": "Trong quản lý dự án, 'Critical Path' là gì?",
          "options": [
            "Đường đi không quan trọng trong dự án",
            "Đường đi dài nhất qua các công việc có phụ thuộc",
            "Đường đi ngắn nhất qua các công việc không phụ thuộc",
            "Đường đi có ít rủi ro nhất"
          ],
          "correctAnswer": "Đường đi dài nhất qua các công việc có phụ thuộc",
          "reason": "Critical Path là đường đi dài nhất qua các công việc có phụ thuộc trong dự án, xác định thời gian hoàn thành tối thiểu của dự án."
        },
        {
          "id": 44,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để phân tích nguyên nhân gốc rễ của vấn đề?",
          "options": [
            "Fishbone Diagram",
            "Gantt Chart",
            "SWOT Analysis",
            "MoSCoW"
          ],
          "correctAnswer": "Fishbone Diagram",
          "reason": "Fishbone Diagram, còn gọi là Ishikawa Diagram, được sử dụng để phân tích nguyên nhân gốc rễ của vấn đề."
        },
        {
          "id": 45,
          "question": "Trong quản lý dự án, 'burn rate' đề cập đến gì?",
          "options": [
            "Tốc độ phát triển phần mềm",
            "Tốc độ tiêu hao ngân sách dự án",
            "Tốc độ hoàn thành công việc",
            "Tốc độ tăng trưởng nhóm"
          ],
          "correctAnswer": "Tốc độ tiêu hao ngân sách dự án",
          "reason": "Burn rate là tốc độ tiêu hao ngân sách dự án, thường được sử dụng để theo dõi mức độ chi tiêu so với kế hoạch."
        },
        {
          "id": 46,
          "question": "Trong quản lý dự án, phương pháp nào tập trung vào việc xác định và quản lý các rủi ro dự án?",
          "options": [
            "Risk Management",
            "Scope Management",
            "Time Management",
            "Cost Management"
          ],
          "correctAnswer": "Risk Management",
          "reason": "Risk Management tập trung vào việc xác định, phân tích, và quản lý các rủi ro có thể ảnh hưởng đến dự án."
        },
        {
          "id": 47,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để xác định thứ tự ưu tiên cho các công việc dựa trên sự phụ thuộc?",
          "options": [
            "Critical Path Method (CPM)",
            "SWOT Analysis",
            "MoSCoW",
            "Fishbone Diagram"
          ],
          "correctAnswer": "Critical Path Method (CPM)",
          "reason": "CPM được sử dụng để xác định thứ tự ưu tiên cho các công việc dựa trên sự phụ thuộc và tìm ra Critical Path của dự án."
        },
        {
          "id": 48,
          "question": "Trong quản lý dự án, 'deliverable' đề cập đến gì?",
          "options": [
            "Các tài liệu dự án",
            "Các phần mềm được hoàn thiện và giao cho khách hàng",
            "Các cuộc họp dự án",
            "Các lỗi phần mềm"
          ],
          "correctAnswer": "Các phần mềm được hoàn thiện và giao cho khách hàng",
          "reason": "Deliverable là các sản phẩm, phần mềm hoặc tài liệu được hoàn thiện và giao cho khách hàng hoặc các bên liên quan khác."
        },
        {
          "id": 49,
          "question": "Trong quản lý dự án, phương pháp nào nhấn mạnh vào việc giao tiếp liên tục và phản hồi nhanh chóng từ khách hàng?",
          "options": ["Waterfall", "Agile", "Critical Path Method", "PRINCE2"],
          "correctAnswer": "Agile",
          "reason": "Agile nhấn mạnh vào sự giao tiếp liên tục và phản hồi nhanh chóng từ khách hàng để thích ứng với các thay đổi yêu cầu."
        },
        {
          "id": 50,
          "question": "Trong quản lý dự án, kỹ thuật nào được sử dụng để xác định và phân tích các rủi ro dự án?",
          "options": [
            "Risk Matrix",
            "SWOT Analysis",
            "Gantt Chart",
            "Burn Down Chart"
          ],
          "correctAnswer": "Risk Matrix",
          "reason": "Risk Matrix được sử dụng để đánh giá mức độ rủi ro dựa trên xác suất và ảnh hưởng, từ đó xác định ưu tiên đối với các rủi ro."
        }
      ]
    },
    {
      "id": 14,
      "title": "Quiz về Hệ Điều Hành",
      "timeLimit": 1800,
      "questions": [
        {
          "id": 1,
          "question": "Hệ điều hành nào là nguồn mở phổ biến nhất?",
          "options": ["Windows", "macOS", "Linux", "Unix"],
          "correctAnswer": "Linux",
          "reason": "Linux là hệ điều hành nguồn mở phổ biến nhất, được sử dụng rộng rãi trong nhiều môi trường khác nhau."
        },
        {
          "id": 2,
          "question": "Trong hệ điều hành, quản lý tiến trình liên quan đến gì?",
          "options": [
            "Quản lý bộ nhớ",
            "Quản lý các tiến trình đang chạy",
            "Quản lý thiết bị ngoại vi",
            "Quản lý hệ thống tập tin"
          ],
          "correctAnswer": "Quản lý các tiến trình đang chạy",
          "reason": "Quản lý tiến trình liên quan đến việc tạo, hủy, và quản lý các tiến trình đang chạy trên hệ thống."
        },
        {
          "id": 3,
          "question": "Phần mềm nào sau đây không phải là hệ điều hành?",
          "options": ["Windows", "Android", "Microsoft Office", "Ubuntu"],
          "correctAnswer": "Microsoft Office",
          "reason": "Microsoft Office là bộ ứng dụng văn phòng, không phải là hệ điều hành."
        },
        {
          "id": 4,
          "question": "Trong hệ điều hành, paging là một kỹ thuật quản lý bộ nhớ nào?",
          "options": [
            "Phân đoạn (Segmentation)",
            "Kỹ thuật ảo hóa bộ nhớ (Virtual Memory)",
            "Quản lý bộ nhớ tĩnh",
            "Quản lý bộ nhớ động"
          ],
          "correctAnswer": "Kỹ thuật ảo hóa bộ nhớ (Virtual Memory)",
          "reason": "Paging là một kỹ thuật trong ảo hóa bộ nhớ, giúp chia bộ nhớ thành các trang nhỏ để quản lý hiệu quả hơn."
        },
        {
          "id": 5,
          "question": "Hệ thống tập tin nào được sử dụng trong Windows?",
          "options": ["ext4", "HFS+", "NTFS", "APFS"],
          "correctAnswer": "NTFS",
          "reason": "NTFS (New Technology File System) là hệ thống tập tin được sử dụng trong các phiên bản Windows hiện đại."
        },
        {
          "id": 6,
          "question": "Trong Linux, lệnh nào được sử dụng để xem các tiến trình đang chạy?",
          "options": ["ps", "ls", "cd", "mkdir"],
          "correctAnswer": "ps",
          "reason": "Lệnh `ps` trong Linux được sử dụng để xem danh sách các tiến trình đang chạy."
        },
        {
          "id": 7,
          "question": "Phần mềm nào được sử dụng để quản lý và kiểm soát các tiến trình trong hệ điều hành?",
          "options": ["Scheduler", "Shell", "Compiler", "Linker"],
          "correctAnswer": "Scheduler",
          "reason": "Scheduler (bộ lập lịch) được sử dụng để quản lý và kiểm soát các tiến trình, quyết định tiến trình nào sẽ được thực hiện tiếp theo."
        },
        {
          "id": 8,
          "question": "Trong hệ điều hành, deadlock xảy ra khi nào?",
          "options": [
            "Khi tiến trình chạy không ngừng",
            "Khi không gian bộ nhớ đầy",
            "Khi các tiến trình chờ nhau và không thể tiếp tục",
            "Khi không có tiến trình nào đang chạy"
          ],
          "correctAnswer": "Khi các tiến trình chờ nhau và không thể tiếp tục",
          "reason": "Deadlock xảy ra khi các tiến trình chờ nhau để giải phóng tài nguyên và không thể tiếp tục thực hiện."
        },
        {
          "id": 9,
          "question": "Trong hệ điều hành, kernel có vai trò gì?",
          "options": [
            "Quản lý giao diện người dùng",
            "Quản lý tài nguyên hệ thống và giao tiếp giữa phần cứng và phần mềm",
            "Xử lý dữ liệu người dùng",
            "Thiết kế giao diện đồ họa"
          ],
          "correctAnswer": "Quản lý tài nguyên hệ thống và giao tiếp giữa phần cứng và phần mềm",
          "reason": "Kernel là thành phần trung tâm của hệ điều hành, quản lý tài nguyên hệ thống và giao tiếp giữa phần cứng và phần mềm."
        },
        {
          "id": 10,
          "question": "Hệ điều hành nào sau đây được phát triển bởi Apple?",
          "options": ["Windows", "Linux", "macOS", "Android"],
          "correctAnswer": "macOS",
          "reason": "macOS là hệ điều hành được phát triển bởi Apple cho các máy tính Mac."
        },
        {
          "id": 11,
          "question": "Trong hệ điều hành, multitasking là gì?",
          "options": [
            "Chạy nhiều tiến trình cùng một lúc",
            "Tối ưu hóa bộ nhớ",
            "Chạy một tiến trình tại một thời điểm",
            "Tăng tốc độ xử lý"
          ],
          "correctAnswer": "Chạy nhiều tiến trình cùng một lúc",
          "reason": "Multitasking cho phép hệ điều hành chạy nhiều tiến trình cùng một lúc, chia sẻ tài nguyên CPU giữa chúng."
        },
        {
          "id": 12,
          "question": "Trong Windows, Task Manager được sử dụng để làm gì?",
          "options": [
            "Quản lý tập tin",
            "Quản lý tiến trình và tài nguyên hệ thống",
            "Chỉnh sửa văn bản",
            "Thiết lập mạng"
          ],
          "correctAnswer": "Quản lý tiến trình và tài nguyên hệ thống",
          "reason": "Task Manager trong Windows được sử dụng để quản lý các tiến trình đang chạy và theo dõi tài nguyên hệ thống như CPU, bộ nhớ."
        },
        {
          "id": 13,
          "question": "Trong Linux, lệnh nào được sử dụng để thay đổi quyền truy cập của tệp?",
          "options": ["chmod", "chown", "chgrp", "chperm"],
          "correctAnswer": "chmod",
          "reason": "Lệnh `chmod` được sử dụng để thay đổi quyền truy cập của tệp trong Linux."
        },
        {
          "id": 14,
          "question": "Trong hệ điều hành, virtual memory là gì?",
          "options": [
            "Bộ nhớ vật lý của máy tính",
            "Bộ nhớ bổ sung bằng đĩa cứng được sử dụng khi RAM đầy",
            "Bộ nhớ được chia sẻ giữa các tiến trình",
            "Bộ nhớ nhanh hơn RAM"
          ],
          "correctAnswer": "Bộ nhớ bổ sung bằng đĩa cứng được sử dụng khi RAM đầy",
          "reason": "Virtual memory là một kỹ thuật sử dụng bộ nhớ bổ sung bằng đĩa cứng để mở rộng không gian bộ nhớ khi RAM đầy."
        },
        {
          "id": 15,
          "question": "Hệ điều hành nào sau đây không phải là hệ điều hành Unix-based?",
          "options": ["Linux", "macOS", "Windows", "FreeBSD"],
          "correctAnswer": "Windows",
          "reason": "Windows không phải là hệ điều hành Unix-based, trong khi Linux, macOS và FreeBSD đều dựa trên Unix."
        },
        {
          "id": 16,
          "question": "Trong hệ điều hành, shell là gì?",
          "options": [
            "Giao diện người dùng để tương tác với hệ thống",
            "Một loại bộ nhớ",
            "Một loại tệp hệ thống",
            "Một công cụ quản lý tiến trình"
          ],
          "correctAnswer": "Giao diện người dùng để tương tác với hệ thống",
          "reason": "Shell là giao diện người dùng cho phép người dùng tương tác với hệ thống thông qua dòng lệnh hoặc giao diện đồ họa."
        },
        {
          "id": 17,
          "question": "Trong hệ điều hành, process scheduling là gì?",
          "options": [
            "Quản lý bộ nhớ",
            "Quản lý các tiến trình và quyết định tiến trình nào sẽ được thực hiện tiếp theo",
            "Quản lý thiết bị ngoại vi",
            "Quản lý tệp hệ thống"
          ],
          "correctAnswer": "Quản lý các tiến trình và quyết định tiến trình nào sẽ được thực hiện tiếp theo",
          "reason": "Process scheduling liên quan đến việc quản lý các tiến trình và quyết định tiến trình nào sẽ được CPU thực hiện tiếp theo."
        },
        {
          "id": 18,
          "question": "Trong Linux, lệnh nào được sử dụng để sao chép tệp hoặc thư mục?",
          "options": ["cp", "mv", "rm", "mkdir"],
          "correctAnswer": "cp",
          "reason": "Lệnh `cp` trong Linux được sử dụng để sao chép tệp hoặc thư mục."
        },
        {
          "id": 19,
          "question": "Trong hệ điều hành, thuật ngữ 'context switch' đề cập đến gì?",
          "options": [
            "Chuyển đổi giữa các tiến trình khác nhau",
            "Chuyển đổi giữa các người dùng khác nhau",
            "Chuyển đổi giữa các tệp khác nhau",
            "Chuyển đổi giữa các thiết bị khác nhau"
          ],
          "correctAnswer": "Chuyển đổi giữa các tiến trình khác nhau",
          "reason": "Context switch là quá trình chuyển đổi CPU từ một tiến trình này sang tiến trình khác, bao gồm lưu trữ và tải lại trạng thái tiến trình."
        },
        {
          "id": 20,
          "question": "Hệ điều hành nào sau đây là hệ điều hành di động của Google?",
          "options": ["iOS", "Windows Phone", "Android", "BlackBerry OS"],
          "correctAnswer": "Android",
          "reason": "Android là hệ điều hành di động được phát triển bởi Google."
        },
        {
          "id": 21,
          "question": "Trong Windows, Registry là gì?",
          "options": [
            "Một loại tệp hệ thống",
            "Cơ sở dữ liệu lưu trữ cài đặt và tùy chọn cho hệ điều hành và ứng dụng",
            "Một công cụ quản lý tiến trình",
            "Một loại bộ nhớ"
          ],
          "correctAnswer": "Cơ sở dữ liệu lưu trữ cài đặt và tùy chọn cho hệ điều hành và ứng dụng",
          "reason": "Registry trong Windows là một cơ sở dữ liệu lưu trữ cài đặt và tùy chọn cho hệ điều hành và các ứng dụng."
        },
        {
          "id": 22,
          "question": "Trong Linux, lệnh nào được sử dụng để thay đổi thư mục hiện tại?",
          "options": ["cd", "ls", "pwd", "mkdir"],
          "correctAnswer": "cd",
          "reason": "Lệnh `cd` được sử dụng để thay đổi thư mục hiện tại trong Linux."
        },
        {
          "id": 23,
          "question": "Trong hệ điều hành, từ khóa nào được sử dụng để bắt đầu một tiến trình mới?",
          "options": ["start", "run", "execute", "fork"],
          "correctAnswer": "fork",
          "reason": "Trong Unix-based systems, `fork` là một hệ thống gọi được sử dụng để bắt đầu một tiến trình mới bằng cách tạo một bản sao của tiến trình hiện tại."
        },
        {
          "id": 24,
          "question": "Trong hệ điều hành, phương pháp nào được sử dụng để phân bổ CPU cho các tiến trình?",
          "options": [
            "Memory Management",
            "Process Scheduling",
            "File Management",
            "Device Management"
          ],
          "correctAnswer": "Process Scheduling",
          "reason": "Process Scheduling được sử dụng để phân bổ CPU cho các tiến trình, quyết định tiến trình nào sẽ được thực hiện tiếp theo."
        },
        {
          "id": 25,
          "question": "Trong Linux, lệnh nào được sử dụng để xóa một tệp?",
          "options": ["rm", "del", "erase", "delete"],
          "correctAnswer": "rm",
          "reason": "Lệnh `rm` trong Linux được sử dụng để xóa một tệp hoặc thư mục."
        },
        {
          "id": 26,
          "question": "Trong hệ điều hành, thuật ngữ 'paging' đề cập đến gì?",
          "options": [
            "Phân chia bộ nhớ thành các trang nhỏ",
            "Chuyển đổi giữa các tiến trình",
            "Quản lý tệp hệ thống",
            "Xử lý các yêu cầu thiết bị ngoại vi"
          ],
          "correctAnswer": "Phân chia bộ nhớ thành các trang nhỏ",
          "reason": "Paging là kỹ thuật phân chia bộ nhớ thành các trang nhỏ để quản lý và ảo hóa bộ nhớ hiệu quả hơn."
        },
        {
          "id": 27,
          "question": "Trong Windows, công cụ nào được sử dụng để kiểm tra và sửa chữa tệp hệ thống?",
          "options": ["chkdsk", "format", "diskpart", "defrag"],
          "correctAnswer": "chkdsk",
          "reason": "Công cụ `chkdsk` được sử dụng để kiểm tra và sửa chữa các lỗi trong hệ thống tập tin của Windows."
        },
        {
          "id": 28,
          "question": "Trong hệ điều hành, buffer overflow xảy ra khi nào?",
          "options": [
            "Khi bộ nhớ đầy",
            "Khi quá trình không thể tiếp tục",
            "Khi dữ liệu vượt quá kích thước của bộ đệm",
            "Khi không đủ tài nguyên hệ thống"
          ],
          "correctAnswer": "Khi dữ liệu vượt quá kích thước của bộ đệm",
          "reason": "Buffer overflow xảy ra khi dữ liệu được nhập vào vượt quá kích thước của bộ đệm, có thể gây ra lỗi hoặc lỗ hổng bảo mật."
        },
        {
          "id": 29,
          "question": "Trong Linux, lệnh nào được sử dụng để hiển thị đường dẫn thư mục hiện tại?",
          "options": ["cd", "ls", "pwd", "mkdir"],
          "correctAnswer": "pwd",
          "reason": "Lệnh `pwd` (print working directory) được sử dụng để hiển thị đường dẫn thư mục hiện tại trong Linux."
        },
        {
          "id": 30,
          "question": "Trong hệ điều hành, thuật ngữ 'multithreading' đề cập đến gì?",
          "options": [
            "Chạy nhiều tiến trình cùng một lúc",
            "Chạy nhiều luồng trong một tiến trình",
            "Chạy nhiều người dùng cùng một lúc",
            "Chạy nhiều chương trình khác nhau"
          ],
          "correctAnswer": "Chạy nhiều luồng trong một tiến trình",
          "reason": "Multithreading đề cập đến việc chạy nhiều luồng (threads) trong cùng một tiến trình để tăng hiệu suất và khả năng phản hồi."
        },
        {
          "id": 31,
          "question": "Trong hệ điều hành, từ khóa nào được sử dụng để hiển thị danh sách các tệp trong thư mục hiện tại trong Linux?",
          "options": ["ls", "dir", "list", "show"],
          "correctAnswer": "ls",
          "reason": "Lệnh `ls` được sử dụng trong Linux để hiển thị danh sách các tệp và thư mục trong thư mục hiện tại."
        },
        {
          "id": 32,
          "question": "Trong hệ điều hành, 'virtual memory' cho phép gì?",
          "options": [
            "Tăng bộ nhớ vật lý",
            "Sử dụng bộ nhớ đĩa cứng như bộ nhớ RAM",
            "Giảm bộ nhớ RAM",
            "Không có lợi ích gì"
          ],
          "correctAnswer": "Sử dụng bộ nhớ đĩa cứng như bộ nhớ RAM",
          "reason": "Virtual memory cho phép hệ điều hành sử dụng bộ nhớ đĩa cứng như bộ nhớ RAM để mở rộng không gian bộ nhớ khi RAM đầy."
        },
        {
          "id": 33,
          "question": "Trong Windows, công cụ nào được sử dụng để quản lý các tiến trình và ứng dụng đang chạy?",
          "options": [
            "Task Manager",
            "Control Panel",
            "Command Prompt",
            "File Explorer"
          ],
          "correctAnswer": "Task Manager",
          "reason": "Task Manager trong Windows được sử dụng để quản lý và theo dõi các tiến trình và ứng dụng đang chạy."
        },
        {
          "id": 34,
          "question": "Trong hệ điều hành, từ khóa nào được sử dụng để phân quyền truy cập cho người dùng?",
          "options": ["chmod", "chown", "chgrp", "All of the above"],
          "correctAnswer": "All of the above",
          "reason": "Trong Linux, `chmod`, `chown`, và `chgrp` đều được sử dụng để phân quyền truy cập và sở hữu cho người dùng và nhóm."
        },
        {
          "id": 35,
          "question": "Trong hệ điều hành, lệnh nào được sử dụng để chuyển đổi thư mục trong Linux?",
          "options": ["cd", "ls", "pwd", "mkdir"],
          "correctAnswer": "cd",
          "reason": "Lệnh `cd` được sử dụng để chuyển đổi thư mục hiện tại trong Linux."
        },
        {
          "id": 36,
          "question": "Trong hệ điều hành, 'context switch' là gì?",
          "options": [
            "Chuyển đổi giữa các tiến trình khác nhau",
            "Chuyển đổi giữa các thư mục",
            "Chuyển đổi giữa các người dùng",
            "Chuyển đổi giữa các tệp"
          ],
          "correctAnswer": "Chuyển đổi giữa các tiến trình khác nhau",
          "reason": "Context switch là quá trình chuyển đổi CPU từ một tiến trình này sang tiến trình khác, bao gồm lưu trữ và tải lại trạng thái tiến trình."
        },
        {
          "id": 37,
          "question": "Trong hệ điều hành Linux, lệnh nào được sử dụng để xóa một thư mục?",
          "options": ["rm", "rmdir", "del", "erase"],
          "correctAnswer": "rmdir",
          "reason": "Lệnh `rmdir` được sử dụng để xóa một thư mục trong Linux. Nếu thư mục không trống, bạn có thể sử dụng `rm -r`."
        },
        {
          "id": 38,
          "question": "Trong hệ điều hành, từ khóa nào được sử dụng để kiểm tra thông tin về hệ thống trong Linux?",
          "options": ["uname", "systeminfo", "info", "sysinfo"],
          "correctAnswer": "uname",
          "reason": "Lệnh `uname` được sử dụng để kiểm tra thông tin về hệ thống trong Linux."
        },
        {
          "id": 39,
          "question": "Trong hệ điều hành, 'deadlock' xảy ra khi nào?",
          "options": [
            "Khi hệ thống ngừng hoạt động",
            "Khi các tiến trình chờ nhau và không thể tiếp tục",
            "Khi bộ nhớ đầy",
            "Khi không có tiến trình nào đang chạy"
          ],
          "correctAnswer": "Khi các tiến trình chờ nhau và không thể tiếp tục",
          "reason": "Deadlock xảy ra khi các tiến trình chờ nhau để giải phóng tài nguyên và không thể tiếp tục thực hiện."
        },
        {
          "id": 40,
          "question": "Trong Linux, lệnh nào được sử dụng để xem đường dẫn thư mục hiện tại?",
          "options": ["pwd", "cd", "ls", "dir"],
          "correctAnswer": "pwd",
          "reason": "Lệnh `pwd` (print working directory) được sử dụng để hiển thị đường dẫn thư mục hiện tại trong Linux."
        },
        {
          "id": 41,
          "question": "Trong hệ điều hành, 'multithreading' đề cập đến gì?",
          "options": [
            "Chạy nhiều tiến trình cùng một lúc",
            "Chạy nhiều luồng trong một tiến trình",
            "Chạy nhiều người dùng cùng một lúc",
            "Chạy nhiều chương trình khác nhau"
          ],
          "correctAnswer": "Chạy nhiều luồng trong một tiến trình",
          "reason": "Multithreading đề cập đến việc chạy nhiều luồng (threads) trong cùng một tiến trình để tăng hiệu suất và khả năng phản hồi."
        },
        {
          "id": 42,
          "question": "Trong hệ điều hành Windows, Registry là gì?",
          "options": [
            "Một loại tệp hệ thống",
            "Cơ sở dữ liệu lưu trữ cài đặt và tùy chọn cho hệ điều hành và ứng dụng",
            "Một công cụ quản lý tiến trình",
            "Một loại bộ nhớ"
          ],
          "correctAnswer": "Cơ sở dữ liệu lưu trữ cài đặt và tùy chọn cho hệ điều hành và ứng dụng",
          "reason": "Registry trong Windows là một cơ sở dữ liệu lưu trữ cài đặt và tùy chọn cho hệ điều hành và các ứng dụng."
        },
        {
          "id": 43,
          "question": "Trong hệ điều hành, từ khóa nào được sử dụng để thay đổi quyền truy cập của tệp trong Linux?",
          "options": ["chmod", "chown", "chgrp", "All of the above"],
          "correctAnswer": "chmod",
          "reason": "Lệnh `chmod` được sử dụng để thay đổi quyền truy cập của tệp trong Linux."
        },
        {
          "id": 44,
          "question": "Trong hệ điều hành, từ khóa nào được sử dụng để tạo một tiến trình mới trong Unix?",
          "options": ["fork()", "exec()", "spawn()", "create()"],
          "correctAnswer": "fork()",
          "reason": "Trong Unix, `fork()` được sử dụng để tạo một tiến trình mới bằng cách sao chép tiến trình hiện tại."
        },
        {
          "id": 45,
          "question": "Trong hệ điều hành, 'paging' là gì?",
          "options": [
            "Phân chia bộ nhớ thành các trang nhỏ",
            "Chuyển đổi giữa các tiến trình",
            "Quản lý tệp hệ thống",
            "Xử lý các yêu cầu thiết bị ngoại vi"
          ],
          "correctAnswer": "Phân chia bộ nhớ thành các trang nhỏ",
          "reason": "Paging là kỹ thuật phân chia bộ nhớ thành các trang nhỏ để quản lý và ảo hóa bộ nhớ hiệu quả hơn."
        },
        {
          "id": 46,
          "question": "Trong hệ điều hành Linux, lệnh nào được sử dụng để tạo một thư mục mới?",
          "options": ["mkdir", "rmdir", "touch", "cp"],
          "correctAnswer": "mkdir",
          "reason": "Lệnh `mkdir` được sử dụng để tạo một thư mục mới trong Linux."
        },
        {
          "id": 47,
          "question": "Trong hệ điều hành, 'inter-process communication (IPC)' đề cập đến gì?",
          "options": [
            "Giao tiếp giữa các tiến trình khác nhau",
            "Giao tiếp giữa người dùng và hệ thống",
            "Giao tiếp giữa các tệp tin",
            "Giao tiếp giữa các thiết bị ngoại vi"
          ],
          "correctAnswer": "Giao tiếp giữa các tiến trình khác nhau",
          "reason": "IPC là phương thức giao tiếp giữa các tiến trình khác nhau để trao đổi dữ liệu và đồng bộ hóa hoạt động."
        },
        {
          "id": 48,
          "question": "Trong hệ điều hành, 'buffer overflow' xảy ra khi nào?",
          "options": [
            "Khi bộ nhớ đầy",
            "Khi dữ liệu vượt quá kích thước của bộ đệm",
            "Khi không đủ tài nguyên hệ thống",
            "Khi không có tiến trình nào đang chạy"
          ],
          "correctAnswer": "Khi dữ liệu vượt quá kích thước của bộ đệm",
          "reason": "Buffer overflow xảy ra khi dữ liệu được nhập vào vượt quá kích thước của bộ đệm, có thể gây ra lỗi hoặc lỗ hổng bảo mật."
        },
        {
          "id": 49,
          "question": "Trong hệ điều hành, từ khóa nào được sử dụng để kiểm tra các tiến trình đang chạy trong Windows?",
          "options": ["tasklist", "ps", "top", "processes"],
          "correctAnswer": "tasklist",
          "reason": "Lệnh `tasklist` được sử dụng trong Windows để liệt kê các tiến trình đang chạy."
        },
        {
          "id": 50,
          "question": "Trong hệ điều hành, 'swap space' là gì?",
          "options": [
            "Bộ nhớ RAM bổ sung",
            "Bộ nhớ đĩa cứng được sử dụng để lưu trữ tạm thời dữ liệu khi RAM đầy",
            "Bộ nhớ cache",
            "Bộ nhớ ROM"
          ],
          "correctAnswer": "Bộ nhớ đĩa cứng được sử dụng để lưu trữ tạm thời dữ liệu khi RAM đầy",
          "reason": "Swap space là một khu vực trên đĩa cứng được sử dụng để lưu trữ tạm thời dữ liệu khi RAM đầy, giúp hệ thống tiếp tục hoạt động mà không bị gián đoạn."
        }
      ]
    },
    {
      "id": 15,
      "title": "Computer Networks & OOP Mega Quiz",
      "timeLimit": 3600,
      "questions": [
        {
          "id": 1,
          "question": "Tầng nào trong mô hình OSI chịu trách nhiệm định tuyến gói tin?",
          "options": [
            "Tầng Vận chuyển (Transport)",
            "Tầng Mạng (Network)",
            "Tầng Liên kết Dữ liệu (Data Link)",
            "Tầng Vật lý (Physical)"
          ],
          "correctAnswer": "Tầng Mạng (Network)",
          "reason": "Việc định tuyến (routing) được thực hiện ở tầng 3 - Network."
        },
        {
          "id": 2,
          "question": "Thiết bị nào hoạt động ở tầng Liên kết Dữ liệu (Data Link) trong mô hình OSI?",
          "options": ["Router", "Switch", "Hub", "Gateway"],
          "correctAnswer": "Switch",
          "reason": "Switch hoạt động ở tầng 2 của mô hình OSI, dựa vào địa chỉ MAC."
        },
        {
          "id": 3,
          "question": "Địa chỉ IP phiên bản 4 có độ dài bao nhiêu bit?",
          "options": ["16 bit", "32 bit", "64 bit", "128 bit"],
          "correctAnswer": "32 bit",
          "reason": "IPv4 sử dụng địa chỉ 32 bit, thường biểu diễn dưới dạng thập phân dấu chấm (dot-decimal)."
        },
        {
          "id": 4,
          "question": "Cơ chế nào được sử dụng để tránh xung đột trên mạng Ethernet truyền thống (IEEE 802.3)?",
          "options": ["CSMA/CA", "CSMA/CD", "Token Passing", "Slotted ALOHA"],
          "correctAnswer": "CSMA/CD",
          "reason": "Ethernet (802.3) sử dụng cơ chế CSMA/CD để phát hiện và xử lý xung đột."
        },
        {
          "id": 5,
          "question": "Công cụ nào dùng để kiểm tra kết nối và độ trễ giữa hai thiết bị trong mạng?",
          "options": ["ipconfig", "ping", "nslookup", "traceroute"],
          "correctAnswer": "ping",
          "reason": "Lệnh ping gửi gói ICMP Echo Request để kiểm tra tính sẵn sàng và độ trễ."
        },
        {
          "id": 6,
          "question": "DNS (Domain Name System) có chức năng chính nào?",
          "options": [
            "Chuyển địa chỉ MAC thành IP",
            "Chuyển địa chỉ IP thành tên miền",
            "Chuyển tên miền thành địa chỉ IP",
            "Định tuyến gói tin qua mạng"
          ],
          "correctAnswer": "Chuyển tên miền thành địa chỉ IP",
          "reason": "DNS chịu trách nhiệm phân giải tên miền (domain) sang địa chỉ IP tương ứng."
        },
        {
          "id": 7,
          "question": "Cổng mặc định của giao thức HTTP là gì?",
          "options": ["443", "25", "80", "53"],
          "correctAnswer": "80",
          "reason": "HTTP mặc định sử dụng cổng 80 (TCP)."
        },
        {
          "id": 8,
          "question": "Thiết bị nào hoạt động ở tầng 3 (Network) của mô hình OSI?",
          "options": ["Switch", "Router", "Hub", "Repeater"],
          "correctAnswer": "Router",
          "reason": "Router hoạt động ở tầng 3, sử dụng địa chỉ IP để định tuyến dữ liệu."
        },
        {
          "id": 9,
          "question": "Giao thức nào hỗ trợ truyền dữ liệu phi kết nối, không đảm bảo, thường dùng cho streaming?",
          "options": ["TCP", "UDP", "HTTP", "ICMP"],
          "correctAnswer": "UDP",
          "reason": "UDP (User Datagram Protocol) là giao thức phi kết nối, không đảm bảo, tốc độ cao."
        },
        {
          "id": 10,
          "question": "Protocol nào trong mô hình TCP/IP chịu trách nhiệm chuyển tiếp gói tin và đánh địa chỉ?",
          "options": ["TCP", "IP", "HTTP", "SSH"],
          "correctAnswer": "IP",
          "reason": "IP (Internet Protocol) đảm nhiệm định tuyến (routing) và đánh địa chỉ ở tầng Internet."
        },
        {
          "id": 11,
          "question": "Giao thức nào thường dùng để gửi mail từ client lên mail server?",
          "options": ["SMTP", "POP3", "IMAP", "HTTP"],
          "correctAnswer": "SMTP",
          "reason": "SMTP (Simple Mail Transfer Protocol) dùng để gửi email từ client lên server."
        },
        {
          "id": 12,
          "question": "Kỹ thuật NAT (Network Address Translation) dùng để làm gì?",
          "options": [
            "Cấp phát IP động cho client",
            "Phân giải DNS",
            "Chuyển địa chỉ IP private thành IP public",
            "Kiểm tra lỗi gói tin"
          ],
          "correctAnswer": "Chuyển địa chỉ IP private thành IP public",
          "reason": "NAT cho phép nhiều máy trong mạng LAN dùng chung một địa chỉ IP công cộng."
        },
        {
          "id": 13,
          "question": "Khái niệm subnet mask dùng để xác định điều gì?",
          "options": [
            "Phần địa chỉ mạng và phần địa chỉ host",
            "Phần địa chỉ MAC và IP",
            "Phần DNS và Gateway",
            "Độ dài gói tin"
          ],
          "correctAnswer": "Phần địa chỉ mạng và phần địa chỉ host",
          "reason": "Subnet mask chia địa chỉ IP thành hai phần: network và host."
        },
        {
          "id": 14,
          "question": "Cơ chế an ninh nào thường được dùng cho mạng Wi-Fi hiện đại?",
          "options": ["WEP", "WPA2/WPA3", "CSMA/CA", "CHAP"],
          "correctAnswer": "WPA2/WPA3",
          "reason": "WPA2 và WPA3 là các chuẩn mã hóa an toàn cho mạng Wi-Fi thay thế WEP cũ."
        },
        {
          "id": 15,
          "question": "Mục đích của VLAN (Virtual LAN) trong mạng LAN là gì?",
          "options": [
            "Kết nối mạng WAN với LAN",
            "Chia miền quảng bá và tăng bảo mật",
            "Cấp phát IP động cho máy trạm",
            "Tối ưu hóa tốc độ Wi-Fi"
          ],
          "correctAnswer": "Chia miền quảng bá và tăng bảo mật",
          "reason": "VLAN giúp chia nhỏ mạng logic, giảm broadcast domain và tăng cường bảo mật."
        },
        {
          "id": 16,
          "question": "Trong định tuyến động, giao thức OSPF thuộc nhóm nào?",
          "options": [
            "EGP",
            "IGP dạng link-state",
            "IGP dạng distance-vector",
            "Không thuộc nhóm nào"
          ],
          "correctAnswer": "IGP dạng link-state",
          "reason": "OSPF là IGP dựa trên thuật toán link-state (mở rộng Dijkstra)."
        },
        {
          "id": 17,
          "question": "Công cụ nào giúp theo dõi đường đi của gói tin qua các router trung gian?",
          "options": [
            "ping",
            "netstat",
            "traceroute (hoặc tracert)",
            "ipconfig"
          ],
          "correctAnswer": "traceroute (hoặc tracert)",
          "reason": "Traceroute (Linux) hoặc tracert (Windows) hiển thị các nút (router) trên đường đi gói tin."
        },
        {
          "id": 18,
          "question": "Giao thức nào chuyên dùng để phân giải địa chỉ IP sang địa chỉ MAC trong cùng mạng LAN?",
          "options": ["DNS", "ARP", "RARP", "ICMP"],
          "correctAnswer": "ARP",
          "reason": "ARP (Address Resolution Protocol) ánh xạ IP thành MAC trong cùng subnet."
        },
        {
          "id": 19,
          "question": "Trong IPv4, địa chỉ 127.0.0.1 được dùng cho mục đích gì?",
          "options": ["Broadcast", "Loopback", "Multicast", "Reserved"],
          "correctAnswer": "Loopback",
          "reason": "127.0.0.1 là địa chỉ loopback (localhost) dùng để kiểm tra chính máy cục bộ."
        },
        {
          "id": 20,
          "question": "Giao thức ICMP thường được sử dụng cho công cụ nào?",
          "options": ["ping", "telnet", "ssh", "ftp"],
          "correctAnswer": "ping",
          "reason": "Ping gửi ICMP Echo Request để kiểm tra kết nối giữa hai host."
        },
        {
          "id": 21,
          "question": "IPv6 có độ dài địa chỉ là bao nhiêu bit?",
          "options": ["32 bit", "64 bit", "128 bit", "256 bit"],
          "correctAnswer": "128 bit",
          "reason": "IPv6 sử dụng địa chỉ 128 bit, biểu diễn dạng hex."
        },
        {
          "id": 22,
          "question": "Trong mô hình TCP/IP, tầng Internet tương ứng với tầng nào trong mô hình OSI?",
          "options": [
            "Tầng 2 (Data Link)",
            "Tầng 3 (Network)",
            "Tầng 4 (Transport)",
            "Tầng 5 (Session)"
          ],
          "correctAnswer": "Tầng 3 (Network)",
          "reason": "Tầng Internet của TCP/IP tương ứng Network layer (tầng 3) trong OSI."
        },
        {
          "id": 23,
          "question": "Giao thức nào không yêu cầu phiên kết nối và không đảm bảo dữ liệu đến nơi?",
          "options": ["TCP", "UDP", "FTP", "RDP"],
          "correctAnswer": "UDP",
          "reason": "UDP là giao thức không kết nối, không cung cấp cơ chế đảm bảo chuyển giao."
        },
        {
          "id": 24,
          "question": "SMTP thường sử dụng cổng nào để gửi email?",
          "options": ["25", "53", "110", "443"],
          "correctAnswer": "25",
          "reason": "Cổng mặc định của SMTP là 25 (hoặc 587 khi dùng bảo mật)."
        },
        {
          "id": 25,
          "question": "DHCP (Dynamic Host Configuration Protocol) cung cấp thông tin nào cho client?",
          "options": [
            "IP, Subnet mask, Gateway, DNS",
            "MAC address",
            "Chứng chỉ SSL/TLS",
            "Tài khoản người dùng"
          ],
          "correctAnswer": "IP, Subnet mask, Gateway, DNS",
          "reason": "DHCP cung cấp động các thông tin cấu hình mạng cho thiết bị."
        },
        {
          "id": 26,
          "question": "Trong kỹ thuật NAT, kiểu nào cho phép nhiều máy cục bộ chia sẻ một IP public thông qua phân biệt cổng?",
          "options": [
            "Static NAT",
            "Dynamic NAT",
            "PAT (NAT overload)",
            "NAT 1-1"
          ],
          "correctAnswer": "PAT (NAT overload)",
          "reason": "PAT (Port Address Translation) ánh xạ nhiều IP private đến một IP public dựa trên cổng."
        },
        {
          "id": 27,
          "question": "VPN (Virtual Private Network) được dùng để làm gì?",
          "options": [
            "Tăng tốc độ mạng LAN",
            "Tạo đường hầm mã hóa giữa hai mạng/thiết bị",
            "Thay thế giao thức HTTP",
            "Kiểm soát xung đột trên kênh truyền"
          ],
          "correctAnswer": "Tạo đường hầm mã hóa giữa hai mạng/thiết bị",
          "reason": "VPN mã hóa dữ liệu, giúp kết nối an toàn qua mạng công cộng."
        },
        {
          "id": 28,
          "question": "Giao thức FTP mặc định sử dụng cổng nào để điều khiển (control)?",
          "options": ["21", "22", "20", "25"],
          "correctAnswer": "21",
          "reason": "FTP dùng cổng 21 cho kênh điều khiển và cổng 20 cho kênh dữ liệu."
        },
        {
          "id": 29,
          "question": "Trong phân lớp địa chỉ IPv4, Class C có phần Network dài bao nhiêu bit?",
          "options": ["8 bit", "16 bit", "24 bit", "32 bit"],
          "correctAnswer": "24 bit",
          "reason": "Class C thường có cấu trúc N.N.N.H (3 byte mạng, 1 byte host)."
        },
        {
          "id": 30,
          "question": "Khi Switch nhận frame, nó dựa vào thông tin nào để chuyển tiếp đến cổng đích?",
          "options": [
            "Địa chỉ IP đích",
            "Địa chỉ MAC đích",
            "Địa chỉ MAC nguồn",
            "Địa chỉ IP nguồn"
          ],
          "correctAnswer": "Địa chỉ MAC đích",
          "reason": "Switch hoạt động ở tầng 2, dùng bảng MAC để quyết định chuyển frame."
        },
        {
          "id": 31,
          "question": "Giao thức nào thuộc nhóm định tuyến động (dynamic routing) dạng distance-vector?",
          "options": ["OSPF", "RIP", "BGP", "ICMP"],
          "correctAnswer": "RIP",
          "reason": "RIP (Routing Information Protocol) sử dụng thuật toán distance-vector."
        },
        {
          "id": 32,
          "question": "Trong bảng định tuyến, thông tin Next Hop dùng để chỉ điều gì?",
          "options": [
            "Địa chỉ MAC kế tiếp",
            "Địa chỉ lớp ứng dụng",
            "Router kế tiếp trên đường đến mạng đích",
            "Lệnh cần thực thi tiếp theo"
          ],
          "correctAnswer": "Router kế tiếp trên đường đến mạng đích",
          "reason": "Next Hop là địa chỉ router tiếp theo gói tin sẽ đi qua."
        },
        {
          "id": 33,
          "question": "Tầng Vật lý (Physical) trong OSI đề cập đến điều gì?",
          "options": [
            "Gói tin (packet)",
            "Tín hiệu điện/quang và phương tiện truyền dẫn",
            "Địa chỉ IP",
            "Truyền file"
          ],
          "correctAnswer": "Tín hiệu điện/quang và phương tiện truyền dẫn",
          "reason": "Tầng Physical liên quan đến cáp, tín hiệu, đầu nối, chuẩn vật lý."
        },
        {
          "id": 34,
          "question": "Thiết bị nào hoạt động ở tầng Physical và chỉ khuếch đại tín hiệu?",
          "options": ["Hub", "Switch", "Router", "Bridge"],
          "correctAnswer": "Hub",
          "reason": "Hub hoạt động ở tầng 1, phát lại tín hiệu đến tất cả cổng."
        },
        {
          "id": 35,
          "question": "Mục đích của DMZ (Demilitarized Zone) trong bảo mật mạng là gì?",
          "options": [
            "Chia VLAN nội bộ",
            "Khu vực tách biệt để đặt server public",
            "Tăng tốc độ routing",
            "Mã hóa dữ liệu giữa hai mạng"
          ],
          "correctAnswer": "Khu vực tách biệt để đặt server public",
          "reason": "DMZ là khu vực chứa các server công khai, tách khỏi mạng nội bộ để giảm rủi ro."
        },
        {
          "id": 36,
          "question": "BGP (Border Gateway Protocol) thuộc nhóm giao thức định tuyến nào?",
          "options": [
            "IGP (Interior Gateway Protocol)",
            "EGP (Exterior Gateway Protocol)",
            "Distance-Vector",
            "Link-State"
          ],
          "correctAnswer": "EGP (Exterior Gateway Protocol)",
          "reason": "BGP là giao thức định tuyến giữa các hệ thống tự trị (AS) trên Internet."
        },
        {
          "id": 37,
          "question": "Chuẩn Wi-Fi IEEE 802.11 nào hỗ trợ tốc độ lên đến 54 Mbps ở băng tần 5 GHz?",
          "options": ["802.11b", "802.11g", "802.11a", "802.11n"],
          "correctAnswer": "802.11a",
          "reason": "802.11a hoạt động băng tần 5 GHz, tốc độ 54 Mbps."
        },
        {
          "id": 38,
          "question": "WAN (Wide Area Network) thường kết nối các mạng LAN ở phạm vi nào?",
          "options": [
            "Phạm vi phòng làm việc",
            "Phạm vi tòa nhà",
            "Phạm vi đô thị",
            "Phạm vi toàn quốc hoặc quốc tế"
          ],
          "correctAnswer": "Phạm vi toàn quốc hoặc quốc tế",
          "reason": "WAN kết nối địa lý rộng lớn, ví dụ kết nối liên tỉnh, liên quốc gia."
        },
        {
          "id": 39,
          "question": "Proxy Server thường dùng để làm gì?",
          "options": [
            "Định tuyến gói tin giữa các mạng",
            "Lưu và trung chuyển yêu cầu web để tiết kiệm băng thông",
            "Chia mạng LAN thành nhiều subnet",
            "Thay thế địa chỉ IP từ IPv4 sang IPv6"
          ],
          "correctAnswer": "Lưu và trung chuyển yêu cầu web để tiết kiệm băng thông",
          "reason": "Proxy Server có thể cache dữ liệu, kiểm soát truy cập, ẩn IP client."
        },
        {
          "id": 40,
          "question": "Công cụ netstat dùng để làm gì?",
          "options": [
            "Kiểm tra kết nối, cổng mở và thống kê giao thức",
            "Phân giải tên miền",
            "Theo dõi đường đi gói tin",
            "Cấu hình IP động"
          ],
          "correctAnswer": "Kiểm tra kết nối, cổng mở và thống kê giao thức",
          "reason": "netstat hiển thị trạng thái kết nối, port đang lắng nghe, thống kê giao thức."
        },
        {
          "id": 41,
          "question": "Giao thức nào dùng để truyền tệp tin với chế độ bảo mật cao, thay thế cho FTP?",
          "options": [
            "SFTP (SSH File Transfer Protocol)",
            "SNMP",
            "SCP (Secure Copy)",
            "HTTP"
          ],
          "correctAnswer": "SFTP (SSH File Transfer Protocol)",
          "reason": "SFTP chạy trên SSH, cung cấp khả năng truyền file an toàn, mã hóa dữ liệu."
        },
        {
          "id": 42,
          "question": "Cơ chế QoS (Quality of Service) trong mạng dùng để làm gì?",
          "options": [
            "Quản lý băng thông, ưu tiên luồng dữ liệu quan trọng",
            "Bảo mật cho Wi-Fi",
            "Chia subnet trên router",
            "Phân giải địa chỉ IP"
          ],
          "correctAnswer": "Quản lý băng thông, ưu tiên luồng dữ liệu quan trọng",
          "reason": "QoS cho phép ưu tiên những gói tin quan trọng (voice, video) để giảm trễ, jitter."
        },
        {
          "id": 43,
          "question": "Trong OOP, lớp (class) là gì?",
          "options": [
            "Một thực thể cụ thể trong chương trình",
            "Khuôn mẫu mô tả thuộc tính và phương thức của đối tượng",
            "Một hàm khởi tạo",
            "Một hàm hủy"
          ],
          "correctAnswer": "Khuôn mẫu mô tả thuộc tính và phương thức của đối tượng",
          "reason": "Class là bản thiết kế (blueprint) để tạo ra các đối tượng."
        },
        {
          "id": 44,
          "question": "Đối tượng (object) trong OOP là gì?",
          "options": [
            "Là một biến toàn cục",
            "Là một instance được tạo ra từ lớp",
            "Là một phương thức trừu tượng",
            "Là một thuộc tính tĩnh (static)"
          ],
          "correctAnswer": "Là một instance được tạo ra từ lớp",
          "reason": "Đối tượng là thể hiện cụ thể của một lớp trong bộ nhớ."
        },
        {
          "id": 45,
          "question": "Phương thức (method) trong OOP là gì?",
          "options": [
            "Là biến toàn cục",
            "Là một hàm/hoạt động mà đối tượng có thể thực hiện",
            "Là một interface",
            "Là một gói tin trong mạng"
          ],
          "correctAnswer": "Là một hàm/hoạt động mà đối tượng có thể thực hiện",
          "reason": "Method quy định hành vi (behavior) của đối tượng."
        },
        {
          "id": 46,
          "question": "Tính đóng gói (Encapsulation) trong OOP có ý nghĩa gì?",
          "options": [
            "Cho phép một lớp con kế thừa lớp cha",
            "Nhóm dữ liệu và phương thức trong cùng một đơn vị, hạn chế truy cập trực tiếp",
            "Cho phép nhiều phương thức cùng tên nhưng khác tham số",
            "Tạo giao diện chung cho nhiều lớp"
          ],
          "correctAnswer": "Nhóm dữ liệu và phương thức trong cùng một đơn vị, hạn chế truy cập trực tiếp",
          "reason": "Encapsulation giúp bảo vệ dữ liệu và che giấu triển khai bên trong."
        },
        {
          "id": 47,
          "question": "Tính kế thừa (Inheritance) trong OOP là gì?",
          "options": [
            "Khi một lớp con có thể sử dụng, bổ sung hoặc ghi đè tính năng từ lớp cha",
            "Khi có thể nạp chồng các phương thức cùng tên",
            "Khi dữ liệu được che giấu qua phạm vi truy cập",
            "Khi một lớp không thể tạo đối tượng"
          ],
          "correctAnswer": "Khi một lớp con có thể sử dụng, bổ sung hoặc ghi đè tính năng từ lớp cha",
          "reason": "Inheritance cho phép tái sử dụng mã, mở rộng chức năng thông qua lớp kế thừa."
        },
        {
          "id": 48,
          "question": "Tính đa hình (Polymorphism) trong OOP được thể hiện khi nào?",
          "options": [
            "Phương thức trừu tượng được định nghĩa ở nhiều lớp con",
            "Hai lớp có cùng tên",
            "Chỉ khi sử dụng interface",
            "Tránh xung đột dữ liệu"
          ],
          "correctAnswer": "Phương thức trừu tượng được định nghĩa ở nhiều lớp con",
          "reason": "Polymorphism: cùng tên phương thức nhưng triển khai khác nhau (override)."
        },
        {
          "id": 49,
          "question": "Tính trừu tượng (Abstraction) giúp gì trong OOP?",
          "options": [
            "Xác định rõ chi tiết triển khai nội bộ",
            "Ẩn đi những chi tiết không cần thiết, chỉ hiển thị đặc điểm chính",
            "Cho phép thay đổi kiểu dữ liệu động",
            "Tăng tốc độ thực thi chương trình"
          ],
          "correctAnswer": "Ẩn đi những chi tiết không cần thiết, chỉ hiển thị đặc điểm chính",
          "reason": "Abstraction tập trung vào những gì đối tượng làm, chứ không cần quan tâm chi tiết cách làm."
        },
        {
          "id": 50,
          "question": "Overloading (nạp chồng) là gì trong OOP?",
          "options": [
            "Khi một phương thức có thể gọi chính nó",
            "Khi hai lớp con ghi đè cùng phương thức từ lớp cha",
            "Khi có nhiều phương thức cùng tên nhưng khác tham số hoặc kiểu trả về",
            "Khi lớp con kế thừa lớp cha"
          ],
          "correctAnswer": "Khi có nhiều phương thức cùng tên nhưng khác tham số hoặc kiểu trả về",
          "reason": "Overloading cho phép cùng tên phương thức nhưng khác signature."
        },
        {
          "id": 51,
          "question": "Overriding (ghi đè) là gì trong OOP?",
          "options": [
            "Tạo nhiều phiên bản hàm khác tham số",
            "Thay đổi hoặc viết lại nội dung của phương thức lớp cha trong lớp con",
            "Ẩn thuộc tính của đối tượng",
            "Tạo lớp con từ nhiều lớp cha"
          ],
          "correctAnswer": "Thay đổi hoặc viết lại nội dung của phương thức lớp cha trong lớp con",
          "reason": "Overriding là tái định nghĩa phương thức để phù hợp lớp con."
        },
        {
          "id": 52,
          "question": "Constructor là gì?",
          "options": [
            "Một phương thức hủy đối tượng",
            "Phương thức đặc biệt để khởi tạo đối tượng",
            "Phương thức trừu tượng không có thân hàm",
            "Phương thức tĩnh không thể ghi đè"
          ],
          "correctAnswer": "Phương thức đặc biệt để khởi tạo đối tượng",
          "reason": "Constructor được gọi khi tạo object, dùng để gán giá trị ban đầu."
        },
        {
          "id": 53,
          "question": "Interface trong OOP thường chứa những thành phần nào?",
          "options": [
            "Thuộc tính private và phương thức static",
            "Các phương thức abstract (chưa có triển khai)",
            "Phương thức có sẵn phần triển khai",
            "Constructor và destructor"
          ],
          "correctAnswer": "Các phương thức abstract (chưa có triển khai)",
          "reason": "Interface chỉ định nghĩa 'cái gì' phải làm, không có phần triển khai."
        },
        {
          "id": 54,
          "question": "Abstract class khác Interface như thế nào?",
          "options": [
            "Abstract class không cho phép kế thừa, interface cho phép",
            "Interface có thể chứa thuộc tính bình thường, abstract class thì không",
            "Abstract class có thể chứa cả phương thức triển khai và phương thức abstract",
            "Interface không thể được implements"
          ],
          "correctAnswer": "Abstract class có thể chứa cả phương thức triển khai và phương thức abstract",
          "reason": "Abstract class cho phép một số phương thức có thân, interface thì chỉ có phương thức abstract (trong nhiều ngôn ngữ)."
        },
        {
          "id": 55,
          "question": "Tính năng nào của OOP đảm bảo lớp con có thể dùng, sửa đổi hoặc mở rộng những gì lớp cha đã có?",
          "options": ["Đa hình", "Kế thừa", "Đóng gói", "Trừu tượng"],
          "correctAnswer": "Kế thừa",
          "reason": "Inheritance cho phép lớp con kế thừa các thành viên (fields, methods) của lớp cha."
        },
        {
          "id": 56,
          "question": "Phạm vi truy cập (Access Modifier) nào chỉ cho phép truy cập trong cùng một class?",
          "options": ["public", "private", "protected", "internal"],
          "correctAnswer": "private",
          "reason": "private hạn chế truy cập chỉ trong nội bộ class đó."
        },
        {
          "id": 57,
          "question": "Từ khóa ‘this’ được sử dụng với mục đích gì trong OOP?",
          "options": [
            "Gọi hàm tạo của lớp cha",
            "Trỏ đến đối tượng hiện tại (instance hiện tại)",
            "Gọi phương thức tĩnh của lớp",
            "Khai báo biến cục bộ"
          ],
          "correctAnswer": "Trỏ đến đối tượng hiện tại (instance hiện tại)",
          "reason": "‘this’ đại diện cho đối tượng hiện đang được tham chiếu trong class."
        },
        {
          "id": 58,
          "question": "Tại sao nên sử dụng đóng gói (Encapsulation)?",
          "options": [
            "Để chia sẻ toàn bộ dữ liệu với bên ngoài",
            "Để ẩn dữ liệu và giảm phụ thuộc, tránh thay đổi ngoài ý muốn",
            "Để chạy chương trình nhanh hơn",
            "Để dễ dàng kế thừa"
          ],
          "correctAnswer": "Để ẩn dữ liệu và giảm phụ thuộc, tránh thay đổi ngoài ý muốn",
          "reason": "Encapsulation giúp ẩn dữ liệu, dùng setter/getter để kiểm soát truy cập."
        },
        {
          "id": 59,
          "question": "Trong đa hình (polymorphism), phương thức được quyết định gọi phiên bản nào vào thời điểm nào?",
          "options": [
            "Lúc biên dịch (compile time)",
            "Lúc chạy (runtime)",
            "Không xác định",
            "Khi cài đặt IDE"
          ],
          "correctAnswer": "Lúc chạy (runtime)",
          "reason": "Đa hình động (runtime polymorphism) quyết định phiên bản phương thức khi chương trình chạy."
        },
        {
          "id": 60,
          "question": "Đối tượng nào sau đây được gọi là “blueprint” trong OOP?",
          "options": ["Interface", "Class", "Object", "Constructor"],
          "correctAnswer": "Class",
          "reason": "Class là bản thiết kế (blueprint) để tạo các đối tượng cụ thể."
        },
        {
          "id": 61,
          "question": "Nguyên lý Single Responsibility (SOLID) quy định điều gì?",
          "options": [
            "Mỗi lớp chỉ nên có đúng một lý do để thay đổi",
            "Mỗi lớp có thể đảm nhiệm nhiều trách nhiệm khác nhau",
            "Mỗi phương thức chỉ nên có một tham số",
            "Không được kế thừa quá một lớp"
          ],
          "correctAnswer": "Mỗi lớp chỉ nên có đúng một lý do để thay đổi",
          "reason": "Single Responsibility: một lớp chỉ đảm nhận một trách nhiệm duy nhất."
        },
        {
          "id": 62,
          "question": "Interface Segregation Principle (ISP) gợi ý điều gì?",
          "options": [
            "Không nên dùng interface trong thiết kế",
            "Chia nhỏ interface lớn thành các interface chuyên biệt",
            "Dùng duy nhất một interface tổng quát",
            "Chỉ kế thừa từ một interface"
          ],
          "correctAnswer": "Chia nhỏ interface lớn thành các interface chuyên biệt",
          "reason": "ISP khuyến khích tạo nhiều interface nhỏ, tránh một interface cồng kềnh."
        },
        {
          "id": 63,
          "question": "Trong Java, một class có thể kế thừa bao nhiêu class cha?",
          "options": ["1", "2", "Không giới hạn", "Tùy thuộc phiên bản Java"],
          "correctAnswer": "1",
          "reason": "Java chỉ hỗ trợ single inheritance (một lớp cha)."
        },
        {
          "id": 64,
          "question": "Cụm từ “Composition over Inheritance” khuyến khích điều gì trong thiết kế OOP?",
          "options": [
            "Nên ưu tiên đa kế thừa thay vì dùng thuộc tính",
            "Nên ưu tiên gộp (has-a) thay vì kế thừa (is-a) khi thích hợp",
            "Nên bỏ qua nguyên tắc OOP",
            "Nên tạo thật nhiều lớp con để dễ mở rộng"
          ],
          "correctAnswer": "Nên ưu tiên gộp (has-a) thay vì kế thừa (is-a) khi thích hợp",
          "reason": "Nguyên tắc Composition over Inheritance giúp giảm phức tạp và ràng buộc giữa các lớp."
        },
        {
          "id": 65,
          "question": "Pattern nào đảm bảo chỉ có đúng một instance của một lớp được tạo trong suốt thời gian chạy?",
          "options": ["Factory", "Singleton", "Observer", "Adapter"],
          "correctAnswer": "Singleton",
          "reason": "Singleton Pattern giới hạn việc khởi tạo chỉ một đối tượng duy nhất."
        },
        {
          "id": 66,
          "question": "Trong mô hình MVC (Model-View-Controller), phần “Model” thường được hiểu là gì?",
          "options": [
            "Phần giao diện người dùng",
            "Phần xử lý logic điều hướng",
            "Phần đại diện dữ liệu, logic nghiệp vụ",
            "Phần cấu hình hệ thống"
          ],
          "correctAnswer": "Phần đại diện dữ liệu, logic nghiệp vụ",
          "reason": "Model đại diện trạng thái, nghiệp vụ dữ liệu; View là giao diện, Controller điều hướng."
        },
        {
          "id": 67,
          "question": "Trong Design Pattern, Factory Method nhằm mục đích gì?",
          "options": [
            "Tạo một lớp duy nhất trong hệ thống",
            "Đóng gói việc khởi tạo đối tượng, cho phép lớp con quyết định đối tượng nào sẽ được tạo",
            "Thông báo cho các đối tượng khi có sự kiện",
            "Tách biệt giao diện với phần triển khai"
          ],
          "correctAnswer": "Đóng gói việc khởi tạo đối tượng, cho phép lớp con quyết định đối tượng nào sẽ được tạo",
          "reason": "Factory Method cung cấp phương thức ảo để lớp con ghi đè, chỉ định đối tượng tạo ra."
        },
        {
          "id": 68,
          "question": "Pattern Observer giải quyết vấn đề gì?",
          "options": [
            "Thêm hành vi cho đối tượng mà không cần kế thừa",
            "Cho phép các đối tượng phụ (Observers) theo dõi và cập nhật khi chủ thể (Subject) thay đổi",
            "Đóng gói một yêu cầu dưới dạng đối tượng",
            "Kết nối nhiều giao diện khác nhau"
          ],
          "correctAnswer": "Cho phép các đối tượng phụ (Observers) theo dõi và cập nhật khi chủ thể (Subject) thay đổi",
          "reason": "Observer pattern giúp thực hiện cơ chế publish-subscribe giữa Subject và Observers."
        },
        {
          "id": 69,
          "question": "Interface trong C# hoặc Java có thể chứa thuộc tính (property) hoặc biến instance không?",
          "options": [
            "Có thể, nếu được khai báo public",
            "Không thể, nó chỉ chứa hằng số hoặc phương thức abstract (trước Java 8)",
            "Có thể, nếu dùng từ khóa static",
            "Có thể, nếu dùng từ khóa volatile"
          ],
          "correctAnswer": "Không thể, nó chỉ chứa hằng số hoặc phương thức abstract (trước Java 8)",
          "reason": "Trước Java 8, interface chỉ có hằng số, phương thức trừu tượng; không có biến instance."
        },
        {
          "id": 70,
          "question": "Nguyên tắc “Open/Closed” (trong SOLID) gợi ý điều gì?",
          "options": [
            "Class nên mở cho việc kế thừa, đóng cho sự sử dụng",
            "Class nên mở cho extension, đóng cho modification",
            "Class không nên cho phép bất kỳ kế thừa nào",
            "Class chỉ chứa thuộc tính private"
          ],
          "correctAnswer": "Class nên mở cho extension, đóng cho modification",
          "reason": "Open/Closed Principle: có thể mở rộng tính năng mới mà không cần sửa mã gốc."
        },
        {
          "id": 71,
          "question": "Trong .NET, từ khóa 'sealed' khi khai báo class có nghĩa gì?",
          "options": [
            "Class này không thể tạo object",
            "Class này không thể bị kế thừa",
            "Class này buộc phải abstract",
            "Class này buộc phải interface"
          ],
          "correctAnswer": "Class này không thể bị kế thừa",
          "reason": "sealed class trong C# không cho phép bất kỳ lớp con kế thừa."
        },
        {
          "id": 72,
          "question": "Lợi ích của việc sử dụng interface thay vì lớp trừu tượng (trong một số trường hợp) là gì?",
          "options": [
            "Giảm tính linh hoạt",
            "Cho phép đa kế thừa về hành vi",
            "Tăng độ phụ thuộc giữa các lớp",
            "Không có ưu điểm nào"
          ],
          "correctAnswer": "Cho phép đa kế thừa về hành vi",
          "reason": "Một lớp có thể implements nhiều interface, giúp đa kế thừa hành vi."
        },
        {
          "id": 73,
          "question": "Phương thức tĩnh (static method) trong OOP có đặc điểm gì?",
          "options": [
            "Phải được override trong lớp con",
            "Không cần đối tượng để gọi",
            "Luôn là phương thức ảo (virtual)",
            "Không thể truy cập thuộc tính tĩnh"
          ],
          "correctAnswer": "Không cần đối tượng để gọi",
          "reason": "Static method thuộc về lớp, được gọi qua tên lớp, không cần instance."
        },
        {
          "id": 74,
          "question": "Constructor overloading có nghĩa là gì?",
          "options": [
            "Nhiều phương thức khởi tạo cùng tên nhưng khác tham số",
            "Ghi đè phương thức khởi tạo lớp cha",
            "Khởi tạo lớp con từ lớp cha",
            "Không có nghĩa trong OOP"
          ],
          "correctAnswer": "Nhiều phương thức khởi tạo cùng tên nhưng khác tham số",
          "reason": "Overloading constructor cho phép tạo đối tượng với các tham số khác nhau."
        },
        {
          "id": 75,
          "question": "“IS-A” relationship trong OOP đề cập đến điều gì?",
          "options": [
            "Kết hợp (composition)",
            "Kế thừa (inheritance)",
            "Phương thức trừu tượng",
            "Giao diện"
          ],
          "correctAnswer": "Kế thừa (inheritance)",
          "reason": "IS-A mô tả quan hệ kế thừa: Dog IS-A Animal."
        },
        {
          "id": 76,
          "question": "“HAS-A” relationship trong OOP đề cập đến điều gì?",
          "options": [
            "Kế thừa (inheritance)",
            "Đa hình (polymorphism)",
            "Gộp (composition) hoặc kết hợp (aggregation)",
            "Trừu tượng (abstraction)"
          ],
          "correctAnswer": "Gộp (composition) hoặc kết hợp (aggregation)",
          "reason": "HAS-A mô tả đối tượng này chứa đối tượng khác, ví dụ Car HAS-A Engine."
        },
        {
          "id": 77,
          "question": "Khi lớp con ghi đè phương thức của lớp cha, từ khóa nào được dùng trong C#?",
          "options": ["override", "overload", "virtual", "sealed"],
          "correctAnswer": "override",
          "reason": "Để ghi đè trong C#, lớp cha khai báo phương thức virtual, lớp con dùng override."
        },
        {
          "id": 78,
          "question": "Trong Java, từ khóa nào để gọi trực tiếp phương thức/biến của lớp cha?",
          "options": ["this", "super", "parent", "extends"],
          "correctAnswer": "super",
          "reason": "super dùng để gọi constructor hoặc phương thức của lớp cha trong Java."
        },
        {
          "id": 79,
          "question": "Nguyên tắc Liskov Substitution (SOLID) yêu cầu điều gì?",
          "options": [
            "Lớp con phải thay thế được lớp cha mà không làm sai logic",
            "Lớp con chỉ kế thừa phương thức công cộng",
            "Phương thức tĩnh không bị ghi đè",
            "Không sử dụng đa kế thừa"
          ],
          "correctAnswer": "Lớp con phải thay thế được lớp cha mà không làm sai logic",
          "reason": "LSP: Subclass có thể dùng thay superclass mà không phá vỡ tính đúng của chương trình."
        },
        {
          "id": 80,
          "question": "Dependency Inversion Principle (SOLID) đề xuất điều gì?",
          "options": [
            "Module cấp cao không nên phụ thuộc module cấp thấp, cả hai nên phụ thuộc abstraction",
            "Mọi class đều phải có interface",
            "Hạn chế dùng constructor",
            "Ưu tiên kiểu dữ liệu nguyên thủy"
          ],
          "correctAnswer": "Module cấp cao không nên phụ thuộc module cấp thấp, cả hai nên phụ thuộc abstraction",
          "reason": "DIP: Giảm phụ thuộc cụ thể, tăng tính linh hoạt, module cấp cao và cấp thấp cùng dựa trên abstraction."
        },
        {
          "id": 81,
          "question": "Trong OOP, “throw” thường được dùng để làm gì?",
          "options": [
            "Gửi một gói tin trong mạng",
            "Ném ngoại lệ (exception)",
            "Kết thúc chương trình ngay lập tức",
            "Tạo đối tượng mới"
          ],
          "correctAnswer": "Ném ngoại lệ (exception)",
          "reason": "“throw” được dùng để kích hoạt một ngoại lệ, báo lỗi hoặc tình huống đặc biệt."
        },
        {
          "id": 82,
          "question": "“try-catch” block trong OOP nhằm mục đích nào?",
          "options": [
            "Kiểm tra chính tả trong code",
            "Bắt và xử lý ngoại lệ khi chạy chương trình",
            "Khai báo biến tĩnh",
            "Định nghĩa lớp cha"
          ],
          "correctAnswer": "Bắt và xử lý ngoại lệ khi chạy chương trình",
          "reason": "try-catch dùng để bắt exception, tránh chương trình bị crash đột ngột."
        },
        {
          "id": 83,
          "question": "Mục đích của destructor (C++), finalizer (C#) là gì?",
          "options": [
            "Khởi tạo đối tượng",
            "Hủy đối tượng, giải phóng tài nguyên",
            "Ghi đè phương thức",
            "Tạo interface"
          ],
          "correctAnswer": "Hủy đối tượng, giải phóng tài nguyên",
          "reason": "Destructor được gọi khi đối tượng bị xóa khỏi bộ nhớ, dọn dẹp tài nguyên."
        },
        {
          "id": 84,
          "question": "Trong Python, từ khóa nào được dùng để khai báo class kế thừa một lớp khác?",
          "options": [
            "inherit",
            "extends",
            "super",
            "class MySubClass(ParentClass):"
          ],
          "correctAnswer": "class MySubClass(ParentClass):",
          "reason": "Python kế thừa bằng cách đặt lớp cha trong ngoặc tròn khi khai báo lớp con."
        },
        {
          "id": 85,
          "question": "Trong Java, lớp nào là lớp cha tối cao của mọi lớp?",
          "options": ["Object", "Base", "Super", "Class"],
          "correctAnswer": "Object",
          "reason": "Trong Java, java.lang.Object là lớp cha của mọi lớp."
        },
        {
          "id": 86,
          "question": "Khi nào nên sử dụng Abstract Class thay vì Interface?",
          "options": [
            "Khi cần đa kế thừa nhiều hành vi",
            "Khi cần một số phương thức đã triển khai sẵn và một số trừu tượng",
            "Khi không muốn chia sẻ bất kỳ logic nào",
            "Khi không có thuộc tính chung"
          ],
          "correctAnswer": "Khi cần một số phương thức đã triển khai sẵn và một số trừu tượng",
          "reason": "Abstract class cho phép chứa cả phương thức có code và phương thức abstract."
        },
        {
          "id": 87,
          "question": "Tại sao chúng ta cần getter và setter thay vì dùng biến public?",
          "options": [
            "Vì biến public luôn nhanh hơn",
            "Getter, setter giúp kiểm soát cách truy cập và sửa dữ liệu, bảo mật hơn",
            "Không có sự khác biệt",
            "Vì chuẩn code yêu cầu"
          ],
          "correctAnswer": "Getter, setter giúp kiểm soát cách truy cập và sửa dữ liệu, bảo mật hơn",
          "reason": "Getter/Setter che giấu cài đặt nội bộ, hạn chế thay đổi trực tiếp dữ liệu."
        },
        {
          "id": 88,
          "question": "Trong mô hình OOP, ‘IS-A’ và ‘HAS-A’ có thể xuất hiện đồng thời không?",
          "options": [
            "Không bao giờ",
            "Có, một lớp vừa kế thừa lớp cha vừa có thành phần là đối tượng khác",
            "Chỉ khi dùng interface",
            "Chỉ khi dùng abstract class"
          ],
          "correctAnswer": "Có, một lớp vừa kế thừa lớp cha vừa có thành phần là đối tượng khác",
          "reason": "Một lớp có thể kế thừa (IS-A) và cũng có thuộc tính là đối tượng khác (HAS-A)."
        },
        {
          "id": 89,
          "question": "Nếu một lớp kế thừa từ lớp abstract, lớp con cần phải làm gì?",
          "options": [
            "Triển khai tất cả phương thức abstract hoặc cũng có thể khai báo abstract",
            "Không cần làm gì",
            "Phải chuyển thành interface",
            "Phải final"
          ],
          "correctAnswer": "Triển khai tất cả phương thức abstract hoặc cũng có thể khai báo abstract",
          "reason": "Lớp con phải ghi đè các phương thức abstract, nếu không sẽ phải khai báo lớp con cũng là abstract."
        },
        {
          "id": 90,
          "question": "Static binding và Dynamic binding trong OOP khác nhau thế nào?",
          "options": [
            "Static binding được quyết định lúc runtime, dynamic binding lúc compile-time",
            "Static binding được quyết định lúc compile-time, dynamic binding lúc runtime",
            "Chúng giống nhau",
            "Chỉ áp dụng cho biến chứ không áp dụng cho phương thức"
          ],
          "correctAnswer": "Static binding được quyết định lúc compile-time, dynamic binding lúc runtime",
          "reason": "Ví dụ overloading là static binding, overriding là dynamic binding."
        },
        {
          "id": 91,
          "question": "Khái niệm ‘coupling’ trong OOP đề cập đến điều gì?",
          "options": [
            "Độ phức tạp của thuật toán",
            "Mức độ phụ thuộc giữa các module hoặc lớp",
            "Số lượng biến static trong lớp",
            "Thời gian chạy của chương trình"
          ],
          "correctAnswer": "Mức độ phụ thuộc giữa các module hoặc lớp",
          "reason": "Coupling cao khiến hệ thống khó bảo trì, do các lớp phụ thuộc chặt chẽ nhau."
        },
        {
          "id": 92,
          "question": "Khái niệm ‘cohesion’ trong OOP đề cập đến điều gì?",
          "options": [
            "Sự gắn kết lỏng lẻo giữa các lớp",
            "Mức độ tập trung các trách nhiệm liên quan trong một module hoặc lớp",
            "Khả năng mở rộng của một lớp",
            "Cách thức một lớp gọi hàm tĩnh"
          ],
          "correctAnswer": "Mức độ tập trung các trách nhiệm liên quan trong một module hoặc lớp",
          "reason": "Cohesion cao khi một class chỉ làm đúng một việc, liên quan chặt chẽ giữa các thành phần bên trong."
        },
        {
          "id": 93,
          "question": "Design pattern ‘Decorator’ dùng để làm gì?",
          "options": [
            "Tạo một đối tượng duy nhất",
            "Thay đổi giao diện của một lớp thành giao diện khác",
            "Thêm chức năng mới cho đối tượng mà không thay đổi cấu trúc",
            "Ghép nhiều đối tượng thành cấu trúc cây"
          ],
          "correctAnswer": "Thêm chức năng mới cho đối tượng mà không thay đổi cấu trúc",
          "reason": "Decorator pattern bọc (wrap) đối tượng để mở rộng hành vi động (runtime)."
        },
        {
          "id": 94,
          "question": "Design pattern ‘Facade’ có mục đích gì?",
          "options": [
            "Cung cấp một giao diện đơn giản hơn cho một hệ thống phức tạp",
            "Tạo mới đối tượng thông qua một class trung gian",
            "Tạo một kênh liên lạc giữa các observer",
            "Phân chia trách nhiệm cho nhiều class"
          ],
          "correctAnswer": "Cung cấp một giao diện đơn giản hơn cho một hệ thống phức tạp",
          "reason": "Facade ẩn sự phức tạp của hệ thống, cung cấp giao diện nhất quán cho client."
        },
        {
          "id": 95,
          "question": "Pattern ‘Strategy’ cho phép làm gì?",
          "options": [
            "Cung cấp cơ chế thay đổi thuật toán thực thi tại runtime",
            "Tạo cầu nối giữa hai giao diện không tương thích",
            "Giám sát sự thay đổi trạng thái trong đối tượng chủ thể",
            "Phân cấp lớp và interface"
          ],
          "correctAnswer": "Cung cấp cơ chế thay đổi thuật toán thực thi tại runtime",
          "reason": "Strategy đóng gói các thuật toán khác nhau, cho phép thay đổi linh hoạt."
        },
        {
          "id": 96,
          "question": "Trong OOP, ‘public static void main(String[] args)’ (Java) là gì?",
          "options": [
            "Phương thức khởi tạo đối tượng",
            "Điểm bắt đầu thực thi chương trình",
            "Interface trừu tượng",
            "Tên lớp con"
          ],
          "correctAnswer": "Điểm bắt đầu thực thi chương trình",
          "reason": "Phương thức main là entry point khi chạy ứng dụng Java."
        },
        {
          "id": 97,
          "question": "Ngôn ngữ nào hỗ trợ đa kế thừa lớp (multiple inheritance) một cách trực tiếp?",
          "options": ["Java", "C++", "C#", "VB.NET"],
          "correctAnswer": "C++",
          "reason": "C++ cho phép một lớp kế thừa từ nhiều lớp cha, Java và C# thì không."
        },
        {
          "id": 98,
          "question": "Đối tượng thi hành interface Runnable trong Java thường được dùng cho mục đích gì?",
          "options": [
            "Xử lý ngoại lệ",
            "Nạp chồng hàm tạo",
            "Tạo luồng (thread)",
            "Bảo mật dữ liệu"
          ],
          "correctAnswer": "Tạo luồng (thread)",
          "reason": "Runnable định nghĩa phương thức run(), được Thread sử dụng để chạy luồng."
        },
        {
          "id": 99,
          "question": "Phương thức finalize() trong Java được gọi khi nào?",
          "options": [
            "Khi khởi tạo đối tượng",
            "Khi chạy hàm main",
            "Ngay lập tức sau khi vứt ngoại lệ",
            "Trước khi Garbage Collector xóa đối tượng"
          ],
          "correctAnswer": "Trước khi Garbage Collector xóa đối tượng",
          "reason": "finalize() được gọi bởi GC trước khi giải phóng bộ nhớ cho đối tượng (tuy nhiên không nên lạm dụng)."
        },
        {
          "id": 100,
          "question": "Trong lập trình hướng đối tượng, khái niệm ‘coupling thấp, cohesion cao’ mang lại lợi ích gì?",
          "options": [
            "Mã nguồn dễ bảo trì, dễ mở rộng",
            "Mã nguồn phức tạp khó đọc",
            "Giảm tính bảo mật",
            "Tăng độ chặt chẽ giữa các lớp"
          ],
          "correctAnswer": "Mã nguồn dễ bảo trì, dễ mở rộng",
          "reason": "Coupling thấp, cohesion cao là mục tiêu thiết kế OOP, giúp hệ thống linh hoạt và dễ quản lý."
        }
      ]
    },
    {
      "id": 16,
      "title": "Data Structures & Algorithms Quiz",
      "timeLimit": 3600,
      "questions": [
        {
          "id": 1,
          "question": "Cấu trúc dữ liệu nào phù hợp nhất để triển khai hàng đợi (Queue)?",
          "options": [
            "Mảng (Array)",
            "Danh sách liên kết (Linked List)",
            "Stack",
            "Cây nhị phân (Binary Tree)"
          ],
          "correctAnswer": "Danh sách liên kết (Linked List)",
          "reason": "Hàng đợi có thể được triển khai bằng danh sách liên kết để thao tác nhanh ở hai đầu."
        },
        {
          "id": 2,
          "question": "Đâu là đặc điểm chính của Stack?",
          "options": [
            "FIFO (First In First Out)",
            "LIFO (Last In First Out)",
            "Truy cập ngẫu nhiên (Random Access)",
            "Ưu tiên phần tử nhỏ nhất"
          ],
          "correctAnswer": "LIFO (Last In First Out)",
          "reason": "Stack tuân theo cơ chế LIFO: phần tử được đẩy (push) cuối sẽ được lấy (pop) ra đầu tiên."
        },
        {
          "id": 3,
          "question": "Phép duyệt cây tiền thứ tự (Pre-order) thông thường được mô tả theo thứ tự nào?",
          "options": [
            "Root -> Left -> Right",
            "Left -> Root -> Right",
            "Left -> Right -> Root",
            "Right -> Root -> Left"
          ],
          "correctAnswer": "Root -> Left -> Right",
          "reason": "Duyệt tiền thứ tự: thăm gốc trước, sau đó nhánh trái, rồi nhánh phải."
        },
        {
          "id": 4,
          "question": "Trong danh sách liên kết đơn (Singly Linked List), đâu là thao tác chèn (insert) vào đầu danh sách?",
          "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
          "correctAnswer": "O(1)",
          "reason": "Chèn vào đầu danh sách liên kết đơn chỉ cần thay đổi một vài con trỏ, do đó chi phí O(1)."
        },
        {
          "id": 5,
          "question": "Thuật toán sắp xếp nào có thời gian trung bình (average case) là O(n log n) và thường được dùng nhiều trong thực tế?",
          "options": [
            "Bubble Sort",
            "Insertion Sort",
            "Merge Sort",
            "Quick Sort"
          ],
          "correctAnswer": "Quick Sort",
          "reason": "Quick Sort có thời gian trung bình O(n log n), cài đặt đơn giản và chạy nhanh với dữ liệu ngẫu nhiên."
        },
        {
          "id": 6,
          "question": "Đâu là phương pháp duyệt đồ thị theo chiều rộng?",
          "options": [
            "BFS (Breadth-First Search)",
            "DFS (Depth-First Search)",
            "Dijkstra",
            "Prim"
          ],
          "correctAnswer": "BFS (Breadth-First Search)",
          "reason": "BFS duyệt đồ thị theo lớp (layer), tức là theo chiều rộng, dùng queue làm cấu trúc hỗ trợ."
        },
        {
          "id": 7,
          "question": "Khi chèn một phần tử vào Heap nhị phân (Binary Heap - Min-Heap), ta cần đảm bảo điều gì?",
          "options": [
            "Phần tử mới được chèn vào vị trí bất kì",
            "Cấu trúc cây vẫn là binary tree đầy đủ (complete), và tính chất min-heap được duy trì",
            "Không được chèn quá 2 phần tử",
            "Trộn với max-heap"
          ],
          "correctAnswer": "Cấu trúc cây vẫn là binary tree đầy đủ (complete), và tính chất min-heap được duy trì",
          "reason": "Heap nhị phân yêu cầu hình dạng complete binary tree và tính chất so sánh cha < con (min-heap) hoặc ngược lại (max-heap)."
        },
        {
          "id": 8,
          "question": "Thao tác tìm phần tử lớn nhất trong Max-Heap có độ phức tạp bao nhiêu?",
          "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
          "correctAnswer": "O(1)",
          "reason": "Trong Max-Heap, phần tử lớn nhất nằm ở gốc (root), nên tìm thấy ngay lập tức."
        },
        {
          "id": 9,
          "question": "Hash Table sử dụng cơ chế nào để truy xuất dữ liệu nhanh?",
          "options": [
            "Tìm kiếm nhị phân",
            "Hàng đợi ưu tiên",
            "Tính toán hàm băm (hash function) và phân chia theo bucket",
            "Duyệt tuyến tính"
          ],
          "correctAnswer": "Tính toán hàm băm (hash function) và phân chia theo bucket",
          "reason": "Hash Table dùng hàm băm để ánh xạ key vào vị trí lưu trữ (bucket)."
        },
        {
          "id": 10,
          "question": "Độ phức tạp trung bình (average case) của thao tác tìm kiếm trên Hash Table (với phương pháp xử lý xung đột hợp lý) là bao nhiêu?",
          "options": ["O(1)", "O(log n)", "O(n)", "O(n^2)"],
          "correctAnswer": "O(1)",
          "reason": "Trong trường hợp hàm băm tốt, số xung đột ít, thao tác tìm kiếm trung bình là O(1)."
        },
        {
          "id": 11,
          "question": "Đối với danh sách liên kết kép (Doubly Linked List), việc xóa một node ở giữa (khi đã có con trỏ đến node đó) có độ phức tạp là bao nhiêu?",
          "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
          "correctAnswer": "O(1)",
          "reason": "Nếu đã trỏ đến đúng node, chỉ cần cập nhật hai liên kết (prev, next) là đủ."
        },
        {
          "id": 12,
          "question": "DFS (Depth-First Search) sử dụng cấu trúc dữ liệu nào để hỗ trợ quá trình duyệt?",
          "options": [
            "Queue",
            "Stack (hoặc recursion)",
            "Priority Queue",
            "Hash Table"
          ],
          "correctAnswer": "Stack (hoặc recursion)",
          "reason": "DFS lần lượt đi sâu theo hướng node con, thường triển khai bằng Stack hoặc đệ quy."
        },
        {
          "id": 13,
          "question": "Đâu là cách tốt nhất để lưu trữ biểu diễn đồ thị dày đặc (dense graph) có nhiều cạnh?",
          "options": [
            "Danh sách kề (Adjacency List)",
            "Ma trận kề (Adjacency Matrix)",
            "Danh sách liên kết đơn",
            "Stack"
          ],
          "correctAnswer": "Ma trận kề (Adjacency Matrix)",
          "reason": "Đồ thị dày đặc có nhiều cạnh, ma trận kề (n*n) sẽ tiện lợi hơn thay vì danh sách kề."
        },
        {
          "id": 14,
          "question": "Cấu trúc dữ liệu nào thuận tiện nhất để triển khai Undo/Redo trong các ứng dụng?",
          "options": ["Queue", "Two Stacks", "Linked List", "HashMap"],
          "correctAnswer": "Two Stacks",
          "reason": "Undo/Redo thường được triển khai bằng hai stack: một stack cho lệnh Undo, một stack cho lệnh Redo."
        },
        {
          "id": 15,
          "question": "Đâu không phải là thuật toán sắp xếp kiểu so sánh (Comparison-based)?",
          "options": ["Merge Sort", "Quick Sort", "Radix Sort", "Heap Sort"],
          "correctAnswer": "Radix Sort",
          "reason": "Radix Sort là thuật toán sắp xếp không dựa vào so sánh, mà dựa trên chữ số/bit của phần tử."
        },
        {
          "id": 16,
          "question": "Thuật toán tìm kiếm nhị phân (Binary Search) yêu cầu điều gì trên dữ liệu đầu vào?",
          "options": [
            "Dữ liệu được sắp xếp",
            "Dữ liệu chỉ chứa số nguyên",
            "Dữ liệu không trùng lặp",
            "Dữ liệu lưu trong stack"
          ],
          "correctAnswer": "Dữ liệu được sắp xếp",
          "reason": "Binary Search đòi hỏi mảng đã được sắp xếp trước để chia đôi và loại bỏ nửa không liên quan."
        },
        {
          "id": 17,
          "question": "Thời gian chạy trung bình (average case) của thuật toán tìm kiếm tuần tự (Linear Search) là bao nhiêu?",
          "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
          "correctAnswer": "O(n)",
          "reason": "Linear Search so sánh tuần tự, trung bình phải duyệt khoảng n/2 phần tử, độ phức tạp O(n)."
        },
        {
          "id": 18,
          "question": "Cấu trúc dữ liệu nào tối ưu cho việc lấy phần tử lớn nhất/nhỏ nhất thường xuyên?",
          "options": [
            "Queue",
            "Binary Search Tree (BST)",
            "Priority Queue (Min-Heap hoặc Max-Heap)",
            "Linked List"
          ],
          "correctAnswer": "Priority Queue (Min-Heap hoặc Max-Heap)",
          "reason": "Priority Queue (dùng Heap) cho phép lấy phần tử lớn nhất/nhỏ nhất hiệu quả (O(1))."
        },
        {
          "id": 19,
          "question": "Để xác định đường đi ngắn nhất từ một đỉnh đến các đỉnh khác trong đồ thị không trọng số (unweighted), ta có thể dùng?",
          "options": ["DFS", "BFS", "Dijkstra", "Bellman-Ford"],
          "correctAnswer": "BFS",
          "reason": "Trong đồ thị không trọng số, BFS tìm đường đi ngắn nhất theo số cạnh rất hiệu quả."
        },
        {
          "id": 20,
          "question": "Đâu là thuật toán tham lam (Greedy) để tìm cây khung nhỏ nhất (Minimum Spanning Tree)?",
          "options": [
            "Prim hoặc Kruskal",
            "DFS",
            "Bellman-Ford",
            "Floyd-Warshall"
          ],
          "correctAnswer": "Prim hoặc Kruskal",
          "reason": "Cả Prim và Kruskal đều là các giải thuật tham lam giúp tìm MST."
        },
        {
          "id": 21,
          "question": "Xét mảng [5, 2, 9, 1]. Ứng dụng Bubble Sort, sau lần lặp (pass) thứ nhất, mảng trở thành gì?",
          "options": [
            "[2, 5, 9, 1]",
            "[2, 1, 9, 5]",
            "[5, 2, 1, 9]",
            "[2, 9, 1, 5]"
          ],
          "correctAnswer": "[2, 5, 1, 9]",
          "reason": "Với Bubble Sort, qua pass đầu, phần tử lớn nhất (9) sẽ 'nổi' về cuối, thứ tự: so sánh (5,2) -> (2,5), (5,9) -> (5,9), (9,1) -> (1,9). Kết quả: [2, 5, 1, 9]."
        },
        {
          "id": 22,
          "question": "Với thuật toán Insertion Sort, bao nhiêu lần so sánh được thực hiện (worst case) khi sắp xếp mảng có n phần tử?",
          "options": ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"],
          "correctAnswer": "O(n^2)",
          "reason": "Trong tình huống xấu nhất (mảng ngược), Insertion Sort phải so sánh/lùi các phần tử dẫn đến O(n^2)."
        },
        {
          "id": 23,
          "question": "Với mảng [10, 8, 4, 3, 1], nếu áp dụng Tìm kiếm nhị phân (Binary Search) để tìm giá trị 4, ta cần dữ liệu đầu vào như thế nào để đúng yêu cầu?",
          "options": [
            "Không cần sắp xếp, chỉ cần chia đôi",
            "Sắp xếp tăng dần, ví dụ [1, 3, 4, 8, 10]",
            "Sắp xếp giảm dần, ví dụ [10, 8, 4, 3, 1]",
            "Xếp thứ tự bất kì, miễn chứa 4"
          ],
          "correctAnswer": "Sắp xếp tăng dần, ví dụ [1, 3, 4, 8, 10]",
          "reason": "Binary Search yêu cầu mảng đã sắp xếp, thường là sắp xếp tăng dần."
        },
        {
          "id": 24,
          "question": "Có mảng A = [1, 2, 3, 4, 5]. Nếu ta dùng Linear Search để tìm phần tử 5 trong trường hợp xấu nhất, số lần so sánh là bao nhiêu?",
          "options": ["1", "3", "4", "5"],
          "correctAnswer": "5",
          "reason": "Trường hợp xấu nhất, phải so sánh với mọi phần tử (5 lần) mới tìm thấy giá trị cần."
        },
        {
          "id": 25,
          "question": "Cho mảng [2, 7, 4, 1], áp dụng Selection Sort (chọn phần tử nhỏ nhất đưa lên đầu) sau vòng lặp (i=0), mảng thành gì?",
          "options": [
            "[1, 7, 4, 2]",
            "[2, 7, 4, 1]",
            "[1, 2, 7, 4]",
            "[4, 2, 1, 7]"
          ],
          "correctAnswer": "[1, 7, 4, 2]",
          "reason": "Selection Sort vòng lặp đầu tìm min (1), đổi chỗ với phần tử đầu (2), được [1, 7, 4, 2]."
        },
        {
          "id": 26,
          "question": "Nếu dùng Merge Sort để sắp xếp mảng 8 phần tử, độ sâu của đệ quy (recursive depth) tối đa là bao nhiêu (log2(8))?",
          "options": ["1", "2", "3", "4"],
          "correctAnswer": "3",
          "reason": "8 phần tử chia đôi log2(8) = 3, tức chia đến mảng 1 phần tử thì dừng."
        },
        {
          "id": 27,
          "question": "Trong cây nhị phân tìm kiếm (Binary Search Tree), phần tử nhỏ nhất nằm ở đâu?",
          "options": [
            "Cành phải xa nhất",
            "Cành trái xa nhất",
            "Ở gốc",
            "Ở giữa"
          ],
          "correctAnswer": "Cành trái xa nhất",
          "reason": "Trong BST, các node bên trái có giá trị nhỏ hơn node gốc, nên nhỏ nhất nằm cực trái."
        },
        {
          "id": 28,
          "question": "Độ phức tạp tìm kiếm trung bình trong Binary Search Tree (BST) cân bằng tốt là bao nhiêu?",
          "options": ["O(1)", "O(log n)", "O(n)", "O(n^2)"],
          "correctAnswer": "O(log n)",
          "reason": "BST cân bằng tốt có chiều cao ~ log n, tìm kiếm trung bình O(log n)."
        },
        {
          "id": 29,
          "question": "Khi triển khai danh sách liên kết đơn, đâu là thao tác phức tạp nhất (O(n)) nếu ta chỉ có con trỏ đầu (head)?",
          "options": [
            "Thêm vào đầu",
            "Xóa đầu",
            "Xóa cuối",
            "Duyệt và in danh sách"
          ],
          "correctAnswer": "Xóa cuối",
          "reason": "Phải duyệt hết danh sách đến node kế cuối để điều chỉnh liên kết, mất O(n)."
        },
        {
          "id": 30,
          "question": "Trong cấu trúc dữ liệu Trie (prefix tree), mỗi nút con tương ứng với điều gì?",
          "options": [
            "Một ký tự (character)",
            "Một số nguyên",
            "Một giá trị băm (hash)",
            "Một phần tử ngẫu nhiên"
          ],
          "correctAnswer": "Một ký tự (character)",
          "reason": "Trie thường dùng để lưu trữ chuỗi, mỗi nhánh con biểu thị một ký tự tiếp theo."
        },
        {
          "id": 31,
          "question": "Thuật toán Floyd-Warshall dùng để giải quyết bài toán gì?",
          "options": [
            "Cây khung nhỏ nhất (MST)",
            "Đường đi ngắn nhất giữa mọi cặp đỉnh (All-pairs shortest path)",
            "Sắp xếp trong mảng",
            "Đếm số thành phần liên thông"
          ],
          "correctAnswer": "Đường đi ngắn nhất giữa mọi cặp đỉnh (All-pairs shortest path)",
          "reason": "Floyd-Warshall tìm đường đi ngắn nhất cho mọi cặp đỉnh trong đồ thị có trọng số (có thể âm)."
        },
        {
          "id": 32,
          "question": "Trong sắp xếp Heap Sort, bước đầu tiên là gì?",
          "options": [
            "Xây dựng một Max-Heap từ mảng ban đầu",
            "Chia mảng thành hai nửa",
            "Đệ quy xử lý n-1 phần tử",
            "Tạo một mảng tạm thời"
          ],
          "correctAnswer": "Xây dựng một Max-Heap từ mảng ban đầu",
          "reason": "Bước đầu Heap Sort: build heap để đưa phần tử lớn nhất lên root trước."
        },
        {
          "id": 33,
          "question": "Một thuật toán có độ phức tạp O(n^3). Nếu đầu vào tăng gấp đôi, thời gian chạy sẽ tăng như thế nào (xấp xỉ)?",
          "options": ["Gấp 2 lần", "Gấp 4 lần", "Gấp 6 lần", "Gấp 8 lần"],
          "correctAnswer": "Gấp 8 lần",
          "reason": "O(n^3) nghĩa là khi n tăng gấp đôi, thời gian tăng khoảng 2^3 = 8 lần."
        },
        {
          "id": 34,
          "question": "Độ phức tạp thời gian của thuật toán Quick Sort trong trường hợp xấu nhất (worst case) là bao nhiêu?",
          "options": ["O(n)", "O(n log n)", "O(n^2)", "O(1)"],
          "correctAnswer": "O(n^2)",
          "reason": "Nếu chọn pivot xấu liên tục (mảng gần như đã sắp xếp), Quick Sort trở thành O(n^2)."
        },
        {
          "id": 35,
          "question": "Khi triển khai Stack bằng mảng, nếu mảng đầy mà ta vẫn cố push một phần tử, điều gì xảy ra?",
          "options": [
            "Phát sinh lỗi tràn (stack overflow)",
            "Stack tự động tăng kích thước",
            "Phần tử tự động ghi đè lên vị trí đầu",
            "Xóa phần tử cuối"
          ],
          "correctAnswer": "Phát sinh lỗi tràn (stack overflow)",
          "reason": "Stack tĩnh (mảng) có giới hạn, push thêm gây lỗi tràn."
        },
        {
          "id": 36,
          "question": "Kỹ thuật phân mảnh (partition) trong Quick Sort nhằm mục đích gì?",
          "options": [
            "Tách dữ liệu thành 3 phần bằng nhau",
            "Đưa pivot về vị trí chính xác, trái < pivot < phải",
            "Trộn hai mảng đã sắp xếp",
            "Chọn phần tử nhỏ nhất đưa về đầu"
          ],
          "correctAnswer": "Đưa pivot về vị trí chính xác, trái < pivot < phải",
          "reason": "Partition chia mảng thành 2 bên so với pivot, pivot về đúng vị trí cuối cùng."
        },
        {
          "id": 37,
          "question": "Cho mảng [1, 3, 5, 7, 9]. Nếu chạy Binary Search để tìm giá trị 3, ta cần tối đa bao nhiêu phép so sánh?",
          "options": ["1", "2", "3", "4"],
          "correctAnswer": "2",
          "reason": "Lần 1 so sánh pivot (vị trí giữa = 5). Thấy 3 < 5 nên tìm nửa trái [1, 3], lần 2 so sánh 3 == 3."
        },
        {
          "id": 38,
          "question": "Trong mảng [2, 5, 7, 9, 11], nếu dùng Linear Search tìm 7, thứ tự so sánh lần lượt là gì (best case k=1, average n/2)?",
          "options": [
            "So sánh 2, 5, 7 -> tìm thấy",
            "So sánh 2, 5, 7, 9 -> tìm thấy",
            "So sánh 2 -> tìm thấy",
            "So sánh 2, 5, 7, 9, 11 -> tìm thấy"
          ],
          "correctAnswer": "So sánh 2, 5, 7 -> tìm thấy",
          "reason": "Linear Search duyệt tuần tự: 2 != 7, 5 != 7, 7 == 7 -> dừng."
        },
        {
          "id": 39,
          "question": "Trong B-Tree (cấu trúc cây cho database/index), một node có thể chứa bao nhiêu key?",
          "options": [
            "Không giới hạn",
            "Tối thiểu t-1, tối đa 2t-1 (với bậc t)",
            "1 đến 2 key",
            "Chỉ chứa 1 key"
          ],
          "correctAnswer": "Tối thiểu t-1, tối đa 2t-1 (với bậc t)",
          "reason": "Với B-Tree bậc t, mỗi node (trừ root) có số key từ [t-1..2t-1]."
        },
        {
          "id": 40,
          "question": "Độ phức tạp chèn một phần tử vào danh sách liên kết đơn (singly linked list) ở cuối (khi chỉ có con trỏ head) là?",
          "options": ["O(1)", "O(log n)", "O(n)", "O(n^2)"],
          "correctAnswer": "O(n)",
          "reason": "Phải duyệt đến node cuối cùng rồi mới gắn node mới, mất thời gian O(n)."
        },
        {
          "id": 41,
          "question": "Cho mảng [4, 2, 6, 1]. Nếu áp dụng Merge Sort, sau bước chia nhỏ đệ quy (trước khi trộn), mảng sẽ được chia tối đa thành các mảng con như thế nào?",
          "options": [
            "[4], [2, 6, 1]",
            "[4, 2], [6, 1]",
            "[4], [2], [6], [1]",
            "[1, 2, 4, 6]"
          ],
          "correctAnswer": "[4], [2], [6], [1]",
          "reason": "Merge Sort chia đôi liên tiếp đến khi mảng còn 1 phần tử: [4], [2], [6], [1]."
        },
        {
          "id": 42,
          "question": "Nếu ta áp dụng Heap Sort cho mảng [3, 1, 4, 2], sau bước build Max-Heap, phần tử nào sẽ nằm ở gốc (root)?",
          "options": ["1", "2", "3", "4"],
          "correctAnswer": "4",
          "reason": "Max-Heap đặt phần tử lớn nhất làm gốc, ở đây là 4."
        },
        {
          "id": 43,
          "question": "Trong một Binary Search Tree (BST), nếu ta duyệt trung thứ tự (In-order), ta thu được gì?",
          "options": [
            "Danh sách các giá trị giảm dần",
            "Danh sách các giá trị đã sắp xếp tăng dần",
            "Danh sách các giá trị ngẫu nhiên",
            "Danh sách các cặp khóa-giá trị"
          ],
          "correctAnswer": "Danh sách các giá trị đã sắp xếp tăng dần",
          "reason": "Duyệt In-order BST sẽ thu được các giá trị theo thứ tự tăng dần."
        },
        {
          "id": 44,
          "question": "Queue tuân theo quy tắc nào?",
          "options": ["LIFO", "FIFO", "Ưu tiên lớn nhất", "Ưu tiên nhỏ nhất"],
          "correctAnswer": "FIFO",
          "reason": "Queue: First In, First Out (phần tử vào trước ra trước)."
        },
        {
          "id": 45,
          "question": "Để kiểm tra biểu thức ngoặc đúng/sai (như ‘(a+b)*[c-d]’), ta dùng cấu trúc dữ liệu nào đơn giản nhất?",
          "options": ["Queue", "Stack", "Hash Map", "Array sắp xếp"],
          "correctAnswer": "Stack",
          "reason": "Khi gặp mở ngoặc, push, gặp đóng ngoặc, pop và kiểm tra cặp tương ứng."
        },
        {
          "id": 46,
          "question": "Trong danh sách liên kết đơn, muốn lấy phần tử k-th, ta cần thời gian bao nhiêu?",
          "options": ["O(1)", "O(k)", "O(log k)", "O(n^2)"],
          "correctAnswer": "O(k)",
          "reason": "Phải duyệt tuần tự từ đầu tới vị trí k-th, mất O(k)."
        },
        {
          "id": 47,
          "question": "Đâu không phải là tính chất của Red-Black Tree?",
          "options": [
            "Mọi nút đều có màu Đỏ hoặc Đen",
            "Root luôn màu Đen",
            "Đường từ Root đến lá có số nút Đen giống nhau",
            "Không cho phép 2 nút liền kề cùng màu Đen"
          ],
          "correctAnswer": "Không cho phép 2 nút liền kề cùng màu Đen",
          "reason": "Quy tắc Red-Black: Không cho phép 2 nút đỏ liền kề, còn đen thì được."
        },
        {
          "id": 48,
          "question": "Độ phức tạp thuật toán sắp xếp Radix Sort khi xử lý n số nguyên (có k chữ số) là?",
          "options": ["O(n log n)", "O(nk)", "O(n^2)", "O(k^2)"],
          "correctAnswer": "O(nk)",
          "reason": "Radix Sort quét từng chữ số của tất cả n phần tử, độ phức tạp ~ O(nk)."
        },
        {
          "id": 49,
          "question": "Để duy trì một lịch sử lệnh (history) có thể 'quay lại' và 'tiến tới' như trên trình duyệt web, ta có thể dùng?",
          "options": [
            "Hai Stack (Back stack, Forward stack)",
            "Một Queue",
            "Một mảng tĩnh",
            "Một Hash Table"
          ],
          "correctAnswer": "Hai Stack (Back stack, Forward stack)",
          "reason": "Cơ chế back-forward tương tự Undo/Redo, dùng 2 Stack."
        },
        {
          "id": 50,
          "question": "Xét mảng [9, 7, 3, 1]. Với Bubble Sort, để mảng được sắp xếp tăng dần hoàn chỉnh, cần tối đa bao nhiêu lần lặp (pass)?",
          "options": ["1", "2", "3", "4"],
          "correctAnswer": "3",
          "reason": "Bubble Sort cho mảng 4 phần tử cần tối đa n-1 = 3 pass để đảm bảo sắp xếp hoàn tất trong trường hợp xấu nhất."
        }
      ]
    }
  ]
}
